Django ORM
========================
---
## select_related и prefetch_related

В Django select_related и prefetch_related предназначены для остановки потока запросов к базе данных, вызванных доступом к связанным объектам.

### select_related
Мы используем select_related, когда объект, который вы собираетесь выбрать, является одним объектом, что означает пересылку ForeignKey, OneToOne и обратный OneToOne.

select_related работает путем создания соединения SQL и включения полей связанного объекта в оператор SELECT. По этой причине select_related получает связанные объекты в том же запросе к базе данных.
```
queryset = Book.objects.all()
for book in queryset:
        books.append({'id': book.id, 'name': book.name)

Number of SQL Queries : 101        
```
Один запрос для заполнения всех книг и, выполняя итерацию каждый раз, мы получаем доступ к издателю, который выполняет другой отдельный запрос.

Давайте изменим запрос с помощью select_related следующим образом и посмотрим, что произойдет.

```
queryset = Book.objects.select_related('publisher').all()
for book in queryset:
        books.append({'id': book.id, 'name': book.name)

Number of SQL Queries : 1
        
```
### prefetch_related
Мы используем prefetch_related, когда собираемся получить набор вещей.

Это означает обработку ManyToMany и обратных ManyToMany, ForeignKey. prefetch_related выполняет отдельный поиск для каждой связи и выполняет «объединение» в Python.

Он отличается от select_related. prefetch_related выполнял JOIN с использованием Python, а не в базе данных.
```
queryset = Store.objects.all()
for store in queryset:
        books = [book.name for book in store.books.all()]
        stores.append({'id': store.id, 'name': store.name, 'books': books})

Number of Queries : 11
```
У нас в базе 10 магазинов и в каждом магазине по 10 книг. Здесь происходит один запрос для выборки всех хранилищ, и во время итерации по каждому хранилищу выполняется другой запрос, когда мы получаем доступ к полю books ManyToMany.

Давайте уменьшим количество запросов с помощью prefetch_related.

```
queryset = Store.objects.prefetch_related('books')
    for store in queryset:
        books = [book.name for book in store.books.all()]
        stores.append({'id': store.id, 'name': store.name, 'books': books})

Number of Queries : 2
```
Здесь производительность запросов улучшилась, с 11 до 2 запросов. Я хочу, чтобы вы поняли, что здесь делает prefetch_related.

Возьмем еще один пример для prefetch_related.

В коде команды управления я произвольно устанавливаю цену книги от 50 до 300. Теперь мы найдем дорогие книги (цена от 250 до 300) в каждом магазине.

```
queryset = Store.objects.prefetch_related('books')
    for store in queryset:
        books = [book.name for book in store.books.filter(price__range=(250, 300))]
        stores.append({'id': store.id, 'name': store.name, 'books': books})

Number of Queries : 12
```
Несмотря на то, что мы используем prefetch_related, наши запросы скорее увеличились, чем уменьшились. Но почему?

Используя предварительную выборку, мы говорим Django предоставить все результаты для JOIN, но когда мы используем фильтр (price__range = (250, 300)), мы меняем основной запрос, и тогда Django не присоединяется к правильным результатам для нас.

По этой причине у нас есть 12 запросов, 11 запросов, повторяющихся по хранилищам, и один запрос для получения всех результатов в режиме предварительной выборки.

Решим проблему с Prefetch.
```

queryset = Store.objects.prefetch_related(
        Prefetch('books', queryset=Book.objects.filter(price__range=(250, 300))))
for store in queryset:
    books = [book.name for book in store.books.all()]
    stores.append({'id': store.id, 'name': store.name, 'books': books})

Number of Queries : 2
```

select_releted - [select_related и prefetch_related в Django](https://django.fun/ru/articles/tutorials/select_related-i-prefetch_related-v-django/)

---

Леонид Агапов, [30.08.2023 21:24]
Ниже приведены 50 вопросов на собеседование для позиции Junior Python Backend разработчика на вебфреймворках Django и Flask:

1. Что такое веб-фреймворк?
2. Чем отличаются Django и Flask?
3. Какие основные компоненты входят в Django?
4. Какие основные компоненты входят в Flask?
5. Что такое ORM?
6. Какие ORM-библиотеки используются в Django и Flask?
7. Что такое миграции базы данных?
8. Какие инструменты используются для работы с миграциями в Django и Flask?
9. Какие типы запросов HTTP вы знаете?
10. Какие типы ответов HTTP вы знаете?
11. Что такое RESTful API?
12. Какие методы HTTP используются для работы с ресурсами в RESTful API?
13. Что такое маршрутизация (routing)?
14. Какие инструменты используются для маршрутизации в Django и Flask?
15. Что такое шаблонизация?
16. Какие шаблонизаторы используются в Django и Flask?
17. Что такое сессии и как они работают в Django и Flask?
18. Какие виды аутентификации вы знаете?
19. Какие виды авторизации вы знаете?
20. Какие виды кэширования вы знаете и как они реализуются в Django и Flask?
21. Что такое мидлвары (middleware)?
22. Какие мидлвары используются в Django и Flask?
23. Что такое валидация данных?
24. Какая библиотека используется для валидации данных в Django и Flask?
25. Какие инструменты используются для тестирования кода в Django и Flask?
26. Что такое многопоточность и как она реализуется в Python?
27. Какие инструменты используются для работы с асинхронным кодом в Django и Flask?
28. Что такое сигналы (signals) в Django?
29. Какие инструменты используются для работы с базами данных в Django и Flask?
30. Что такое механизм миграции баз данных?
31. Какие базы данных поддерживаются Django и Flask?
32. Какие инструменты используются для обработки форм в Django и Flask?
33. Что такое межсайтовая подделка запроса (CSRF)?
34. Какие инструменты используются для защиты от CSRF-атак в Django и Flask?
35. Что такое сигналы (signals) в Flask?
36. Что такое декораторы и как они используются в Django и Flask?
37. Какие инструменты используются для работы с файлами и загрузки файлов в Django и Flask?
38. Что такое кукисы (cookies) и как они работают в Django и Flask?
39. Какие инструменты используются для отправки электронной почты в Django и Flask?
40. Что такое межпроцессовое взаимодействие (IPC)?
41. Какие инструменты используются для межпроцессового взаимодействия в Django и Flask?
42. Что такое кэширование и как оно реализуется в Django и Flask?
43. Какие инструменты используются для кэширования данных в Django и Flask?
44. Что такое микросервисная архитектура и как она реализуется в Django и Flask?
45. Какие инструменты используются для развертывания приложений Django и Flask?
46. Что такое среда выполнения (runtime)?
47. Какие инструменты используются для управления средой выполнения в Django и Flask?
48. Что такое документирование кода и как оно реализуется в Django и Flask?
49. Какие инструменты используются для документирования кода в Django и Flask?
50. Что такое контейнеризация и как она реализуется в Django и Flask?

Ответы:

1. Веб-фреймворк - это программная платформа, которая предоставляет разработчикам набор инструментов и библиотек для создания веб-приложений.
2. Django - это полноценный веб-фреймворк, который предоставляет множество готовых компонентов для разработки веб-приложений, таких как ORM, система маршрутизации, система шаблонов и т. д. Flask - это более легковесный микрофреймворк, который предоставляет базовый набор инструментов для создания веб-приложений.
3. Основные компоненты Django: ORM (Object-Relational Mapping), система маршрутизации, система шаблонов, система аутентификации и авторизации, система управления базами данных, система миграции баз данных.
4. Основные компоненты Flask: система маршрутизации, система шаблонов, система аутентификации и авторизации, система управления базами данных.
5. ORM (Object-Relational Mapping) - это техника программирования, которая позволяет работать с базами данных с использованием объектно-ориентированной парадигмы.
6. В Django используется ORM-библиотека Django ORM, а в Flask - ORM-библиотека SQLAlchemy.
7.

Леонид Агапов, [30.08.2023 21:24]
Миграции баз данных - это процесс автоматического обновления структуры базы данных при изменении моделей данных.
8. В Django для работы с миграциями используется инструмент Django ORM, а в Flask - инструмент Flask-Migrate.
9. Типы запросов HTTP: GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS.
10. Типы ответов HTTP: 200 OK, 201 Created, 204 No Content, 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 500 Internal Server Error и т. д.
11. RESTful API - это архитектурный стиль разработки веб-сервисов, который основан на использовании протокола HTTP и позволяет создавать легко масштабируемые и гибкие веб-приложения.
12. Методы HTTP для работы с ресурсами в RESTful API: GET (получение данных), POST (создание нового ресурса), PUT (обновление существующего ресурса), DELETE (удаление ресурса).
13. Маршрутизация (routing) - это процесс определения, какой код должен быть выполнен при обращении к определенному URL-адресу.
14. В Django для маршрутизации используется система URLconf, а в Flask - декораторы маршрутизации.
15. Шаблонизация - это процесс разделения кода и представления данных, позволяющий создавать динамические HTML-страницы.
16. В Django используется шаблонизатор Django Template, а в Flask - шаблонизатор Jinja2.
17. Сессии - это механизм хранения данных на сервере, связанных с определенным клиентом, для поддержки состояния между запросами.
18. В Django и Flask используются различные методы аутентификации, такие как базовая аутентификация, токены доступа, OAuth и др.
19. Авторизация - это процесс проверки прав доступа к определенным ресурсам или функциям веб-приложения.
20. В Django и Flask используются различные методы авторизации, такие как ролевая авторизация, политики доступа и др.
21. Мидлвары (middleware) - это компоненты, которые выполняются перед и после обработки запросов веб-приложения и позволяют выполнять определенные операции, такие как логирование, обработка ошибок и др.
22. В Django используется система мидлваров Django Middleware, а в Flask - декораторы мидлваров.
23. Валидация данных - это процесс проверки корректности данных перед их использованием в приложении.
24. В Django используется библиотека Django Forms, а в Flask - библиотека WTForms.
25. В Django используется инструмент Django Testing Framework, а в Flask - инструмент Flask-Testing.
26. Многопоточность - это возможность программы выполнять несколько потоков одновременно для увеличения производительности.
27. В Django и Flask для работы с асинхронным кодом используются инструменты asyncio и aiohttp.
28. Сигналы (signals) в Django - это способ отправки и обработки событий в приложении.
29. В Django используется система сигналов Django Signals.
30. В Django и Flask для работы с базами данных используются ORM-библиотеки, такие как Django ORM и SQLAlchemy.
31. В Django поддерживаются различные базы данных, такие как PostgreSQL, MySQL, SQLite, Oracle и др., а в Flask - любая база данных, поддерживаемая SQLAlchemy.
32. В Django для обработки форм используется инструмент Django Forms, а в Flask - инструмент WTForms.
33. Межсайтовая подделка запроса (CSRF) - это атака, при которой злоумышленник отправляет запрос от имени авторизованного пользователя без его согласия.
34. В Django и Flask для защиты от CSRF-атак используются различные методы, такие как использование токенов CSRF, проверка Referer-заголовка и др.
35. Сигналы (signals) в Flask - это способ отправки и обработки событий в приложении.
36. Декораторы - это специальные функции, которые позволяют изменять поведение других функций или классов.
37. В Django и Flask для работы с файлами и загрузки файлов используются инструменты FileField и Flask-Uploads.
38. Куки (cookies) - это небольшие текстовые файлы, которые хранятся на компьютере пользователя и используются для хранения информации о состоянии сеанса.
39. В Django для отправки электронной почты используется инструмент Django Email, а в Flask - инструмент Flask-Mail.
40. Межпроцессовое взаимодействие (IPC) - это механизм передачи данных между процессами или потоками в операционной системе.
41. В Django и Flask для межпроцессов

Леонид Агапов, [30.08.2023 21:25]
ого взаимодействия используются различные методы, такие как использование сокетов, очередей сообщений и др.
42. Кэширование - это процесс сохранения данных в быстродействующей памяти для ускорения доступа к ним.
43. В Django и Flask для кэширования данных используются инструменты Django Cache и Flask-Caching.
44. Микросервисная архитектура - это подход к разработке приложений, при котором они разбиваются на небольшие независимые сервисы, каждый из которых выполняет определенные функции.
45. В Django и Flask для развертывания приложений используются инструменты, такие как Gunicorn, uWSGI, Nginx и др.
46. Среда выполнения (runtime) - это среда, в которой выполняется программа, включая операционную систему, библиотеки и другие зависимости.
47. В Django и Flask для управления средой выполнения используются инструменты, такие как virtualenv, pipenv, Docker и др.
48. Документирование кода - это процесс создания документации, которая описывает функции, классы и другие элементы кода.
49. В Django и Flask для документирования кода используются инструменты, такие как Sphinx, MkDocs и др.
50. Контейнеризация - это технология, которая позволяет упаковывать приложение и его зависимости в отдельный контейнер, который можно запускать на любой платформе без изменений.

Это лишь небольшой набор вопросов, которые могут быть заданы на собеседовании. Важно помнить, что конкретные вопросы могут отличаться в зависимости от компании и позиции, поэтому рекомендуется изучить документацию Django и Flask, а также пройти практические задания и упражнения, чтобы быть готовым к собеседованию.