ООП и паттерны программирования
========================
# Объектно-ориентированное программирование

## Общие положения и концепция

**Объектно ориентированное программирование** — парадигма программирования, с помощью которой программу можно представить в виде совокупности взаимодействующих между собой объектов, каждый из которых является экземпляром определенного класса, и каждый класс может наследоваться от другого класса, тем самым приобретая свойства и методы родителя.

**Класс** можно представить в виде шаблона на основе которого будут создаваться объекты определенного типа, которые будут иметь свойства и методы описанные в этом классе.

**Объект** определенного класса можно назвать экземпляром (instances) этого класса. При создании экземпляра, описываются все необходимые свойства и объект будет иметь доступ ко всем методам и атрибутам класса.

**Атрибуты класса / Свойства / Поля класса** — это определенные данные, которые понадобятся при создании объекта для определения его структуры.

**Методы** — это функции класса, которые содержат набор инструкций для оперирования объектами этого класса . Методы имеют доступ ко всем свойствам объекта для которого вызываются. Можно сказать, что метод определяет поведение объекта для которого вызывается.

**Магический метод или атрибут** — (magic or dunder – double underscore). Каждый отдельный магический метод автоматически вызывается  в определенный промежуток времени. 

---
## Инкапсуляция

Инкапсуляция – механизм сокрытия деталей реализации класса от других объектов. Достигается путем использования модификаторов доступа public, private и protected, которые соответствуют публичным, приватным и защищенным атрибутам.

Инкапсуляция – это принцип, согласно которому любой класс и в более широком смысле – любая часть системы должны рассматриваться как «черный ящик»: пользователь класса или подсистемы должен видеть только интерфейс (т.е. список декларируемых свойств и методов) и не вникать во внутреннюю реализацию.»

Пример
```python
class SomeClass():
    def __init__(self):
        self.__param = 42 # защищенный атрибут

obj = SomeClass()
obj.__param # AttributeError: 'SomeClass' object has no attribute '__param'
obj._SomeClass__param # 42
```

---
## Наследование

Наследование — это возможность порождать один класс от другого с сохранением всех свойств и методов класса-предка (суперкласса), добавляя при необходимости новые свойства и
методы.

Таким образом соблюдается принцип DRY — Don’t repeat yourself — исключается повторение одинаковый элементов. 


```python
class A:
    x = 'A'
class B(A):
    x = 'B'
    def super_x(self):
        return super().x
```
## Полиморфизм
Возможность через единый интерфейс работать с объектами разных классов. Полиморфизм позволяет обращаться с объектами разных классов так, как будто они являются объектами одного класса. Реализовать полиморфизм можно через наследование, перегрузку методов

Например, для того, чтобы произвести перекличку, мне достаточно знать, что все опрашиваемые субъекты могут назвать себя. И в данном случае не важно, у кого мы спрашиваем имя — у человека, робота или говорящего динозавра.


```python
class T1:
    def __init__(self):
        self.n = 10
 
    def total(self, a):
        return self.n + int(a)
 
 
class T2:
    def __init__(self):
        self.string = 'Hi'
 
    def total(self, a):
        return len(self.string + str(a))
 
 
t1 = T1()
t2 = T2()
 
print(t1.total(35))  # Вывод: 45
print(t2.total(35))  # Вывод: 4
```

Также в языках программирования и теории типов полиморфизмом называется способность функции обрабатывать данные разных типов.

## Абстракция

Абстракция – процесс определения существенных характеристик объекта и игнорирования несущественных характеристик. Это позволяет создавать абстрактные классы, которые определяют общие свойства и поведение группы объектов, не уточняя детали каждого объекта.

Абстрактный подход помогает эффективно решать ряд сложных задач:

1. Позволяет выделять существенные характеристики объекта, игнорируя все незначительные детали.
2. Принуждает подклассы к реализации конкретных методов или к выполнению определенных требований путем определения абстрактных методов или свойств. Таким образом, абстракция позволяет определять общие интерфейсы для классов, но при этом гарантирует, что каждый подкласс будет реализовывать свою версию этих методов или свойств.
3. Позволяет создавать общие модели объектов, которые могут использоваться для создания конкретных объектов.
4. Упрощает работу со сложными системами, которые включают множество взаимодействующих компонентов, и позволяет создавать расширяемые, модульные приложения.

Абстрактные классы в Python
Для работы с абстрактными классами в Python используют модуль abc. Он предоставляет:

1. abc.ABC – базовый класс для создания абстрактных классов. Абстрактный класс содержит один или несколько абстрактных методов, то есть методов без определения (пустых, без кода). Эти методы необходимо переопределить в подклассах.
2. abc.abstractmethod – декоратор, который указывает, что метод является абстрактным. Этот декоратор применяется к методу внутри абстрактного класса. Класс, который наследует свойства и методы от абстрактного класса, должен реализовать все абстрактные методы, иначе он также будет считаться абстрактным.
Рассмотрим пример абстрактного класса Book:

```python
from abc import ABC, abstractmethod

class Book(ABC):
    def __init__(self, title, author):
        self.title = title
        self.author = author

    @abstractmethod
    def get_summary(self):
        pass

class Fiction(Book):
    def get_summary(self):
        print(f'"{self.title}" - роман в стиле исторический фикшн, автор - {self.author}')

class NonFiction(Book):
    def get_summary(self):
        print(f'"{self.title}" - книга в стиле нон фикшн, автор - {self.author}')

class Poetry(Book):
    pass
```
Класс Book имеет абстрактный метод get_summary(). Два подкласса Book (Fiction и NonFiction) реализуют метод get_summary(), а третий подкласс Poetry – нет. Когда мы создаем экземпляры Fiction и NonFiction и вызываем их методы get_summary(), получаем ожидаемый результат:

подробнее - [Абстракция и полиморфизм в Python на примерах: код и задачи](https://proglib.io/p/samouchitel-po-python-dlya-nachinayushchih-chast-19-osnovy-oop-abstrakciya-i-polimorfizm-2023-04-24)

---

# Атрибуты классов и объектов

```python
class Point:
	    COLOR = ‘red’
	    CIRCLE = 1
```

``__dict__`` —  магический атрибут  класса, который хранит все атрибуты и методы класса в коллекции наподобие словаря — mappingproxy
``__doc__`` — возвращает докстринг класса.

Хорошей практикой считается создание документации для ключевых классов.

```python
>> Point.__dict__
>> mappingproxy({'__module__': '__main__', 'color': 'red', 'circle': 2, '__dict__': <attribute '__dict__' of 'Point' objects>, '__weakref__': <attribute '__weakref__' of 'Point' objects>, '__doc__': None, '__annotations__': {}})
```
Атрибуты класса являются общими для всех экземпляров класса и они могут на них ссылаться. 

```python
>> a = Point()
>> a.COLOR
>> ‘red’
```
Интерфейс класса — это функциональная часть класса, через которую происходит взаимодействие с самим классом или с экземпляром этого класса.

---

## Внимательнее c аттрибутами
Если через объект ссылаясь к атрибуту класса попытаться присвоить ему новое значение, у экземпляра появится собственный локальный атрибут с таким же именем, как у атрибута класса, а последний останется без изменений.
```python
>> a.color = ‘green’
>> a.__dict__
>> {‘color’: ‘green’}
>> Point.__dict__
>> {..., ‘color’: ‘red’, …}
```
## Создание локального атрибута экземпляра
Эти атрибуты создаются для каждого отдельного экземпляра и в отличие от атрибутов класса, которые общие для всех объектов, они независимы.
```
>> a.x = 1
>> a.y = 2
```
---
## Функции delattr(), getattr(), setattr(), hasattr()

### Добавить новый атрибут класса

Используя этот же синтаксис в отношение класса можно добавлять новые свойства.
```
>> Point.type_pt = ‘disc’
```
Также существует возможность создания нового свойства или изменение существующего при помощи функции setattr(class, ‘attr_name’, ‘attr_value’)
```
>> setattr(Point, ‘prop’, 1)
>> Point.prop
>> 1
```
### Получить значение атрибута
При помощи функции getattr(class, attr_name, False) можно обратиться к определенному свойству. Только в отличие от обращения  типа class.attr, в этой функции третьим аргументом можно задать значение, которое вернется в случае отсутствия искомого свойства класса.

Если же обращаться к несуществующему атрибуту через точку или с помощью getattr() без третьего аргумента, то возникнет исключение с соответствующим сообщением. 

### Проверка на существование атрибута
Проверить существует ли тот или иной атрибут можно при помощи функции hasattr(class, ‘attr_name’).
```
>> hasattr(Point, ‘color’)
>> True
```
Важно уточнить, что используя эту функцию проверки можно обратиться к атрибуту класса, но это не будет значить что в пространстве имен экземпляра тоже есть атрибут с таким именем, просто этот экземпляр имеет доступ к этому атрибуту. 
```
>>hasattr(a, ‘color’)
>> True
>> a.__dict__
>> {}
```
### Удаление атрибута
Удалить атрибут в пространстве имен (класса или экземпляра) можно используя оператор del.
```
>> del Point.prop
```
Еще один способ удаления атрибута из пространства имен это использовать функцию delattr(class, 'attr_name')

* Удалить можно только существующие атрибуты. В противном случае возникнет исключение 

* Если удалить локальный атрибут экземпляра, то обратно вернется ссылка к атрибуту класса. 

# Механизм инкапсуляции (_Protected)

Ограничение доступа к методам и данным класса извне можно назвать основой механизма инкапсуляции. Если классифицировать методы по доступу, то можно выделить три режима: public, protected, private.

## Public

``attribute`` — без подчеркиваний в начале — публичное свойство public. К атрибутам и методам можно обращаться из глобального пространства имен. 

## Protected

``_attribute`` — с одним подчеркиванием в начале — защищенный режим доступа protected. Служит для обращения внутри класса и во всех его дочерних классах. Стоит понимать, что режим доступа protected в Python лишь сигнализирует разработчику, что атрибут или метод является защищенным, но никак не ограничивает его действия с ним.

## Private

``__arrtibute`` — с двумя подчеркиваниями в начале — режим доступа private. Служит для обращения только внутри класса, где метод определен. Если попробовать обратиться к приватному атрибуту или методу извне, то  интерпретатор не сможет его найти и возникнет AttributeError. В пространстве имен класса можно без проблем взаимодействовать с ними.

Существует способ узнать кодовое имя приватного атрибута и используя его обратиться к атрибуту в глобальном пространстве имен — использовать функцию dir(). Она вернет список всех атрибутов и методов класса, где можно найти срощенные с именем класса названия приватных атрибутов. 

Но такой подход не рекомендуется и возможен только в самых крайних случаях. Работать с приватными или защищенными свойствами и методами принято только при помощи интерфейсных методов. 

---

#  Чем staticmethod отличается от простой функции? 

Методы экземпляра нуждаются в экземпляре класса и могут иметь доступ к нему через self.
```py
class MyClass:
    def method(self):
        return 'instance method called', self
```
Методы класса не нуждаются в экземпляре класса. Они не могут получить доступ к такому экземпляру (self), но у них есть доступ к самому классу через cls.
```py
class MyClass:
    def method(self):
        return 'instance method called', self
    @classmethod
    def classmethod(cls):
        return 'class method called', cls
```
Статические методы не имеют доступа к cls или self. Они работают как обычные функции, но принадлежат к пространству имен класса.

```py
class MyClass:
    def method(self):
        return 'instance method called', self
    @classmethod
    def classmethod(cls):
        return 'class method called', cls
    @staticmethod
    def staticmethod():
        return 'static method called'
```

---
# Декораторы @classmethod & @staticmethod

```python
class Vector:
    MIN_COORD = 0  # Свойства класса с заглавных букв
    MAX_COORD = 100

    @classmethod
    def validate(cls, arg):
        """Метод имеющий доступ только к атрибутам класса"""
        return cls.MIN_COORD <= arg <= cls.MAX_COORD

    @staticmethod
    def norm2(x, y):
        """функция, который не имеет доступа ни к каким атрибутам класса."""
        return x * x + y * y
```
## @classmethod Метод класса

При помощи декоратора ``@classmethod`` можно объявить метод класса, который будет работать с атрибутами класса, но не сможет обращаться к локальным атрибутам объекта, так как принимает ссылку на класс, а не на объект.

Метод класса можно вызывать через класс, где он объявлен или через экземпляр класса, так как объект все равно содержит информацию о классе и интерпретатор поймет с каким классом нужно взаимодействовать. Хорошей практикой считается второй вариант, обращение в методу класса через ссылку на экземпляр, так как если в будущем придется поменять название класса, метод не будет требовать редактирования. 

## @staticmethod Статические методы

Статические методы определяются при помощи декоратора ``@staticmethod`` и их отличие заключается в том, что они не имеют доступа ни к атрибутам класса, ни к атрибутам экземпляра. 

Можно сказать, что это независимая, самостоятельная функция объявленная в пространстве имен класса для удобства, которая использует некоторый вспомогательный код близкий к тематике класса. Не принимает ссылки на объект или класс. 

В глобальном пространстве имен вызывается через название класса. В пространстве имен методов, можно обращаться через ``self``.

---
# Интерфейсные методы | Сеттеры и геттеры

Следуя принципу инкапсуляции — … чтобы не нарушить целостность работы алгоритма внутри класса, следует взаимодействовать с ним только с помощью публичных свойств и методов… — для переопределения или получения приватных данных принято использовать интерфейсные методы внутри класса, которые называются setter и getter. (проше видеопосмотреть у Балакирева)

## Свойства property 

Как известно, если у объекта или класса определены приватные атрибуты, к ним нужно обращаться или переопределять при помощи методов, которые называются сеттеры и геттеры. 

Таких атрибутов может быть достаточно много и разработчику придется определить к каждому атрибуту свой геттер и сеттер и держать в голове имя каждого метода.

Один из способов решить эту проблему – воспользоваться объектом property.

Можно сказать, что главной опцией объектов property является создание общего имени для сеттера, геттера или делитера, которое хранит ссылки на них и через это имя, в зависимости от используемого оператора (присвоения, удаления, отсутствия оператора) можно вызвать нужный метод.

## Модуль accessify
Служит для установки дополнительной защиты методов.
```
>> pip install accessify
>> from accessify import private, protected
```
Можно обернуть метод  в нужный декоратор и он приобретет нужный режим доступа и нельзя будет получить его кодовое имя с помощью dir(). Но декорировать нужно обычный публичный метод. Если применить декоратор к приватному методу, то он отобразится в списке dir() / ```__dict__```.

```python
from accessify import private


class Point:
    _NAME = 'POINT'

    def __init__(self, x: int, y: int):
        if self.__check_coord(x) and self.__check_coord(y):
            self.__x = x
            self.__y = y
        else:
            raise ValueError('Координаты должны иметь числовые значения!')

    @private
    @classmethod
    def __check_coord(cls, value):  # Приватный метод класса, который делает валидацию координаты
        return type(value) in (int, float)

    def set_coords(self, x: int, y: int):  # Setter
        if self.__check_coord(x) and self.__check_coord(y):
            self.__x = x  # В пространстве имен класса можно взаимодействовать с приватными атрибутами
            self.__y = y
        else:
            raise ValueError('Координаты должны иметь числовые значения!')

    def get_coords(self):  # Getter
        return self.__x, self.__y

```


# Функция hash() и хэши объектов 

Хеширование — это преобразование информации при помощи специальных математических алгоритмов. В результате возникает хеш — отображение данных в виде короткой строки или числа, в идеале — уникальной для каждого набора информации. 

В программировании ассоциативные массивы, в Python представлены в виде словаря, используют хеширование для ключей. 

Функция ```hash()``` в Python вычисляет хеш для неизменяемого объекта по определенному алгоритму.

* Если объекты a == b (равны), то равен и их хеш.
* Равенство хешей hash(a) == hash(b) не гарантирует равенство объектов.
* Если хеши не равны hash(a) != hash(b), можно смело утверждать, что и объекты не равны. 
* Изменяемые объекты являются нехешируемыми. 

Объекты пользовательских классов в Python воспринимаются как неизменяемые объекты и у них можно вычислить хэш используя функцию hash().

Если создать два экземпляра одного класса с одинаковыми локальными атрибутами, они будут представлять из себя два разных объекта с разными адресами в памяти.

Если в пользовательском классе переопределить магический ``__eq__()``, то стандартный алгоритм вычисления хеша для объектов этого класса перестает работать. 

Для вычисления хеша объектов применяется магический метод ``__hash__()``. Если переопределить его поведение в пользовательском классе, можно сделать так, чтобы хеш вычислялся не для объектов в целом, а для локальных атрибутов класса. 

Таким образом если переопределить два магических метода: ``__hash__() и __eq__()``, можно сделать так, что два экземпляра класса будут равны при сравнении и будут иметь одинаковый хеш. Но адреса в памяти у объектов будут разные.

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

    def __hash__(self):
        return hash((self.x, self.y))  # Хешируются локальные свойства объекта, а не объект в целом.
```

# Функция bool() и магический __ bool__()


Для пустых объектов встроенных типов функция bool() возвращает False, в остальных случаях True. 

По умолчанию функция bool() возвращает True для любых объектов пользовательских классов. 

Изменить это поведение возможно, если переопределить один из магических методов:

1. ```__len__()``` — вызывается функцией bool(), если не переопределен магический метод ```__bool__()```. Если возвращаемое значение ```__len__()``` будет больше 0, функция bool() вернет True и наоборот.

2. ```__bool__()``` вызывается в приоритетном порядке функцией bool(). Если переопределен этот метод, ```__len__()``` не будет вызываться. 

```python
class Point:
    BOOL_DEFINE = False  # Поменяй состояние, чтобы увидеть, когда срабатывает __len__, когда __bool__

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __len__(self):
        print('__len__ is calling')
        return self.x ** 2 + self.y ** 2

    if BOOL_DEFINE:
        def __bool__(self):
            """Переопределили метод таким образом, что логическое состояние объекта определяется в зависимости
            от значения заданных локальных свойств.
            Если равны True и наоборот."""
            print('__bool__ is calling')
            return self.x == self.y
```
Изменить поведение булевого метода может быть  полезно для пользовательского класса, когда нужно вернуть логическое состояние экземпляра, которое будет зависеть от заданных локальных атрибутов. 

# Магические / dunder-методы

__магический метод__(self) — dunder от double underscore — специальные методы языка, который определяются / переопределяются в классах и имеют по два подчеркивания спереди и сзади.

## ```__init__(), __del__(), __new__()```

### ```__new__()```

* в Python3 все классы неявно наследуются от базового класса object.

Магический метод ```__new__()``` неявно вызывается интерпретатором перед созданием экземпляра класса и возвращает ссылку по которой будет создан объект и далее при помощи конструктора ```__init__()``` примет необходимые свойства.
```python
class Point:
   def __new__(cls, *args, **kwargs):  #Переопределение
     	print('__new__ calling')
return super().__new__(cls)  #Возвращаем ссылку на класс
   def __init__(self, x, y):
       print('__init__ calling')
       self.x = x
       self.y = y
* cls — ссылка на текущий класс
* self — ссылка на создаваемый объект
```
### ```__init__() — конструктор / инициализатор```
```python
class Point:
   color = 'red'
   circle = 1

   def __init__(self, x, y):
       self.x = x
       self.y = y
* параметры конструктора принято называть аналогично атрибутам объекта.
* хоть метод и магический, ничего не мешает устанавливать параметры по умолчанию, как в обычной функции
```

``__init__()`` — инициализатор объекта класса / его еще называют конструктором. Вызывается при  создании экземпляра класса, после магического метода __new__().
Позволяет задать необходимые атрибуты объекта при его создании. 
```
>> pt = Point(1, 2)
```
### ```__del__ — финализатор / деструктор``` 

Автоматически вызывается непосредственно перед уничтожением экземпляра класса.
 
Когда на объект пропадает ссылка, то есть происходит переопределение переменной со ссылкой на некоторый экземпляр класса, сборщик мусора Python понимает, что этот объект больше не используется и удаляет его из памяти. При этом вызывается магический метод ```__del__()```. 

В крайне редких случаях, можно переопределить этот метод и добавить дополнительный функционал, который будет реализован перед удалением объекта. 


## ```__setattr__(), __getattribute__(), __getattr__() и __delattr__()```

### Важно понимать

Принято разделять атрибуты и методы класса. Хотя названия методов тоже являются атрибутами класса и их можно получить при помощи магического атрибута ```__dict__```.
Как известно атрибуты класса являются общими для всех экземпляров класса. Через объект можно свободно обращаться к атрибутам класса, так как экземпляр содержит ссылку на пространство имен класса. 

Когда интерпретатору дается команда извлечь / получить атрибут с определенным, названием, сначала производится поиск в пространстве имен объекта, затем если соответствующий объект не найден, поиск переходит в пространство имен класса.

Если нужно обратиться к атрибутам класса внутри методов, то лучше это делать через ссылку на объект ```self```, а не через название класса, так как название класса в будущем может измениться, а self встроен в интерпретатор. 

Если через ссылку на объект self попытаться присвоить атрибуту класса новое значение, атрибут класса не будет переопределен, а в пространстве имен объекта будет создан новый атрибут с именем атрибута класса. Так работает оператор присваивания в классах Python. 
Стоит запомнить, что через self можно обратиться к атрибуту класса, но не стоит пытаться присвоить ему новое значение, так как интерпретатор сначала ищет имя атрибута в локальном пространстве объекта и не найдя его там, понимая что используется оператор присваивания, создает новый атрибут объекта.

В этом случае нужно использовать декоратор метода класса @classmethod и использовать ссылку на класс cls. И через эту ссылку переопределять атрибут класса.  Используя такой метод, можно быть уверенным, что взаимодействуют только атрибуты класса.

### ```__setattr__```

``__setattr__(self, key, value)`` — автоматически вызывается при изменении свойства key класса / при присвоении атрибуту определенного  значения.

При переопределении дает возможность управлять изменением того или иного атрибута. Например, запрет на присвоение атрибуту определенного значения или запрет на создание нового атрибута с определенным названием:
```python
def __setattr__(self, key, value):
   # Добавляем новый функционал
   print('__setattr__ is calling')  # Строчка, чтобы показать, что метод выполняется при обращении
   if key == 'z':
       raise AttributeError('Unacceptable attribute name')
   else:
       return object.__setattr__(self, key, value)  # После переопределения нужно не забывать возвращать базовый метод
```
### ```__getattribute__```

``__getattribute__(self, item)`` — автоматически вызывается при получении свойства класса с именем item / обращении к свойству класса с указанным именем. При переопределении дает возможность управлять обращением / получением того или иного атрибута.

Случаи когда нужно переопределять этот метод редки. В качестве примера можно сделать такое переопределение:
```python
   def __getattribute__(self, item):  # Переопределяем базовый метод
        # Добавляем новый функционал
        print('__getattribute__ is calling')  # Строчка, чтобы показать, что метод выполняется при обращении
        # Код ниже закрывает доступ к указанному атрибуту
        if item == 'x':
            raise ValueError('Access to the attribute is denied')
        else:
            return object.__getattribute__(self, item) # После переопределения нужно не забывать возвращать базовый метод
```
### ```__getattr__```
``__getattr__(self, item)`` — автоматически вызывается каждый раз при получении / обращении к  несуществующему свойству класса с именем item.

При переопределении можно изменить поведение при попытке получения несуществующего атрибута. Например, если атрибут не существует,  вместо ошибки, запрос будет возвращать False:
```python
def __getattr__(self, item):
   print('__getattr__ is calling for ' + item) # Строчка, чтобы показать, что метод выполняется при обращении
   return False
__delattr__
__delattr__(self, item) — автоматически вызывается при удалении свойства item; неважно существует это свойство или нет. 
```

```python
class Point:
    MIN_COORD = 0  # Свойства класса с заглавных букв
    MAX_COORD = 100

    def __init__(self, x: int, y: int):
        self.x = x
        self.y = y

    def set_coords(self, x, y):
        self.x = x
        self.y = y

    def __getattribute__(self, item):  # Переопределяем базовый метод
        # Добавляем новый функционал
        print('__getattribute__ is calling for ' + item)  # Строчка, чтобы показать, что метод выполняется при обращении
        # Код ниже закрывает доступ к указанному атрибуту
        if item == 'a':
            raise ValueError('Access to the attribute is denied')
        else:
            return object.__getattribute__(self, item)

    def __setattr__(self, key, value):
        # Добавляем новый функционал
        print(f'__setattr__ is calling for {str(key)} with value {str(value)}')  # Строчка, чтобы показать, что метод выполняется при обращении
        if key == 'z':
            raise AttributeError('Unacceptable attribute name')
        else:
            return object.__setattr__(self, key, value)  # После переопределения нужно не забывать возвращать базовый метод

    def __getattr__(self, item):
        print('__getattr__ is calling for ' + item) # Строчка, чтобы показать, что метод выполняется при обращении
        return False  # Вместо ошибки возвращает ложь

    def __delattr__(self, item):
        # Добавляем новый функционал
        print('__delattr__ is calling for ' + item)
        return object.__delattr__(self, item)

if __name__ == '__main__':
    p = Point(1, 2)  # Инициализация объекта с локальными атрибутами / при инициализации также вызывается __setattr__
    print(p.x)  # Обращение / получение атрибута / вызывается __getattribute__
    p.x = 3  # Переопределение значения атрибута объекта / вызывается __setattr__
    try:
        p.z = 5  # Попытка создания атрибута с таким именем пресекается, так как переопределен __setattr__().
    except AttributeError:
        print('Попытка создания атрибута с таким именем пресекается, так как переопределен __setattr__()')
    print(p.z)  # Попытка обращения к несуществующему атрибуту / вызывается __getattr__().
    del p.x  # Удаление автоматически вызывает __delattr__().
    print(p.__dict__)  # {'y': 2}        
```

## Дескрипторы

Дескриптор – класс в котором переопределены магические методы ```__get__(), __set__() или  __delete__()```. При помощи этих методов, через объект дескриптора можно управлять свойствами в другом классе. Можно сказать, что эти методы являются предопределенными сеттером, геттером и делитером. 

1. Классу-дескриптору можно задать любое удобное имя.

2. Если в дескрипторе содержится только магический метод ```__get__()```, то  это ```non-data descriptor```, если есть еще и сеттер, то это ```data descriptor```.

3. Дескриптор данных имеет высший приоритет, как и property. Например, если создать локальный атрибут экземпляра с именем совпадающим с именем дескриптора, при попытке получить этот атрибут, сработает геттер дескриптора и вернется атрибут заданный дескриптором.

4. non-data descriptor может только считывать данные и имеет приоритет обычного атрибута класса. То есть если при попытке через дескриптор задать новое значение атрибуту, будет создан локальный атрибут с именем атрибута класса, а не новым заданным именем в ```__set_name__()``` методе.

Если рассматривать data descriptor, нужно создать класс с методами:
```__set_name__(), __set__(), __get__ и __delete__(опционально).```

Как только в классе объявляется экземпляр дескриптора, автоматически срабатывает метод ```__set_name__()```. Метод принимает аргументы: ссылка на экземпляр – ```self```,  ссылка на класс где объявлен дескриптор – owner и имя, которому присваивается ссылка на экземпляр класса – name.

Через параметр ```name```, в объекте дескриптора создается локальное свойство, которое является строкой и к нему в начале добавляется одно или два подчеркивания, в зависимости от режима доступа, который нужно предоставить. 

Далее при создании объекта класса, срабатывает инициализатор, где через дескрипторы, присваиваются локальные свойства. В момент присваивания срабатывает магический метод ```__set__()``` дескриптора.

Метод ```__set__()``` принимает аргументы: ```self``` – ссылка на экземпляр дескриптора, instance – ссылка на экземпляр класса (в котором объявлен дескриптор) и value – значение которое присваивается атрибуту экземпляра класса в инициализаторе.
Присваивание значения происходит используя функцию ```setattr(instance, self.name, value)```   

## ```__call__() | Functors```

Магический метод ```__call__()``` запускается при *вызове класса и далее для создания экземпляра срабатывает определенный алгоритм:, максимально упрощенно вызываются методы ```__new__()``` и ```__init__()```.

Если в классе переопределить метод ```__call__()```, этот класс будет называться функтор / functor и к его объекту можно будет обращаться как к функции. 

Это может быть полезно, когда вызов определенного метода зависит от входных данных и эти вызовы должны происходить неявно.

Еще переопределением ```__call__()``` можно создать класс декоратор, приняв функцию, которую нужно дополнить, как свойство объекта. Имя класса-декоратора будет передано в синтаксический сахар – синтаксис декоратора. 

```python

class Integer:  # Класс дескриптор-данных
    @classmethod
    def verify_coord(cls, coord):
        """Валидатор"""
        if type(coord) != int:
            raise TypeError("Координата должна быть целым числом")

    def __set_name__(self, owner, name):
        """Принимает ссылку на объект-дескриптор - self, на класс где он будет объявлен - owner и имя со ссылкой на объект-дескриптор - name, на основе которого создается локальное свойство объекта-дескриптора.
        """
        self.name = '_' + owner.__name__ + '__' + name

    def __get__(self, instance, owner):
        """Магический getter, который возвращает локальное свойство экземпляра класса, где объявлен объект-дескриптор.
        """
        return getattr(instance, self.name)

    def __set__(self, instance, value):
        """Принимает ссылку на объект-дескриптор - self, на экземпляр класса, где объявлен объект-дескриптор - instance и значение, переданное в инициализатор при создании этого экземпляра - value. Далее создает локальный атрибут экземпляра класса, используя setattr(). В качестве имени назначается локальное свойство объекта-дескриптора."""
        self.verify_coord(coord=value)  # Проверка перед назначением.
        setattr(instance, self.name, value)


class Point3D:
    """При создании объекта-дескриптора срабатывает метод __set_name__(). X это имя, которое принимает ссылку на объект-дескриптор и передается в __set_name__() и представляет собой атрибут класса."""
    x = Integer()
    y = Integer()
    z = Integer()

    def __init__(self, x, y, z, a):
        """Параметры переданные в  __init__() передаются в __set__() как value"""
        self.x = x
        self.y = y
        self.z = z
        self.__a = a


if __name__ == '__main__':
    p = Point3D(10, 20, 30, 1)
    print(p.__dict__)
    print(p.x)
    p.x = 45
    print(p.x)
    print(p.__dict__)


```
## ```__str__(), __repr__(), __len__, __abs__```

``__str__()`` — автоматически вызывается для отображения информации об объекте класса для пользователей. Например, для print(). Если переопределить можно изменить отображение информации.

``__repr__()`` — для отображения информации об объекте класса в режиме отладки. Вызывается если обратиться к объекту в консоли.

```py
 class Cat:
	def __init__(self, name):
	self.name = name


def __repr__(self):
	return f'<instance_{self.name}>_{self.__class__}'


def __str__(self):
	return self.name


if __name__ == '__main__':
c = Cat('Alex')
print(c) # __str__() is calling.
```
``__len__()`` — позволяет применять функцию len() к экземпляру класса для возвращения длины какого-либо атрибута класса.

``__abs__()`` — позволяет применять функцию abs() к экземпляру класса. 

## ```__add__(), __sub__(), __mul__(), __truediv__()```


Если определить их в классе, то с объектами можно будет выполнять арифметические операции используя арифметические операторы.

* все эти методы вторым параметром принимают other — значение операнда. 
```py
 def add(self, other)
	return self.attr + other
* при выполнении арифметических операций между экземпляром и числовым типом, эти методы предполагают, что экземпляр будет левым операндом. Если поставить экземпляр в качестве правого операнда, возникнет исключение. Этого можно избежать определив для каждого специальный одноименный метод-модификатор с приставкой r в начале. Например:
	def __radd__(self, other):
		return self + other
* в случае, когда используется оператор приращения (+=, -=, /= , ...) нужно определить модификацию метода с приставкой i, с единственным отличием от основного метода, что возвращает не новый объект, а ссылку на тот же, только в теле меняет локальный атрибут. Таким образом при использовании оператора приращения, избегается создание нового объекта. Например:
	def iadd(self, other):
		<def add algorithm>
		self.attr += other
		return self
```
```py
class SecConverter:
    """Класс конвертер секунд в дни:часы:минуты:секунды."""
    __DAY = 86400

    def __init__(self, seconds: int):
        if not isinstance(seconds, int):
            raise AttributeError('Секунды должны принимать целочисленное значение!')
        self.seconds = seconds

    def get_time(self):
        s = self.seconds % 60  # Целые числа уйдут в минуты, остаток в секундах
        m = (self.seconds // 60) % 60  # Целые числа уйдут в часы, остаток в минутах
        h = (self.seconds // 3600) % 24  # Целые числа уйдут в дни, остаток в часах
        d = self.seconds // self.__DAY
        return f'{d}:{self.__get_formatted(h)}:{self.__get_formatted(m)}:{self.__get_formatted(s)}'

    @classmethod
    def __get_formatted(cls, x):
        return str(x).rjust(2, '0')

    def __add__(self, other):  # instance = instance + 100 --> instance.__add__(other)
        if not isinstance(other, (int, SecConverter)):
            raise ArithmeticError('Операнд должен иметь целочисленный тип или тип Clock!')

        item = other
        if isinstance(item, SecConverter):  # instance3 = instance1 + instance 2 - сложение двух экземпляров между собой
            item = other.seconds

        return SecConverter(self.seconds + item)

    def __radd__(self, other):  # instance = other + instance
        return self + other

    def __iadd__(self, other):  # instance += other
        if not isinstance(other, (int, SecConverter)):
            raise ArithmeticError('Операнд должен иметь целочисленный тип или тип Clock!')

        item = other
        if isinstance(item, SecConverter):  # instance3 = instance1 + instance2 -- сложение двух экземпляров между собой
            item = other.seconds
        self.seconds += item
        return self

    def __sub__(self, other):
        ...

    def __mul__(self, other):
        ...

    def __truediv__(self, other):
        ...

    def __mod__(self, other):
        ...


if __name__ == '__main__':
    c1 = SecConverter(86400001)
    c2 = SecConverter(1800)
    c1 = 3600 + c1  # срабатывает _radd_()
    c2 += 3600  # срабатывает _iadd_()
    c3 = c1 + c2  # срабатывает _add_() с проверкой на класс
    print(c3.get_time())
```
## ```__eq__, __ne__, __lt__, __gt__ и другие```

```
__eq__()  для ==
__ne__() для !=
__lt__() для <
__gt__ () для >
__le__()  для <=
__ge__()  для >=
```

1. по умолчанию если к объектам определенного класса применить оператор сравнения на равенство операндов ==, он сравнит адреса в памяти этих объектов — id. Если нужно сравнить какой-либо другой атрибут, то нужно определить это поведение в магическом методе ```__eq__()```. 
2. если ```__ne__()``` не переопределен в классе, где определен ```__eq__()```, интерпретатор будет инвертировать метод сравнения:
	instance1 != instance2, он представит в виде not(instance1 == instance2). Это можно проверить в режиме отладки.
3. если не определить один из методов проверки на больше или меньше ```(__lt__(), __gt__())``` и попытаться сравнить используя обратный оператор,интерпретатор, как в случае с проверкой на равенство, сравнит через уже определенный метод, заменив оператор на нужный. Аналогично и с <= >=.
Пример реализации:
```py
@staticmethod
def __verify_data(other):
	if not isinstance(other, (Clock, int)):
		raise AttributeError('Сравнивать можно только int или объект Clock!')
	item = other if isinstance(other, int) else other.seconds
	return item


def __eq__(self, other):
	item = self.__verify_data(other)
	return self.seconds == item

class Clock:
    __DAY = 86400

    def __init__(self, seconds):
        if not isinstance(seconds, int):
            raise TypeError("Секунды -- целые числа!")
        self.seconds = seconds % self.__DAY

    @staticmethod
    def __verify_data(other):
        if not isinstance(other, (Clock, int)):
            raise AttributeError('Сравнивать можно только int или объект Clock!')
        item = other if isinstance(other, int) else other.seconds
        return item

    def __eq__(self, other):
        item = self.__verify_data(other)
        return self.seconds == item

    def __lt__(self, other):
        item = self.__verify_data(other)
        return self.seconds < item

    def __gt__(self, other):
        item = self.__verify_data(other)
        return self.seconds > item

    def __le__(self, other):
        item = self.__verify_data(other)
        return self.seconds <= item


if __name__ == '__main__':
    c1 = Clock(1000)
    c2 = Clock(1200)
    print(c1 == c2)
    print(c1 == 1200)
    print(1000 == c1)
    print(c1 != c2)  # срабатывает __eq__() применяя инверсию, так как не определен __ne__().
    print(c1 < c2)
    print(c2 < c1)
    print(c1 >= c2)  # срабатывает __le__() применяя инверсию, так как не определен __ge__().

```

## ```__getitem__(), __setitem__() и __delitem__()```

```py
__getitem__(self, item) — получения значения по ключу; 
__setitem__(self, key, value) — запись значения value по ключу key;
__delitem__(self, key) — удаление элемента по ключу.
```
Переопределив эти методы можно изменить поведение, чтобы к пользовательскому объекту можно было обращаться, изменять или удалять по индексу или ключу, как в определенной коллекции. 
```py
class Student:
    """Переопределив эти методы можно изменить поведение, чтобы к пользовательскому объекту можно было обращаться, изменять или удалять по индексу или ключу, как в определенной коллекции. """
    def __init__(self, name, marks):
        self.name = name
        self.marks = marks

    def __getitem__(self, item):
        return self.marks[item]

    def __setitem__(self, key, value):
        if type(key) in (int, float, str, tuple):
            self.marks[key] = value
        else:
            raise KeyError('invalid key name')

    def __delitem__(self, key):
        del self.marks[key]


if __name__ == '__main__':
    s = Student('George', {'math': 5, 'eng': 1})
    print(s['math'])
    s['eng'] = 5
    print(s.marks)
    del s['eng']
    print(s.marks)

```
## ```__iter__(), __next__()``

```py
__iter__(self) — получение итератора для перебора объекта;
__next__(self) — переход к следующему значение и его считывание.
```
Определив эти методы можно пользовательский объект сделать итерируемым. 

# Наследование (порядок MRO)

Механизм, при котором класс наследник определяется на основе класса родителя и перенимает все его свойства и методы называется наследованием.

Как известно каждый класс имеет собственное пространство имен. При наследовании дочерний класс получает доступ к пространству имен родителя — базового класса.

Общие атрибуты и методы дочерних классов можно определить в базовом классе и таким образом избежать повторения кода. 

Определение одноименного атрибута или метода базового класса в дочернем, называется переопределением атрибута или метода.

## Поиск атрибутов
При вызове определенного метода или при обращении к атрибуту через экземпляр дочернего класса, поиск метода и атрибута интерпретатор в первую очередь выполняет в дочернем классе и если его там нет, поиск переходит в базовый класс.  

Например, если в базовом классе определен конструктор ```__init__()```, а в дочернем его нет, интерпретатор при создании объекта дочернего класса, не найдя у него конструктор, воспользуется конструктором базового класса.

Если в дочернем классе переопределены атрибуты или методы базового класса, интерпретатор выберет их — то есть можно сказать, у переопределенных атрибутов и методов в дочернем классе выше приоритет исполнения.

## Пример для понимания
Есть базовый класс. В базовом классе определен некоторый метод. Есть дочерний класс и он наследуется от базового. Если через объект дочернего класса вызвать этот метод, интерпретатор не найдя его в пространстве имен дочернего класса, перейдет в базовый, найдет его там и вызовет с ссылкой на объект дочернего класса через self.

Важно понимать, что параметр self базового класса может ссылаться не только на свои экземпляры, но и на экземпляры дочерних классов. Это регулируется тем, через объект какого класса был вызван этот метод. 

Если нужно вызвать метод внутри какого-либо метода, нужно удостовериться что этот метод определен в этом классе или его родителях, а не в его дочерних классах.

## Наследование от встроенных классов | object

Начиная с третьей версии языка пользовательские классы неявно наследуются от встроенного базового класса ```object```. При определении нового класса не нужно вручную прописывать базовый класс object, как это было во второй версии языка, можно сказать, что наследование происходит автоматически.

В object уже определены большинство магических методов и им задано стандартное поведение. В пользовательских классах можно переопределять эти методы, тем самым меняя их поведение полностью или частично. 

Если создать два класса: первый неявно наследуется от object, второй наследуется от первого, то для второго класса наследника, базовым классом будет являться первый класс и неявного наследования от object уже не будет. Но второй класс будет иметь доступ к атрибутам и методам object. так как при наследовании дочерний класс перенимает все свойства и поведение класса родителя. А так как класс родитель неявно наследуется от object, у него есть доступ к атрибутам и методам object. Так вот этот доступ передается всем последующим наследникам.

Стоит учитывать момент, что если переопределить какой-либо магический метод в первом классе, дочерний класс наследует этот переопределенный метод, так как доступ к методам и атрибутам object происходит через первый класс.

Функция ```issubclass()``` проверяет, является переданный первым аргументом класс наследником второго.

Функция ```isinstance()``` проверяет, является ли переданный первым аргументом объект экземпляром какого-ли переданного вторым аргументом класса. 

Все встроенные типы в Python являются классами. Так что существует возможность определить пользовательский класс на базе встроенного и изменить его поведение. 

## Функция super() | Делегирование


* Делеги́рование полномо́чий — это процесс передачи части функций руководителя другим управляющим или сотрудникам для достижения конкретных целей организации. 
* ```super()``` возвращает ссылку на объект-посредник, через который происходит вызов методов базового класса. Можно сказать в результате работы функции super() содержится ссылка на базовый класс, через которую и вызываются методы. Это лучше, чем явно указывать название класса, так как если название класса поменяется, нужно будет менять и это обращение.
* вызов через ```super()``` методов базового класса называется делегированием.

### Важно понимать
Если в дочернем классе определить новый уникальный метод или атрибут это является расширением (extending) базового класса. К методам и свойствам базового класса, к которым появляется доступ при наследовании, добавляется новый атрибут или метод в дочернем классе.

Если в базовом классе уже определен некоторый метод (или атрибут) и в дочернем определить метод с аналогичным названием это является переопределением (overriding) базового метода. При переопределении можно изменить поведение метода полностью или частично.

Параметр self нужен для того, чтобы объект мог обратиться к собственным методам или свойствам: self.имя_свойства.

### Пример для понимания super()
Механизм наследования применяется во избежание повторения кода. 
Если у классов есть одинаковые атрибуты и методы, их нужно вынести в базовый класс.
Если функционал какого-то метода в базовом классе не решает поставленную задачу в дочернем, его можно переопределить полностью.

Но бывают случаи, когда какой-то метод нужно переопределить частично, оставить базовый функционал как есть и добавить новый. Эту проблему решает функция super().

Для этого нужно переопределить метод базового класса в дочернем, затем в теле метода через функцию super() вызвать базовый метод, передать необходимые аргументы и и только после этого прописать новый функционал. 

Можно сказать, что часть работы, которую может выполнить, через super() делает базовый метод, а работу с которой не может справиться выполняет переопределенный метод в дочернем классе.

## Пример инкапсуляция при наследовании


Как известно при создании приватных атрибутов класса к ним добавляется префикс с именем класса. Если класс наследник использует конструктор родителя, то и названия атрибутов будут иметь префикс с именем родителя. 
Приватные атрибуту жестко привязываются к классу, где определяются. Из дочернего класса к ним нельзя получить доступ. 

Чтобы иметь доступ к атрибутам созданным в базовом классе из дочерних классов, нужно делать их защищенными, а не приватными. Это относится и к атрибутам класса и к методам. 

```py
class Geom:
    NAME = 'Geom'

    def __init__(self, x1, y1, x2, y2):
        self._x1 = x1
        self._y1 = y1
        self._x2 = x2
        self._y2 = y2


class Rect(Geom):
    def __init__(self, x1, y1, x2, y2, fill=None):
        super().__init__(x1, y1, x2, y2)
        self._fill = True

    def get__coords(self):
        return self._x1, self._y1, self._x2, self._y2


if __name__ == '__main__':
    r = Rect(0, 0, 10, 20)
    print(r.__dict__)  # Приватные свойства объекта субкласса носят префикс родителя {..., _Geom__x1, ...}
    print(r.get__coords())
```
## Множественное наследование

В питоне допускается множественное наследование, когда один дочерний класс наследуется от нескольких базовых. 
* один из примеров использования множественного наследования это классы ```Mixin```.

``Mixin`` — независимые базовые классы, в которых определены дополнительные методы или атрибуты, не предназначенные для самостоятельного использования. Примеси не должны иметь экземпляров и наследовать свойства и поведения других классов. Единственная их цель предоставить дочерним классам дополнительный функционал, которого нет в основном базовом классе. 

### Важно понимать
При использовании множественного наследования нужно убедиться, что конструкторы дополнительных / вспомогательных базовых классов, принимают только один аргумент ```self```, без дополнительных параметров.  Иначе это может привести к сложностям и путанице с параметрами, которые они принимают. Так как имеет значение в каком порядке прописаны базовые классы при множественном наследовании. И параметры переданные в один конструктор могут отличаться от параметров передаваемых в другой.

Если в базовых классах определены методы с одинаковыми названиями, то естественно будет вызываться метод класса стоящего первым в иерархии наследования. 

Если требуется вызвать непосредственно метод миксина (базового класса ниже в иерархии), то нужно явно указать имя класса и вызвать метод, а качестве параметра передав объект, для кого он вызывается:
```
>> Mixin.foo(object)
```
#### Поиск атрибутов
При множественном наследовании поиск атрибутов включает все базовые классы в том порядке, как они прописаны при наследовании, и поиск замыкается классом ``object``.

Пример для понимания:
```py
class Base:
	def foo1(self):
		…
class Mixin:
	def foo2(self):
		…
class Child(Base, Mixin):
	def bar(self):
		…
При такой иерархии наследования, поиск атрибутов будет осуществляться в таком порядке:

Child –> Base –>  Mixin –>  object
```
### ``__mro__``

MRO — Method resolution Ordering — порядок исполнения методов.

Магический атрибут, который содержит ссылку на упорядоченную коллекцию, с названиями классов, которые обходятся при поиске атрибутов.


# Полиморфизм и абстрактные методы


* Абстрактные методы — методы, которые не имеют собственной реализации и их нужно переопределить в дочерних классах. 
* К сожалению, в питоне нет реализации абстрактных методов, в этом случае выполняется лишь имитация их поведения,  путем генерации исключения NotImplementedError.  

Простыми словами, полиморфизм это возможность работы с совершенно разными объектами Python единым образом (через единый интерфейс).

## Пример для понимания

Допустим, есть несколько классов и у каждого класса есть метод расчета периметра. Как сделать так, например чтобы при переборе множества объектов этих классов, у них вызывался их метод?

Для этого нужно воспользоваться механизмом полиморфизма. Создать класс, где определен метод расчета периметра, без реализации — который будет вызывать лишь исключение NotImplementedError.

Затем создать необходимые классы, которые наследуются от базового, где определен этот метод. В этих классах, нужно переопределить базовый метод расчета периметра, с собственной логикой для каждого отдельного класса. 

Теперь для любого объекта этих классов можно вызвать метод расчета периметра, который переопределен в каждом классе с собственной логикой. А в случае, если в каком-то классе, этот метод забыли переопределить, возникнет исключение. 

Так в питоне реализуется механизм параметрического полиморфизма, где метод базового класса, имитируя поведение абстрактного метода, представляет единый интерфейс, для объектов дочерних. 

## Коллекция __slots__
	
Данная коллекция накладывает запрет на создание локальных атрибутов, название которых не входит в нее и таким образом уменьшает размер занимаемой памяти объектом и немного ускоряет работу с этими свойствами.
Одной из причин ускорения и уменьшения затрат памяти является отсутствие коллекции ```__dict__```.

``__slots__ = (‘x’, ‘y’)`` — данная запись означает, что локальные атрибуты объектов этого класса могут иметь названия перечисленные в кортеже.

При наследовании дочерние классы не наследуют ```__slots__```, но перечисленные в ней свойства в базовом классе, не будут созданы в дочернем. 

```py
import timeit


class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def count(self):
        s = self.x + self.y
        for i in range(1000):
            s += 1


class Point2D:
    __slots__ = ('x', 'y')  # Названия допустимых ЛОКАЛЬНЫХ атрибутов.

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def count(self):
        s = self.x + self.y
        for i in range(1000):
            s += 1


class Point3D(Point2D):
    pass


if __name__ == '__main__':
    p1 = Point(10, 20)
    p2 = Point2D(10, 20)
    del p2.x
    p2.x = 10
    # p2.z = 30  # Attribute Error

    p3 = Point3D(10, 20)
    print(p3.x)
    p3.z = 30  # Ошибки не будет, так как не наследуется __slots__.
    print(p3.__dict__)  # Перечисленные в __slots__ имена отсутствуют

```

# Обработка исключений в ООП Python


Встроенные исключения можно разделить на две группы:
- исключения в момент исполнения
- исключения при компиляции / сборке / до исполнения

Обработка исключений в питоне применяется для исключений в момент исполнения программы, интерпретатором — строчка за строчкой. 

У исключений в питоне есть целая иерархия во главе которой стоит класc BaseException. От него наследуются дочерние классы исключений: Exception, SystemExit, GeneratorExit и KeyboardInterrupt. Основным среди перечисленных классов исключений является Exception. От него наследуются все исключения, которые не связаны с системой. И на его основе определяются все пользовательские классы исключений.

```py
class PrintError(Exception):
    """Класс исключения при отправке данных принтеру для печати."""
    def __init__(self, *args):
        self.message = args[0] if args else None  # Пользовательская логика формирования сообщения.

    def __str__(self):
        return f"Ошибка: {self.message}"


class PrintData:
    def print(self, data):
        self.send_data(data)
        print(f'Печать: {str(data)}')

    def send_data(self, data):
        if not self.send_to_print(data):
            raise PrintError('Принтер не отвечает')

    def send_to_print(self, data):
        return False


if __name__ == '__main__':
    p = PrintData()
    p.print('data')


```
## Подробная иерархия наследования
```
BaseException
 ├── BaseExceptionGroup
 ├── GeneratorExit
 ├── KeyboardInterrupt
 ├── SystemExit
 └── Exception
      ├── ArithmeticError
      │    ├── FloatingPointError
      │    ├── OverflowError
      │    └── ZeroDivisionError
      ├── AssertionError
      ├── AttributeError
      ├── BufferError
      ├── EOFError
      ├── ExceptionGroup [BaseExceptionGroup]
      ├── ImportError
      │    └── ModuleNotFoundError
      ├── LookupError
      │    ├── IndexError
      │    └── KeyError
      ├── MemoryError
      ├── NameError
      │    └── UnboundLocalError
      ├── OSError
      │    ├── BlockingIOError
      │    ├── ChildProcessError
      │    ├── ConnectionError
      │    │    ├── BrokenPipeError
      │    │    ├── ConnectionAbortedError
      │    │    ├── ConnectionRefusedError
      │    │    └── ConnectionResetError
      │    ├── FileExistsError
      │    ├── FileNotFoundError
      │    ├── InterruptedError
      │    ├── IsADirectoryError
      │    ├── NotADirectoryError
      │    ├── PermissionError
      │    ├── ProcessLookupError
      │    └── TimeoutError
      ├── ReferenceError
      ├── RuntimeError
      │    ├── NotImplementedError
      │    └── RecursionError
      ├── StopAsyncIteration
      ├── StopIteration
      ├── SyntaxError
      │    └── IndentationError
      │         └── TabError
      ├── SystemError
      ├── TypeError
      ├── ValueError
      │    └── UnicodeError
      │         ├── UnicodeDecodeError
      │         ├── UnicodeEncodeError
      │         └── UnicodeTranslateError
      └── Warning
           ├── BytesWarning
           ├── DeprecationWarning
           ├── EncodingWarning
           ├── FutureWarning
           ├── ImportWarning
           ├── PendingDeprecationWarning
           ├── ResourceWarning
           ├── RuntimeWarning
           ├── SyntaxWarning
           ├── UnicodeWarning
           └── UserWarning
```
## Пользовательские классы исключений

При определении пользовательских классов исключений, принято наследоваться от класса ```Exception```, который уже содержит большинство необходимых встроенных классов исключений.
```py
class CustomException(Exception):
	“““Exception docstring”””
	<exception logic>
```
Можно строить пользовательскую иерархию исключений, создав базовый класс исключения и наследоваться от него.

## Менеджер контекста в ООП Python


Менеджер контекста — объект, который получает уведомление при начале определенного контекста (блок кода) и об его окончании, при этом реализуя определенную логику поведения.
```
with <context_manager_object> as <name>:
	<code>
```

В классе менеджера контекста реализовано два метода:
``__enter__()`` — срабатывает в момент создания объекта менеджера контекста.
``__exit__()`` — срабатывает в момент завершения работы объекта менеджера контекста или при возникновении исключения.

## Пример для понимания
Если в классе реализованы  два магических метода ```__enter__() и __exit__()```, он становится менеджером контекста и для создания объекта потребуется воспользоваться оператором with.

В методе ```__enter__()``` реализуется логика работы с входными данными и ссылка на результат работы возвращается в имя, определенное в конструкции ```with```. Например, открытие файлового потока с помощью ```open()```.

В методе ```__exit__()``` реализуется поведение при завершении работы менеджера. Набор инструкций, в случае отсутствия или наличия ошибок. Если исключения отсутствуют, параметры метода принимают None. Если в ходе выполнения кода внутри блока менеджера возникли исключения, информация о них будет передана в соответствующие параметры метода для дальнейшей обработки.
Например, в этом методе происходит закрытие файлового потока. 

Если метод возвращает ```False```, возникшие в ходе работы исключения не будут обработаны и программа остановится. 
Если ```True```, то исключения будут обрабатываться и программа завершится успешно,

Например, в указанном выше файле определен класс менеджера контекста, который принимает список и возвращает его копию. Далее программа работает с копией и если не возникло ошибок, менеджер заменяет оригинал элементами из этой копиеи. Если возникло исключение, работа прекращается, а оригинальный файл остается без изменения. 

```py
class SecuredVector:
    def __init__(self, v: list):
        if isinstance(v, list):
            self.__v = v

    def __enter__(self):
        self.__temp = self.__v[:]  # создаем копию для дальнейшей обработки...
        return self.__temp  # возвращаем ссылку на эту копию в объявленное глобальном пространстве имя...

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Если возникают исключения, они передаются в качестве параметров."""
        print(exc_val, exc_type, exc_tb)
        if exc_type is None:
            # если в ходе работы менеджера не возникло ошибок, заменяем оригинал временной копией...
            self.__v[:] = self.__temp
        return False  # Если ложь, значит исключения не обрабатываются и наоборот...


if __name__ == '__main__':
    v1 = [1, 2, 3]
    v2 = [1, 2]
    v3 = [2, 4, 6]
    try:
        with SecuredVector(v1) as dv:
            for i, val in enumerate(dv):
                dv[i] += v2[i]
            print("Ошибки нет. Список обновил значения...")
    except IndexError:
        print("Возникла ошибка. Список не изменился...")

    print(v1)  # Если возникнет исключение, данные в списке сохранятся без изменений...

    with SecuredVector(v1) as dv:
        for i, val in enumerate(dv):
            dv[i] += v3[i]
        print("Ошибки нет. Список обновил значения...")

    print(v1)  # Если менеджер контекста завершит работу без ошибок, оригинальные данные изменятся...

```
## Вложенные классы

Вложенный класс реализует независимое от внешнего класса пространство имен, где можно определить дополнительные параметры и логику, что в некоторых случаях может упростить реализацию того или иного функционала, но не более. 

Обращаясь через внешний класс можно создавать объекты вложенного класса. Но плохой практикой считается обращаться из вложенного класса к атрибутам внешнего. Это можно сделать в конструкторе внутреннего, но не рекомендуется. 

## Метаклассы
```
«Метаклассы — это глубокая магия, о которой 99% пользователей даже не нужно задумываться. Если вы думаете нужно ли вам их использовать — вам не нужно. Люди, которым они нужны, точно знают, зачем они им и не нуждаются в объяснениях, почему…» © Тим Питерс
```
В питоне всё является объектом определенного класса. Классы также являются объектами, которые позволяют создавать другие объекты. Сущность, которая создает обычные классы называется метакласс — некоторая отправная точка в ООП питона.

Метакласс представлен объектом ```type()``` — который может принимать 1 или 3 параметра.

Если в него передать объект или ссылку на объект, он вернет название класса переданного объекта.
```
>> def foo(self): print(self.MAX_COORD)
>>> Point = type('Point', (), {'MAX_COORD': 100, 'foo': foo})
>>> pt = Point()
>>> pt.foo()
100
>>> type(pt)
<class '__main__.Point'>
```
Функция может принимать 3 аргумента — имя класса, коллекцию родительских классов и словарь с атрибутами и методами.
В этом случае объект type() начинает работать по-другому:
динамически создает новый класс (тип данных). 
Например, все стандартные (встроенные в питон) типы объектов (типы данных) созданы при помощи объекта  type(). 
```
>> type(int)
>> <class ‘type’>
```
## Пользовательские метаклассы

В питоне можно создавать пользовательские метаклассы, которые неявно или явно будут созданы объектом type().
```py
Метакласс в виде функции:
def create_user_metaclass(class_name, base, attrs):
	<some_logic>
	return type(class_name, base, attrs)

class User(metaclass=create_user_metaclass):
	<extra_logic>
Пользовательский метакласс:
	class Meta(type):
		def __new__(cls, name, base, attrs):
			<logic>
			return type.__new__(cls, name, base, attrs)

	class User(metaclass=Meta):
		<extra_logic>
```
```py
class Meta(type):
    def __new__(cls, name, base, attrs):
        attrs.update({'ATTR': 1})
        # attrs['ATTR'] = 1  # Пользовательская логика
        return type.__new__(cls, name, base, attrs)


class UserClass(metaclass=Meta):
    def __init__(self, attr):
        self.attr = attr

    def get_attr(self):
        return self.attr


if __name__ == '__main__':
    u = UserClass(1)
    print(u.get_attr())
    print(u.ATTR)  # Существует

```

## Немного о Data Classes

Встроенный модуль dataclasses содержит инструменты, помогающие упростить создание классов, которые хранят данные. Вместо того чтобы создавать инициализатор, можно воспользоваться декоратором @dataclass этого модуля и определить класс с более простым синтаксисом:
```py
@dataclass	
class Thing:
“““все параметры со значениями по умолчанию передаются в последнюю очередь...”””
	attr_1: <type> = <optional - default value>
	attr_2: <type>
	mutable_attr: field(default_factory=list) # — создает независимый изменяемый объект у каждого отдельного экземпляра.
	…
	attr_n: <type>
```
Хоть внутри класса явно не прописан инициализатор, при создании экземпляра класса, будут созданы указанные локальные атрибуты. 

В классе созданном при помощи декоратора @dataclass магический метод ```__eq__()``` переопределен таким образом, что он сравнивает не адреса в памяти объектов, как это работает у классов созданных обычных образом, а сравнивает локальные атрибуты. И если локальные атрибуты двух разных объектов равны, для него равны и объекты. 

```py
from dataclasses import dataclass, field


class Thing:
    """Пример обычного класса, объекты которого хранят некоторые данные..."""
    def __init__(self, name: str, weight: int, price: float):
        self.name = name
        self.weight = weight
        self.price = price
        self.dims = []  # независимая коллекция...

    def __repr__(self):
        """Добавляем более информативный вывод..."""
        return f'Thing: {self.__dict__}'


@dataclass
class ThingData:
    name: str
    weight: int
    price: float
    dims: list = field(default_factory=list)  # Чтобы создать независимую коллекцию, нужно воспользоваться field()...


if __name__ == '__main__':
    t = Thing('Freezer', 80, 3500)
    td = ThingData('Freezer', 80, 3500)
    td.dims.append(2)
    t.dims.append(1)
    print(t.dims)
    print(td.dims)
    t2 = Thing('Cooler', 8, 500)
    td2 = ThingData('Cooler', 8, 500)
    print(t2.dims)
    print(td2.dims)


```

## Паттерн Singleton

Паттерн Singleton предоставляет механизм для создания только одного экземпляра класса. При попытке создания нового объекта этого класса, будет возвращаться уже созданный ранее экземпляр.

Класс синглтон не так часто используются в Python, как в других языках. Эффект синглетона обычно лучше реализуется в виде глобальной переменной в модуле.

Пример из PEP318
```python
def singleton(cls):
    instances = {}
    def getinstance():
        if cls not in instances:
            instances[cls] = cls()
        return instances[cls]
    return getinstance

@singleton
class MyClass:
   
```
Пример. Синглтон через метакласс
```python
class MetaSingleton(type):
    """Пример реализации Singleton через метакласс.
       При каждой попытке создания нового (происходит вызов класса) экземпляра класса, будет вызываться __call__
       метакласса и возвращать уже ранее созданный объект...
       Можно сказать, что создав пользовательский метакласс, можно переопределять стандартное поведение всех встроенных
       магических методов...
       """

    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]


class DataBase(metaclass=MetaSingleton):
    def __init__(self, user, psw, port):
        print(self, '__init__ is calling...')
        self.user = user
        

    def connect(self):
        print(f'Connection to DB: {self.user})

```

еще - [🐍 3 классических паттерна проектирования в Python: синглтон, декоратор и итератор](https://proglib.io/p/3-luchshih-patterna-proektirovaniya-v-python-singlton-dekorator-i-iterator-2022-02-03)

---
## Паттерн «Моносостояние» | Monostate

Механизм, который позволяет создавать множество экземпляров определенного класса имеющих общие локальные атрибуты, и когда изменение атрибутов любого отдельного экземпляра этого класса вызывает изменение свойств всех остальных, называется паттерном «Моносостояние»

### Реализация в Python
Для этого нужно создать приватный атрибут, который имеет тип словаря Python, и перечислить там необходимые данные. 
Далее определить инициализатор, который принимает только один аргумент — ссылку на объект self, и указать, что при создании каждого нового экземпляра, локальные атрибуты объекта будут принимать значение приватного атрибута класса. Это делается через переопределение магического атрибута ```__dict__```, который возвращает атрибуты и методы объекта. 

```py
class ThreadData:
    __shared_attrs = {
        'name': 'thread',
        'data': {},
        'id': 1
    }

    def _init__(self):
        self.__dict__ = self.__shared_attrs


if __name__ == '__main__':
    t = ThreadData()
    print(t)

```
##  Что такое конструктор объектов в Python и из чего он состоит и как работает?

Конструктор – это метод, который будет автоматически вызываться системой при создании объектов. Он также называется конструктором объектов класса. Имя соответствующего метода будет регламентироваться синтаксисом определенного языка разработки. 


Конструктор в Python – это особый тип метода (функции), который используется для инициализации членов экземпляра класса.  (`__new__` вызывает `__init__`)

В Python метод __init __() имитирует конструктор класса. Этот метод вызывается при создании экземпляра класса. Он принимает ключевое слово self в качестве первого аргумента, который позволяет получить доступ к атрибутам или методу класса.

Мы можем передать любое количество аргументов во время создания объекта класса, в зависимости от определения __init __(). В основном он используется для инициализации атрибутов класса. У каждого класса должен быть конструктор, даже если он просто полагается на конструктор по умолчанию.


###  Почему в методе __init__ есть аргумент self?

[Конструкторы в Python: как работать с Init OTUS](https://otus.ru/journal/konstruktory-v-python-kak-rabotat-s-init/)

[Конструктор класса в Python – метод __init__. Параметры по-умолчанию. Деструктор](https://younglinux.info/oopython/init)

## Что такое list/dict comprehension

Выражение заключенное в квадратные/фигурные скобки, в котором используются ключевые слова `for` и `in` для построения списка/словаря путем обработки и фильтрации элементов из одного или нескольких итерируемых объектов. Списковое включение работает энергично.

*Энергичный* - итерируемый объект, который сразу строит все свои элементы. В Python включения - энергичные операции. Противоположность - *ленивый* (генератор).

[Когда использовать List Comprehension в Python](https://pythonist.ru/kogda-ispolzovat-list-comprehension-v-python/#how-to-create-lists-in-python)

## Какая разница между одинарным и двойным подчеркиванием

- [Understanding the underscore of Python](https://hackernoon.com/understanding-the-underscore-of-python-309d1a029edc)

Есть 5 кейсов использования подчеркивая в Python:

1. Для хранения значения последнего выражения в REPL
2. Игнорирования значения
3. Для опеределения специального значения функции или переменной
    - одинарное в начале или конце названия
    - двойное в начале
    - двойное в начале и конце
4. Для использования в качестве функции локализации
5. Для разделения символов числа (`1_00 == 100`)

## Отличие copy() от deepcopy()

- [Deep vs Shallow Copies in Python](https://stackabuse.com/deep-vs-shallow-copies-in-python/)

Глубокая копия `deepcopy()` создает новую и отдельную копию всего объекта или списка со своим уникальным адресом памяти. Это означает, что любые изменения, внесенные вами в новую копию объекта или списка, не будут отражаться в исходной. Этот процесс происходит следующим образом: сначала создается новый список или объект, а затем рекурсивно копируются все элементы из исходного в новый.

Поверхностное копирование `copy()` также создает отдельный новый объект или список, но вместо копирования дочерних элементов в новый объект оно просто копирует ссылки на их адреса памяти. Следовательно, если вы сделаете изменение в исходном объекте, оно будет отражено в скопированном объекте, и наоборот. Короче говоря, обе копии зависят друг от друга.

## Что такое garbage collector. В чём его плюсы и минусы

- [Всё, что нужно знать о сборщике мусора в Python](https://habr.com/ru/post/417215/)

GC (generational garbage collector) - это сборщик мусора, создавался он в первую очередь для обнаружения и удаления циклических ссылок.
`gc` является встроенным в python модулем и при необходимости его можно выключить и запускать вручную (или не запускать). Чтобы понимать для чего был создан GC нужно понимать как в Python работает менеджер памяти и как эта память высвобождается.

В отличие от других популярных языков, Python не освобождает всю память обратно операционной системе как только он удаляет какой либо объект. Вместо этого, он использует дополнительный менеджер памяти, предназначенный для маленьких объектов (размер которых меньше чем 512 байт). Для работы с такими объектами он выделяет большие блоки памяти, в которых в дальнейшем будет хранится множество маленьких объектов.

Как только один из маленьких объектов удаляется — память из под него не переходит операционной системе, Python оставляет её для новых объектов с таким же размером. Если в одном из выделенных блоков памяти не осталось объектов, то Python может высвободить его операционной системе. Как правило, высвобождение блоков случается когда скрипт создает множество временных объектов.

Таким образом, если долгоживущий Python процесс с течением времени начинает потреблять больше памяти, то это совсем не означает, что в вашем коде есть проблема с утечкой памяти.

Стандартный интерпретатор питона (CPython) использует сразу два алгоритма сборки мусора, подсчет ссылок и generational garbage collector (далее GC), более известный как стандартный модуль gc из Python.

Алгоритм подсчета ссылок очень простой и эффективный, но у него есть один большой недостаток. Он не умеет определять циклические ссылки. Именно из-за этого, в питоне существует дополнительный сборщик, именуемый поколенческий GC, который следит за объектами с потенциальными циклическими ссылками.

В Python, алгоритм подсчета ссылок является фундаментальным и не может быть отключен, тогда как GC опционален и может быть отключен.

В отличие от алгоритма подсчета ссылок, циклический GC не работает в режиме реального времени и запускается периодически. Каждый запуск сборщика создаёт микропаузы в работе кода, поэтому CPython (стандартный интерпретатор) использует различные эвристики, для определения частоты запуска сборщика мусора.

Циклический сборщик мусора разделяет все объекты на 3 поколения (генерации). Новые объекты попадают в первое поколение. Если новый объект выживает после процесса сборки мусора, то он перемещается в следующее поколение. Чем выше поколение, тем реже оно сканируется на мусор. Так-как новые объекты зачастую имеют очень маленький срок жизни (являются временными), то имеет смысл опрашивать их чаще, чем те, которые уже прошли через несколько этапов сборки мусора.

В каждой генерации есть специальный счетчик и порог срабатывания, при достижении которых срабатывает процесс сборки мусора. Каждый счетчик хранит количество аллокаций минус количество деаллокаций в данной генерации. Как только в Python создается какой либо контейнерный объект, он проверяет эти счетчики. Если условия срабатывают, то начинается процесс сборки мусора.

Если сразу несколько или больше поколений преодолели порог, то выбирается наиболее старшее поколение. Это сделано из-за того, что старые поколения также сканируют все предыдущие. Чтобы сократить число пауз сборки мусора для долгоживущих объектов, самая старшая генерация имеет дополнительный набор условий.

Стандартные пороги срабатывания для поколений установлены на 700, 10 и 10 соответственно, но вы всегда можете их изменить с помощью функций gc.get_threshold и gc.set_threshold.

## Что такое интроспекция

- [Introspection in Python](http://zetcode.com/lang/python/introspection/)

*Интроспекция* — это способность программы исследовать тип или свойства объекта во время работы программы. Вы можете поинтересоваться, каков тип объекта, является ли он экземпляром класса. Некоторые языки даже позволяют узнать иерархию наследования объекта. Возможность интроспекции есть в таких языках, как Ruby, Java, PHP, Python, C++ и других. В целом, инстроспекция — это очень простое и очень мощное явление. Вот несколько примеров использования инстроспекции:

```java
// Java

if(obj instanceof Person){
   Person p = (Person)obj;
   p.walk();
}
```

```php
//PHP

if ($obj instanceof Person) {
   // делаем что угодно
}
```

В Python самой распространённой формой интроспекции является использование метода dir для вывода списка атрибутов объекта:

```python
# Python

class foo(object):
  def __init__(self, val):
    self.x = val
  def bar(self):
    return self.x

...

dir(foo(5))
=> ['__class__', '__delattr__', '__dict__', '__doc__', '__getattribute__', '__hash__', '__init__', '__module__',
'__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__str__', '__weakref__', 'bar', 'x']
```

## Что такое рефлексия

Интроспекция позволяет вам изучать атрибуты объекта во время выполнения программы, а рефлексия — манипулировать ими. *Рефлексия* — это способность компьютерной программы изучать и модифицировать свою структуру и поведение (значения, мета-данные, свойства и функции) во время выполнения. Простым языком: она позволяет вам вызывать методы объектов, создавать новые объекты, модифицировать их, даже не зная имён интерфейсов, полей, методов во время компиляции. Из-за такой природы рефлексии её труднее реализовать в статически типизированных языках, поскольку ошибки типизации возникают во время компиляции, а не исполнения программы (подробнее об этом здесь). Тем не менее, она возможна, ведь такие языки, как Java, C# и другие допускают использование как интроспекции, так и рефлексии (но не C++, он позволяет использовать лишь интроспекцию).

По той же причине рефлексию проще реализовать в интерпретируемых языках, поскольку когда функции, объекты и другие структуры данных создаются и вызываются во время работы программы, используется какая-то система распределения памяти. Интерпретируемые языки обычно предоставляют такую систему по умолчанию, а для компилируемых понадобится дополнительный компилятор и интерпретатор, который следит за корректностью рефлексии.

*Пример*:

```python
# Без рефлексии
Foo().hello()

# С рефлексией
getattr(globals()['Foo'](), 'hello')()
```



## Какие принципы программирования вы знаете

- [10 Coding principles and acronyms demystified!](https://areknawo.com/10-coding-principles-and-acronyms-demystified/)

### KISS

Принцип *Keep It Stupid Simple* («Придерживайся простоты») велит вам следить за тем, чтобы код оставался как можно более простым. Чем код проще, тем легче в нем разобраться, как вам, так и другим людям, занимающимся его поддержкой. Под простотой главным образом имеется в виду отказ от использования хитроумных приемов и ненужного усложнения.

В качестве примеров нарушения этого принципа можно назвать написание отдельной функции только лишь для осуществления операции сложения или использование побитового оператора (right shift >> 1) для деления целых чисел на 2. Последнее, безусловно, более эффективно, чем обычное (/2), но при этом очень сильно снижается понятность кода. Применяя такой подход, вы осуществляете clever coding («заумный кодинг») и over-optimization (чрезмерную оптимизацию). И то, и другое в долгосрочной перспективе не слишком хорошо сказывается на здоровье вашего кода.

### DRY

Принцип *Don’t Repeat Yourself* («Не повторяйся») напоминает нам, что каждое повторяемое поведение в коде следует обособлять (например, выделять в отдельную функцию) для возможности многократного использования. Когда у вас в кодовой базе есть два совершенно одинаковых фрагмента кода, это не хорошо. Это часто приводит к рассинхронизации и прочим багам, не говоря уже о том, что от этого увеличивается размер программы.

### YAGNI

Принцип *You Aren’t Gonna Need It* («Тебе это не понадобится») говорит о том, что нежелательно оставлять в продакшене «точки расширения» (места, предназначенные только для того, чтобы позволить вам в будущем легко добавить новый функционал). Конечно, мы не говорим о случаях, когда речь идет об уже заказанном функционале. Такие точки расширения вносят ненужную сложность и увеличивают размер вашей кодовой базы.

### SLAP

Принцип *Single Level of Abstraction Principle* («Принцип единого уровня абстракций») означает, что функции должны иметь единый уровень абстракции. Скажем, функция, читающая input, не должна также обрабатывать полученные данные. Для этого она должна задействовать отдельную функцию, находящуюся на другом, более низком уровне абстракции. Чем более общей является функция и чем больше других функций она использует, тем выше она располагается в абстракционной иерархии.

### SOLID принципы

*SOLID* - это аббревиатура от 5 принципов, описанных Робертом Мартином, которые способствуют созданию хорошего объектно-ориентированного (и не только) кода.

**S**: Single Responsibility Principle (Принцип единственной ответственности).
>Каждый класс должен решать лишь одну задачу.

**O**: Open-Closed Principle (Принцип открытости-закрытости).
>Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.

**L**: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).
>Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.

**I**: Interface Segregation Principle (Принцип разделения интерфейса).
>Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют.

**D**: Dependency Inversion Principle (Принцип инверсии зависимостей).
>Объектом зависимости должна быть абстракция, а не что-то конкретное.

- Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
- Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

## Что такое code cohesion & code coupling

**Связанность модулей (coupling)**, часто называемую **зацеплением**, характеризует степень независимости модулей. При проектировании систем необходимо стремиться, чтобы модули имели минимальную зависимость друг от друга, т.е. были минимально «сцеплены» между собой (отсюда и термин «сцепление» или связанность). Это требование вытекает из одного из основных принципов системного подхода, требующего минимизации информационных потоков между подсистемами.

**Связность (cohesion)** характеризует целостность, «плотность» модуля, т.е. насколько модуль является простым с точки зрения его использования. В идеале модуль должен выполнять одну единственную функцию и иметь минимальное число «ручек управления». Примером модуля имеющего максимальную связность является модуль проверки орфографии, вычисления заработной платы сотрудника, вычисления логарифма функции. Если связанность является характеристикой системы, то связность характеризует отдельно взятый модуль.

# Паттерны

В разработке программного обеспечения паттерн – это общее, многократно используемое решение проблемы, которая часто встречается внутри конкретной ситуации. Это похоже на готовые чертежи, которые можно использовать для решения проблемы в вашем коде. Паттерн – это не фрагмент кода, а общая концепция, которая описывает, как решить конкретную повторяющуюся проблему.

## Какие шаблоны проектирования вы знаете

Шаблоны, или паттерны программирования - это повторяющиеся решения типовых задач, возникающих в процессе разработки программного обеспечения.

* Синглтон (одиночка) - это объекты, предполагающие наличие только одного экземпляра. Python предоставляет несколько путей для реализации синглтонов.
* Null object может быть использован вместо None, что бы избежать проверки на None.
* Обозреватель- Паттерн обозреватель позволяет нескольким объектам иметь доступ к общим данным.
* Конструктор - Параметры конструктора часто назначаются переменным экземпляра. Этот паттерн может заменить много строк ручного присваивания одной строчкой.



- "Марк Саммерфилд - Python на практике"
- [GitHub - pkolt/design_patterns: Паттерны проектирования](https://github.com/pkolt/design_patterns)
- [GitHub - faif/python-patterns: A collection of design patterns/idioms in Python](https://github.com/faif/python-patterns)
- [Python Design Patterns](https://python-patterns.guide/)
- <https://dzen.ru/a/ZGUGH7X07SoelYfO>


### Виды паттернов

1. Порождающие – предоставляют возможность создания контролируемым образом, инициализации и конфигурации объектов, классов и типов данных на основе требуемых критериев.
2. Структурные – помогают организовать структуры связанных объектов и классов, предоставляя новые функциональные возможности.
3. Поведенческие – направлены на выявление общих моделей взаимодействия между объектами.
4. Concurrency (параллелизм) – это тот тип паттернов проектирования, который имеет дело с многопоточной парадигмой программирования.


[Шаблоны проектирования в Python: для стильного кода](https://proglib.io/p/python-patterns)


### Порождающие (Creational)

Порождающие паттерны проектирования описывают, как создавать объекты. Обычно объект создается путем вызова констуктора, но иногда требуется большая гибкость именно для этого порождающие паттерны и полезны.

#### Абстрактная фабрика (Abstract factory)

Предназначен для случаев, когда требуется создать сложный объект, состоящий из других объектов, причем все составляющие объекты принадлежат одному "семейству". Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов.

Например, в системе с GUI может быть абстрактная фабрика виджетов, которой наследуют три конкретных фабрики: MacWidgetFactory, XfceWidgetFactory, WindowsWidgetFactory, каждая из которых предоставляет методы для создания одних и тех же объектов (make_button(), make_spinbox() и т.д), стилизованных, однако, как принято на конкретной платформе. Это дает возможность создать обобщенную функцию create_dialog(), которая принимает экземпляр фабрики в качестве аргумента и создает диалоговое окно, выглядещее как в OS X, Xfce или Windows - в зависимости от того какую фабрику мы передали.

Классы абстрактной фабрики часто реализуются фабричными методами, но могут быть реализованы и с помощью паттерна прототип.

```python
"""
*What is this pattern about?
In Java and other languages, the Abstract Factory Pattern serves to provide an interface for
creating related/dependent objects without need to specify their
actual class.
The idea is to abstract the creation of objects depending on business
logic, platform choice, etc.
In Python, the interface we use is simply a callable, which is "builtin" interface
in Python, and in normal circumstances we can simply use the class itself as
that callable, because classes are first class objects in Python.
*What does this example do?
This particular implementation abstracts the creation of a pet and
does so depending on the factory we chose (Dog or Cat, or random_animal)
This works because both Dog/Cat and random_animal respect a common
interface (callable for creation and .speak()).
Now my application can create pets abstractly and decide later,
based on my own criteria, dogs over cats.
*Where is the pattern used practically?
*References:
https://sourcemaking.com/design_patterns/abstract_factory
http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/
*TL;DR
Provides a way to encapsulate a group of individual factories.
"""

import random


class PetShop:

    """A pet shop"""

    def __init__(self, animal_factory=None):
        """pet_factory is our abstract factory.  We can set it at will."""

        self.pet_factory = animal_factory

    def show_pet(self):
        """Creates and shows a pet using the abstract factory"""

        pet = self.pet_factory()
        print("We have a lovely {}".format(pet))
        print("It says {}".format(pet.speak()))


class Dog:
    def speak(self):
        return "woof"

    def __str__(self):
        return "Dog"


class Cat:
    def speak(self):
        return "meow"

    def __str__(self):
        return "Cat"


# Additional factories:

# Create a random animal
def random_animal():
    """Let's be dynamic!"""
    return random.choice([Dog, Cat])()


# Show pets with various factories
if __name__ == "__main__":

    # A Shop that sells only cats
    cat_shop = PetShop(Cat)
    cat_shop.show_pet()
    print("")

    # A shop that sells random animals
    shop = PetShop(random_animal)
    for i in range(3):
        shop.show_pet()
        print("=" * 20)

# OUTPUT #
# We have a lovely Cat
# It says meow
#
# We have a lovely Dog
# It says woof
# ====================
# We have a lovely Cat
# It says meow
# ====================
# We have a lovely Cat
# It says meow
# ====================
```

#### Построитель (Builder)

Построитель аналогичен паттерну Абстрактная фабрика в том смысле, что оба предназначены для создания сложных объектов, составленных из других объектов. Но отличается тем, что не только предоставляет методы для построения сложного объекта, но и хранит внутри себя его полное представление.

Этот паттерн допускает такую же композиционную структуру как и Абстрактная фабрика (то есть сложные объекты, составленные из нескольких более простых) но особенно удобен в ситуациях, когда представление составного объета должно быть отделено от алгоритмов композиции

Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления. От абстрактной фабрики отличается тем, что делает акцент на пошаговом конструировании объекта. Строитель возвращает объект на последнем шаге, тогда как абстрактная фабрика возвращает объект немедленно. Строитель часто используется для создания паттерна компоновщик.

```python
"""
*What is this pattern about?
It decouples the creation of a complex object and its representation,
so that the same process can be reused to build objects from the same
family.
This is useful when you must separate the specification of an object
from its actual representation (generally for abstraction).
*What does this example do?
The first example achieves this by using an abstract base
class for a building, where the initializer (__init__ method) specifies the
steps needed, and the concrete subclasses implement these steps.
In other programming languages, a more complex arrangement is sometimes
necessary. In particular, you cannot have polymorphic behaviour in a constructor in C++ -
see https://stackoverflow.com/questions/1453131/how-can-i-get-polymorphic-behavior-in-a-c-constructor
- which means this Python technique will not work. The polymorphism
required has to be provided by an external, already constructed
instance of a different class.
In general, in Python this won't be necessary, but a second example showing
this kind of arrangement is also included.
*Where is the pattern used practically?
*References:
https://sourcemaking.com/design_patterns/builder
*TL;DR
Decouples the creation of a complex object and its representation.
"""


# Abstract Building
class Building:
    def __init__(self):
        self.build_floor()
        self.build_size()

    def build_floor(self):
        raise NotImplementedError

    def build_size(self):
        raise NotImplementedError

    def __repr__(self):
        return 'Floor: {0.floor} | Size: {0.size}'.format(self)


# Concrete Buildings
class House(Building):
    def build_floor(self):
        self.floor = 'One'

    def build_size(self):
        self.size = 'Big'


class Flat(Building):
    def build_floor(self):
        self.floor = 'More than One'

    def build_size(self):
        self.size = 'Small'


# In some very complex cases, it might be desirable to pull out the building
# logic into another function (or a method on another class), rather than being
# in the base class '__init__'. (This leaves you in the strange situation where
# a concrete class does not have a useful constructor)


class ComplexBuilding:
    def __repr__(self):
        return 'Floor: {0.floor} | Size: {0.size}'.format(self)


class ComplexHouse(ComplexBuilding):
    def build_floor(self):
        self.floor = 'One'

    def build_size(self):
        self.size = 'Big and fancy'


def construct_building(cls):
    building = cls()
    building.build_floor()
    building.build_size()
    return building


def main():
    """
    >>> house = House()
    >>> house
    Floor: One | Size: Big
    >>> flat = Flat()
    >>> flat
    Floor: More than One | Size: Small
    # Using an external constructor function:
    >>> complex_house = construct_building(ComplexHouse)
    >>> complex_house
    Floor: One | Size: Big and fancy
    """


if __name__ == "__main__":
    import doctest
    doctest.testmod()
```

#### Фабричный метод (Factory method)

Паттерн Фабричный метод применяется, когда мы хотим, чтобы подклассы выбирали, какой класс инстанциировать, когда запрашивается объект. Это полезно само по себе, но можно пойти дальше и использовать в случае, когда класс заранее неизвестен (например, зависит от информации, прочитанной из файла или введенных пользователем данных).

Абстрактная фабрика часто реализуется с помощью фабричных методов.
Фабричные методы часто вызываются внутри шаблонных методов.

```python
"""*What is this pattern about?
A Factory is an object for creating other objects.
*What does this example do?
The code shows a way to localize words in two languages: English and
Greek. "get_localizer" is the factory function that constructs a
localizer depending on the language chosen. The localizer object will
be an instance from a different class according to the language
localized. However, the main code does not have to worry about which
localizer will be instantiated, since the method "localize" will be called
in the same way independently of the language.
*Where can the pattern be used practically?
The Factory Method can be seen in the popular web framework Django:
http://django.wikispaces.asu.edu/*NEW*+Django+Design+Patterns For
example, in a contact form of a web page, the subject and the message
fields are created using the same form factory (CharField()), even
though they have different implementations according to their
purposes.
*References:
http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/
*TL;DR
Creates objects without having to specify the exact class.
"""


class GreekLocalizer:
    """A simple localizer a la gettext"""

    def __init__(self):
        self.translations = {"dog": "σκύλος", "cat": "γάτα"}

    def localize(self, msg):
        """We'll punt if we don't have a translation"""
        return self.translations.get(msg, msg)


class EnglishLocalizer:
    """Simply echoes the message"""

    def localize(self, msg):
        return msg


def get_localizer(language="English"):
    """Factory"""
    localizers = {
        "English": EnglishLocalizer,
        "Greek": GreekLocalizer,
    }
    return localizers[language]()


def main():
    """
    # Create our localizers
    >>> e, g = get_localizer(language="English"), get_localizer(language="Greek")
    # Localize some text
    >>> for msg in "dog parrot cat bear".split():
    ...     print(e.localize(msg), g.localize(msg))
    dog σκύλος
    parrot parrot
    cat γάτα
    bear bear
    """


if __name__ == "__main__":
    import doctest
    doctest.testmod()
```

#### Прототип (Prototype)

Паттерн Прототип применяется для создания нового объекта путем клонирования исходного с последующей модификацией клона.

Способы создания нового объекта в Python:

```python
class Point:
    __slots__ = ('x', 'y',)

    def __init__(self, x, y):
        self.x = x
        self.y = y

# При таком классическом определении класса Point создать новую точку можно семью способами

def make_object(cls, *args, **kwargs):
    return cls(*args, **kwargs)

point1 = Point(1, 2)
point2 = eval('{}({}, {})'.format('Point', 2, 4)) # Опасно
point3 = getattr(sys.modules[__name__], 'Point')(3, 6)
point4 = globals()['Point'](4, 8)
point5 = make_object(Point, 5, 10)
point6 = copy.deepcopy(point5)
point6.x = 6
point6.y = 12
point7 = point1.__class__(7, 14)
```

При создании point6 используется классический подход на основе прототипа: сначала мы клонируем существующий объект, а затем  инициализируем и конфигурируем его. Для создания point7 мы берем объект класса точки point1 и передаем ему другие аргументы.

На примере point6 мы видим, чтов  Python уже встроена поддержка прототипов в виде функции copy.deepcopy(). Однако пример point7 показывает, что в Python есть средства и поулчше: вместо того чтобы клонировать существующий объект и модифицировать клон, Python предоставляет доступ к объекту класса имеющегося объекта и таким образом мы можем создать новый объект непосредственно, что гораздо эффективнее клонирования.

Прототип - паттерн, порождающий объекты. Задает виды создаваемых объектов с помощью экземпляра-прототипа и создает новые объекты путем копирования этого прототипа.

```python
"""
*What is this pattern about?
This patterns aims to reduce the number of classes required by an
application. Instead of relying on subclasses it creates objects by
copying a prototypical instance at run-time.
This is useful as it makes it easier to derive new kinds of objects,
when instances of the class have only a few different combinations of
state, and when instantiation is expensive.
*What does this example do?
When the number of prototypes in an application can vary, it can be
useful to keep a Dispatcher (aka, Registry or Manager). This allows
clients to query the Dispatcher for a prototype before cloning a new
instance.
Below provides an example of such Dispatcher, which contains three
copies of the prototype: 'default', 'objecta' and 'objectb'.
*TL;DR
Creates new object instances by cloning prototype.
"""


class Prototype:

    value = 'default'

    def clone(self, **attrs):
        """Clone a prototype and update inner attributes dictionary"""
        # Python in Practice, Mark Summerfield
        obj = self.__class__()
        obj.__dict__.update(attrs)
        return obj


class PrototypeDispatcher:
    def __init__(self):
        self._objects = {}

    def get_objects(self):
        """Get all objects"""
        return self._objects

    def register_object(self, name, obj):
        """Register an object"""
        self._objects[name] = obj

    def unregister_object(self, name):
        """Unregister an object"""
        del self._objects[name]


def main():
    """
    >>> dispatcher = PrototypeDispatcher()
    >>> prototype = Prototype()
    >>> d = prototype.clone()
    >>> a = prototype.clone(value='a-value', category='a')
    >>> b = prototype.clone(value='b-value', is_checked=True)
    >>> dispatcher.register_object('objecta', a)
    >>> dispatcher.register_object('objectb', b)
    >>> dispatcher.register_object('default', d)
    >>> [{n: p.value} for n, p in dispatcher.get_objects().items()]
    [{'objecta': 'a-value'}, {'objectb': 'b-value'}, {'default': 'default'}]
    """


if __name__ == '__main__':
    import doctest
    doctest.testmod()
```

#### Одиночка (Singleton)

Паттерн Одиночка (Синглтон) применяется, когда необходим класс, у которого должен быть единственный экземпляр во всей программе.

С помощью паттерна одиночка могут быть реализованы многие паттерны (абстрактная фабрика, строитель, прототип).

В сборнике рецептов приводится простой класс Singleton, которому любой класс может унаследовать, чтобы стать одиночкой.

```python
"""
Yet one singleton realization on Python without metaclass. Singleton may has __init__ method which will call only when first object create.
http://code.activestate.com/recipes/577208-singletonsubclass-with-once-initialization/
"""


class Singleton(object):

    def __new__(cls,*dt,**mp):
        if not hasattr(cls,'_inst'):
            cls._inst = super(Singleton, cls).__new__(cls,dt,mp)
        else:
            def init_pass(self,*dt,**mp):pass
            cls.__init__ = init_pass

        return cls._inst

if __name__ == '__main__':


    class A(Singleton):

        def __init__(self):
            """Super constructor
                There is we can open file or create connection to the database
            """
            print "A init"


    a1 = A()
    a2 = A()
```

И класс Borg, который даст тот же результат совсем другим способом.

```python
"""
*What is this pattern about?
The Borg pattern (also known as the Monostate pattern) is a way to
implement singleton behavior, but instead of having only one instance
of a class, there are multiple instances that share the same state. In
other words, the focus is on sharing state instead of sharing instance
identity.
*What does this example do?
To understand the implementation of this pattern in Python, it is
important to know that, in Python, instance attributes are stored in a
attribute dictionary called __dict__. Usually, each instance will have
its own dictionary, but the Borg pattern modifies this so that all
instances have the same dictionary.
In this example, the __shared_state attribute will be the dictionary
shared between all instances, and this is ensured by assigining
__shared_state to the __dict__ variable when initializing a new
instance (i.e., in the __init__ method). Other attributes are usually
added to the instance's attribute dictionary, but, since the attribute
dictionary itself is shared (which is __shared_state), all other
attributes will also be shared.
*Where is the pattern used practically?
Sharing state is useful in applications like managing database connections:
https://github.com/onetwopunch/pythonDbTemplate/blob/master/database.py
*References:
https://fkromer.github.io/python-pattern-references/design/#singleton
*TL;DR
Provides singleton-like behavior sharing state between instances.
"""


class Borg:
    __shared_state = {}

    def __init__(self):
        self.__dict__ = self.__shared_state
        self.state = 'Init'

    def __str__(self):
        return self.state


class YourBorg(Borg):
    pass


def main():
    """
    >>> rm1 = Borg()
    >>> rm2 = Borg()
    >>> rm1.state = 'Idle'
    >>> rm2.state = 'Running'
    >>> print('rm1: {0}'.format(rm1))
    rm1: Running
    >>> print('rm2: {0}'.format(rm2))
    rm2: Running
    # When the `state` attribute is modified from instance `rm2`,
    # the value of `state` in instance `rm1` also changes
    >>> rm2.state = 'Zombie'
    >>> print('rm1: {0}'.format(rm1))
    rm1: Zombie
    >>> print('rm2: {0}'.format(rm2))
    rm2: Zombie
    # Even though `rm1` and `rm2` share attributes, the instances are not the same
    >>> rm1 is rm2
    False
    # Shared state is also modified from a subclass instance `rm3`
    >>> rm3 = YourBorg()
    >>> print('rm1: {0}'.format(rm1))
    rm1: Init
    >>> print('rm2: {0}'.format(rm2))
    rm2: Init
    >>> print('rm3: {0}'.format(rm3))
    rm3: Init
    """


if __name__ == "__main__":
    import doctest
    doctest.testmod()
```

Однако самый простой способ получить функциональность одиночки в Python - создать модуль с глобальным состоянием, которое хранится в закрытых переменных, и предоставить открытые функции для доступа к нему. Например, для получения курсов валют нам понадобится функция, которая будет возвращать словарь (ключ - название валюты, значение - обменный курс). Возможно, эту функцию понадобится вызывать несколько раз, но в большинстве случев извлекать откуда-то курсы нужно единожды. Реализовать это поможет паттерн Одиночка.

```python
#!/usr/bin/env python3
# Copyright © 2012-13 Qtrac Ltd. All rights reserved.
# This program or module is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version. It is provided for
# educational purposes and is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.

import re
import urllib.request


_URL = "http://www.bankofcanada.ca/stats/assets/csv/fx-seven-day.csv"


def get(refresh=False):
    if refresh:
        get.rates = {}
    if get.rates:
        return get.rates
    with urllib.request.urlopen(_URL) as file:
        for line in file:
            line = line.rstrip().decode("utf-8")
            if not line or line.startswith(("#", "Date")):
                continue
            name, currency, *rest = re.split(r"/s*,/s*", line)
            key = "{} ({})".format(name, currency)
            try:
                get.rates[key] = float(rest[-1])
            except ValueError as err:
                print("error {}: {}".format(err, line))
    return get.rates
get.rates = {}


if __name__ == "__main__":
    import sys
    if sys.stdout.isatty():
        print(get())
    else:
        print("Loaded OK")

```

Здесь мы создаем словарь rates в виде атрибута функции Rates.get() - это наше закрытое значение. Когда открытая функция get() вызывается в первый раз (а также при вызове с параметром refresh=True), мы загружаем список курсов; в противном случае просто возвращаем последние загруженные курсы.

#### Порождающие паттерны. Итог

Все порождающие паттерны проектирования реализуются на Python тривиально. Паттерн Одиночка можно реализовать непосредственно с помощью модуля, а паттерн Прототип вообще ни к чему (хотя его можно реализовать с помощью модуля copy), так как Python дает динамический доступ к объектам классов. Из порождающих паттернов наиболее полезны Фабрика и Построитель, и реализовать их можно несколькими способами.

### Структурные (Structural)

Структурные паттерны описывают, как из одних объектов составляются другие, более крупные. Рассматриваются три основных круга вопросов: адаптация интерфейсов, добавление функциональности и работа с коллекциями объектов.

#### Адаптер (Adapter)

Паттерн Адаптер описывает технику адаптации интерфейса. Задача состоит в том, чтобы один класс мог воспользоваться другим - с несовместимым интерфейсом - без внесения каких-либо изменений в оба класса. Это полезно, например, когда требуется воспользоваться не подлежащим изменению классом в контексте, на который он не был расчитан.

Адаптер обеспечивает совместную работу классов с несовместимыми интерфейсами, которая без него была бы невозможна.

```python
"""
*What is this pattern about?
The Adapter pattern provides a different interface for a class. We can
think about it as a cable adapter that allows you to charge a phone
somewhere that has outlets in a different shape. Following this idea,
the Adapter pattern is useful to integrate classes that couldn't be
integrated due to their incompatible interfaces.
*What does this example do?
The example has classes that represent entities (Dog, Cat, Human, Car)
that make different noises. The Adapter class provides a different
interface to the original methods that make such noises. So the
original interfaces (e.g., bark and meow) are available under a
different name: make_noise.
*Where is the pattern used practically?
The Grok framework uses adapters to make objects work with a
particular API without modifying the objects themselves:
http://grok.zope.org/doc/current/grok_overview.html#adapters
*References:
http://ginstrom.com/scribbles/2008/11/06/generic-adapter-class-in-python/
https://sourcemaking.com/design_patterns/adapter
http://python-3-patterns-idioms-test.readthedocs.io/en/latest/ChangeInterface.html#adapter
*TL;DR
Allows the interface of an existing class to be used as another interface.
"""


class Dog:
    def __init__(self):
        self.name = "Dog"

    def bark(self):
        return "woof!"


class Cat:
    def __init__(self):
        self.name = "Cat"

    def meow(self):
        return "meow!"


class Human:
    def __init__(self):
        self.name = "Human"

    def speak(self):
        return "'hello'"


class Car:
    def __init__(self):
        self.name = "Car"

    def make_noise(self, octane_level):
        return "vroom{0}".format("!" * octane_level)


class Adapter:
    """
    Adapts an object by replacing methods.
    Usage:
    dog = Dog()
    dog = Adapter(dog, make_noise=dog.bark)
    """

    def __init__(self, obj, **adapted_methods):
        """We set the adapted methods in the object's dict"""
        self.obj = obj
        self.__dict__.update(adapted_methods)

    def __getattr__(self, attr):
        """All non-adapted calls are passed to the object"""
        return getattr(self.obj, attr)

    def original_dict(self):
        """Print original object dict"""
        return self.obj.__dict__


def main():
    """
    >>> objects = []
    >>> dog = Dog()
    >>> print(dog.__dict__)
    {'name': 'Dog'}
    >>> objects.append(Adapter(dog, make_noise=dog.bark))
    >>> objects[0].__dict__['obj'], objects[0].__dict__['make_noise']
    (<...Dog object at 0x...>, <bound method Dog.bark of <...Dog object at 0x...>>)
    >>> print(objects[0].original_dict())
    {'name': 'Dog'}
    >>> cat = Cat()
    >>> objects.append(Adapter(cat, make_noise=cat.meow))
    >>> human = Human()
    >>> objects.append(Adapter(human, make_noise=human.speak))
    >>> car = Car()
    >>> objects.append(Adapter(car, make_noise=lambda: car.make_noise(3)))
    >>> for obj in objects:
    ...    print("A {0} goes {1}".format(obj.name, obj.make_noise()))
    A Dog goes woof!
    A Cat goes meow!
    A Human goes 'hello'
    A Car goes vroom!!!
    """


if __name__ == "__main__":
    import doctest
    doctest.testmod(optionflags=doctest.ELLIPSIS)
```

#### Мост (Bridge)

Мост (Bridge) - паттерн, структурирующий объекты. Основная задача - отделить абстракцию от её реализации так, чтобы то и другое можно было изменять независимо.

Традиционный подход без использования паттерна Мост состоит в том, чтобы создать один или несколько абстрактных базовых классов, а затем предоставить две или более конкретных реализации каждого базового класса.
А паттерн Мост предлагает создать две независимых иерархии классов: "абстрактную", которая определяет операции (например интерфейс или алгоритм верхнего уровня) и конкретную, предоставляющую реализацию, которые в конечном итоге и будут вызваны из абстрактных операций. "Абстрактный" класс агрегирует экземпляр одного из конкретных классов с реализацией - и этот последний служит *мостом* между абстрактным интерфейсом и конкретными операциями.

```python
"""
*References:
http://en.wikibooks.org/wiki/Computer_Science_Design_Patterns/Bridge_Pattern#Python
*TL;DR
Decouples an abstraction from its implementation.
"""


# ConcreteImplementor 1/2
class DrawingAPI1:
    def draw_circle(self, x, y, radius):
        print('API1.circle at {}:{} radius {}'.format(x, y, radius))


# ConcreteImplementor 2/2
class DrawingAPI2:
    def draw_circle(self, x, y, radius):
        print('API2.circle at {}:{} radius {}'.format(x, y, radius))


# Refined Abstraction
class CircleShape:
    def __init__(self, x, y, radius, drawing_api):
        self._x = x
        self._y = y
        self._radius = radius
        self._drawing_api = drawing_api

    # low-level i.e. Implementation specific
    def draw(self):
        self._drawing_api.draw_circle(self._x, self._y, self._radius)

    # high-level i.e. Abstraction specific
    def scale(self, pct):
        self._radius *= pct


def main():
    """
    >>> shapes = (CircleShape(1, 2, 3, DrawingAPI1()), CircleShape(5, 7, 11, DrawingAPI2()))
    >>> for shape in shapes:
    ...    shape.scale(2.5)
    ...    shape.draw()
    API1.circle at 1:2 radius 7.5
    API2.circle at 5:7 radius 27.5
    """


if __name__ == '__main__':
    import doctest
    doctest.testmod()
```

#### Компоновщик (Composite)

Паттерн Компоновщик позволяет единообразно обрабатывать объекты, образующие иерархию, вне зависимости от того, содержат они другие объекты или нет. Такие объекты называют составными.

В классическом решении составные объекты - как отдельные, так и коллекции - имеют один и тот же базовый класс. У составных и несоставных объектов обычно одни и те же основные методы, но составные объекты добавляют методы для поддержки добавления, удаления и перебора дочерних объектов.

Этот паттерн часто применяется в программах рисования, например Inkscape, для поддержки группировки и разгруппировки. Его полезность в таких ситуациях объясняется тем, что подлежащие группировке или разгруппировке компоненты могут быть как одиночными (например прямоугольник) так и состаными (например, рожица, составленная из нескольких разных фигур)

```python
"""
*What is this pattern about?
The composite pattern describes a group of objects that is treated the
same way as a single instance of the same type of object. The intent of
a composite is to "compose" objects into tree structures to represent
part-whole hierarchies. Implementing the composite pattern lets clients
treat individual objects and compositions uniformly.
*What does this example do?
The example implements a graphic class，which can be either an ellipse
or a composition of several graphics. Every graphic can be printed.
*Where is the pattern used practically?
In graphics editors a shape can be basic or complex. An example of a
simple shape is a line, where a complex shape is a rectangle which is
made of four line objects. Since shapes have many operations in common
such as rendering the shape to screen, and since shapes follow a
part-whole hierarchy, composite pattern can be used to enable the
program to deal with all shapes uniformly.
*References:
https://en.wikipedia.org/wiki/Composite_pattern
https://infinitescript.com/2014/10/the-23-gang-of-three-design-patterns/
*TL;DR
Describes a group of objects that is treated as a single instance.
"""


class Graphic:
    def render(self):
        raise NotImplementedError("You should implement this.")


class CompositeGraphic(Graphic):
    def __init__(self):
        self.graphics = []

    def render(self):
        for graphic in self.graphics:
            graphic.render()

    def add(self, graphic):
        self.graphics.append(graphic)

    def remove(self, graphic):
        self.graphics.remove(graphic)


class Ellipse(Graphic):
    def __init__(self, name):
        self.name = name

    def render(self):
        print("Ellipse: {}".format(self.name))


if __name__ == '__main__':
    ellipse1 = Ellipse("1")
    ellipse2 = Ellipse("2")
    ellipse3 = Ellipse("3")
    ellipse4 = Ellipse("4")

    graphic1 = CompositeGraphic()
    graphic2 = CompositeGraphic()

    graphic1.add(ellipse1)
    graphic1.add(ellipse2)
    graphic1.add(ellipse3)
    graphic2.add(ellipse4)

    graphic = CompositeGraphic()

    graphic.add(graphic1)
    graphic.add(graphic2)

    graphic.render()

# OUTPUT #
# Ellipse: 1
# Ellipse: 2
# Ellipse: 3
# Ellipse: 4
```

#### Декоратор (Decorator)

Декоратором называется функция, которая принимает функцию с таким же именем, как у исходной, но с расширенной функциональностью. Декораторы часто используются во фреймвоках, чтобы упростить интеграцию пользовательских функций с фреймворком.

Паттерн Декоратор настолько полезен, что в Python встроена специальная поддержка для него. В Python декорировать можно как функции, так и методы. Кроме того, Python поддерживает декораторы классов: функции, которые принимают клас в качестве аргумента и возвращают новый класс с таким же именем, как у исходного, но дополненной функциональностью.

Иногда декораторы классов удобно использовать как альтернативу производным классам.

```python
"""
*What is this pattern about?
The Decorator pattern is used to dynamically add a new feature to an
object without changing its implementation. It differs from
inheritance because the new feature is added only to that particular
object, not to the entire subclass.
*What does this example do?
This example shows a way to add formatting options (boldface and
italic) to a text by appending the corresponding tags (<b> and
<i>). Also, we can see that decorators can be applied one after the other,
since the original text is passed to the bold wrapper, which in turn
is passed to the italic wrapper.
*Where is the pattern used practically?
The Grok framework uses decorators to add functionalities to methods,
like permissions or subscription to an event:
http://grok.zope.org/doc/current/reference/decorators.html
*References:
https://sourcemaking.com/design_patterns/decorator
*TL;DR
Adds behaviour to object without affecting its class.
"""


class TextTag:
    """Represents a base text tag"""

    def __init__(self, text):
        self._text = text

    def render(self):
        return self._text


class BoldWrapper(TextTag):
    """Wraps a tag in <b>"""

    def __init__(self, wrapped):
        self._wrapped = wrapped

    def render(self):
        return "<b>{}</b>".format(self._wrapped.render())


class ItalicWrapper(TextTag):
    """Wraps a tag in <i>"""

    def __init__(self, wrapped):
        self._wrapped = wrapped

    def render(self):
        return "<i>{}</i>".format(self._wrapped.render())


if __name__ == '__main__':
    simple_hello = TextTag("hello, world!")
    special_hello = ItalicWrapper(BoldWrapper(simple_hello))
    print("before:", simple_hello.render())
    print("after:", special_hello.render())

# OUTPUT #
# before: hello, world!
# after: <i><b>hello, world!</b></i>
```

#### Фасад (Facade)

Паттерн Фасад служит для того, чтобы предоставить упрощенный унифицированный интерфейс к подсистеме, чей истинный интерфейс слишком сложен или написан на таком низком уровне, что работать с ним неудобно. Фасад определяет интерфейс более высокого уровня, который упрощает использование подсистемы.

В стандартной библиотеке Python имеется несколько модулей для работы с сжатыми файлами - gzip, tar+gzip, zip. Все они имеют разные интерфейсы. Если мы хотим иметь один унифицированный интерфейс для работы с архивами, мы можем воспользоваться паттерном Фасад.

Паттерны Фасад и Адаптер на первый взгляд кажутся похожими. Разница в том, что Фасад надстраивает простой интерфейс поверх сложного, а Адаптер надстраивает унифицированный интерфейс над каким-то другим (необязательно сложным). Оба эти паттерна можно использовать совместно. Например определить интерфейс для работы с архивными файлами, написать адапрет для каждого формата и надстроить поверх них фасад, чтобы пользователям не нужно было беспокоиться о том, какой конкретно формат файла используется.

```python
"""
Example from https://en.wikipedia.org/wiki/Facade_pattern#Python
*What is this pattern about?
The Facade pattern is a way to provide a simpler unified interface to
a more complex system. It provides an easier way to access functions
of the underlying system by providing a single entry point.
This kind of abstraction is seen in many real life situations. For
example, we can turn on a computer by just pressing a button, but in
fact there are many procedures and operations done when that happens
(e.g., loading programs from disk to memory). In this case, the button
serves as an unified interface to all the underlying procedures to
turn on a computer.
*Where is the pattern used practically?
This pattern can be seen in the Python standard library when we use
the isdir function. Although a user simply uses this function to know
whether a path refers to a directory, the system makes a few
operations and calls other modules (e.g., os.stat) to give the result.
*References:
https://sourcemaking.com/design_patterns/facade
https://fkromer.github.io/python-pattern-references/design/#facade
http://python-3-patterns-idioms-test.readthedocs.io/en/latest/ChangeInterface.html#facade
*TL;DR
Provides a simpler unified interface to a complex system.
"""


# Complex computer parts
class CPU:
    """
    Simple CPU representation.
    """
    def freeze(self):
        print("Freezing processor.")

    def jump(self, position):
        print("Jumping to:", position)

    def execute(self):
        print("Executing.")


class Memory:
    """
    Simple memory representation.
    """
    def load(self, position, data):
        print("Loading from {0} data: '{1}'.".format(position, data))


class SolidStateDrive:
    """
    Simple solid state drive representation.
    """
    def read(self, lba, size):
        return "Some data from sector {0} with size {1}".format(lba, size)


class ComputerFacade:
    """
    Represents a facade for various computer parts.
    """
    def __init__(self):
        self.cpu = CPU()
        self.memory = Memory()
        self.ssd = SolidStateDrive()

    def start(self):
        self.cpu.freeze()
        self.memory.load("0x00", self.ssd.read("100", "1024"))
        self.cpu.jump("0x00")
        self.cpu.execute()


def main():
    """
    >>> computer_facade = ComputerFacade()
    >>> computer_facade.start()
    Freezing processor.
    Loading from 0x00 data: 'Some data from sector 100 with size 1024'.
    Jumping to: 0x00
    Executing.
    """


if __name__ == "__main__":
    import doctest
    doctest.testmod(optionflags=doctest.ELLIPSIS)
```

#### Приспособленец (Flyweight)

Приспособленец предназначен для обработки большого числа сравнительно небольших объектов, когда многие из этих объектов являются дубликатами. Реализация паттерна предполагает, что каждый уникальный объект представлется всего один раз и именно этот экземпляр отдается на запрос. В Python легко реализуется через словарь.

В Python подход к реализации приспособленцев естественный - благодаря наличию ссылок на объекты. Например, если бы у нас был длинный список строк, в котором много дубликатов, то, сохраняя ссылки на объекты (то есть переменные), а не литеральные строки, мы бы могли существенно сэкономить память

```python
red, green, blue = 'red', 'green', 'blue'
x = (red, green, blue, red, green, blue, green)
```

```python
"""
*What is this pattern about?
This pattern aims to minimise the number of objects that are needed by
a program at run-time. A Flyweight is an object shared by multiple
contexts, and is indistinguishable from an object that is not shared.
The state of a Flyweight should not be affected by it's context, this
is known as its intrinsic state. The decoupling of the objects state
from the object's context, allows the Flyweight to be shared.
*What does this example do?
The example below sets-up an 'object pool' which stores initialised
objects. When a 'Card' is created it first checks to see if it already
exists instead of creating a new one. This aims to reduce the number of
objects initialised by the program.
*References:
http://codesnipers.com/?q=python-flyweights
https://python-patterns.guide/gang-of-four/flyweight/
*Examples in Python ecosystem:
https://docs.python.org/3/library/sys.html#sys.intern
*TL;DR
Minimizes memory usage by sharing data with other similar objects.
"""

import weakref


class Card:
    """The Flyweight"""

    # Could be a simple dict.
    # With WeakValueDictionary garbage collection can reclaim the object
    # when there are no other references to it.
    _pool = weakref.WeakValueDictionary()

    def __new__(cls, value, suit):
        # If the object exists in the pool - just return it
        obj = cls._pool.get(value + suit)
        # otherwise - create new one (and add it to the pool)
        if obj is None:
            obj = object.__new__(Card)
            cls._pool[value + suit] = obj
            # This row does the part we usually see in `__init__`
            obj.value, obj.suit = value, suit
        return obj

    # If you uncomment `__init__` and comment-out `__new__` -
    #   Card becomes normal (non-flyweight).
    # def __init__(self, value, suit):
    #     self.value, self.suit = value, suit

    def __repr__(self):
        return "<Card: {}{}>".format(self.value, self.suit)


def main():
    """
    >>> c1 = Card('9', 'h')
    >>> c2 = Card('9', 'h')
    >>> c1, c2
    (<Card: 9h>, <Card: 9h>)
    >>> c1 == c2
    True
    >>> c1 is c2
    True
    >>> c1.new_attr = 'temp'
    >>> c3 = Card('9', 'h')
    >>> hasattr(c3, 'new_attr')
    True
    >>> Card._pool.clear()
    >>> c4 = Card('9', 'h')
    >>> hasattr(c4, 'new_attr')
    False
    """


if __name__ == "__main__":
    import doctest
    doctest.testmod()
```

#### Заместитель (Proxy)

Паттерн Заместитель применяется когда мы хотим подставить один объект вместо другого. В книге "Паттенрны проектирования" описаны 4 таких случая:

1. удаленный прокси, когда доступ к удаленному объекту проксируется локальным объектом;
2. вирутальный прокси, который позволяет создавать облегченные объекты вместо тяжеловесных, а последние создавать только когда это необходимо;
3. защитный прокси, который предоставляет различные уровни доступа, в зависимости от прав клиента;
4. интелектуальная сслыка, которая выполняет "дополнительные действия при обращении к объекту" (можно также реализовать с помощью дескриптопа @property)

Mock - пример реализации паттерна Заместитель

```python
"""
*TL;DR
Provides an interface to resource that is expensive to duplicate.
"""

import time


class SalesManager:
    def talk(self):
        print("Sales Manager ready to talk")


class Proxy:
    def __init__(self):
        self.busy = 'No'
        self.sales = None

    def talk(self):
        print("Proxy checking for Sales Manager availability")
        if self.busy == 'No':
            self.sales = SalesManager()
            time.sleep(0.1)
            self.sales.talk()
        else:
            time.sleep(0.1)
            print("Sales Manager is busy")


class NoTalkProxy(Proxy):
    def talk(self):
        print("Proxy checking for Sales Manager availability")
        time.sleep(0.1)
        print("This Sales Manager will not talk to you", "whether he/she is busy or not")


if __name__ == '__main__':
    p = Proxy()
    p.talk()
    p.busy = 'Yes'
    p.talk()
    p = NoTalkProxy()
    p.talk()
    p.busy = 'Yes'
    p.talk()

# OUTPUT #
# Proxy checking for Sales Manager availability
# Sales Manager ready to talk
# Proxy checking for Sales Manager availability
# Sales Manager is busy
# Proxy checking for Sales Manager availability
# This Sales Manager will not talk to you whether he/she is busy or not
# Proxy checking for Sales Manager availability
# This Sales Manager will not talk to you whether he/she is busy or not
```

#### Структурные паттерны. Итог

Паттерны Адаптер и Фасад упрощают повторное использование классов в новых контекстах, а паттерн Мост дает возможность внедрить сложную функциональность одного класса в другой. Компоновщик упрощает создание иерархий объектов, хотя в Python это не особенно нужно, так как для этой цели хватает словарей. Декоратор настолько полезен, что в Python для него имеется прямая поддержка, причем идея декоратора распространена даже на классы. Использование ссылок на объекты означает что в сам язык встроена варианция на тему паттерна Приспособленец. А паттерн Заместитель в Python реализовать особенно просто.

### Поведенческие (Behavioral)

Предмет поведенческих паттерном - способ решения задачи, то есть они имеют дело с алгоритмами и взаимодействиями объектов. Эти паттерны предлагают действенные способы обдумывания и организации вычислений. Для некоторых из них имеется прямяая поддержка в синтаксисе Python.

#### Цепочка ответственности (Chain of responsobility)

Паттерн цепочка отвестственности предназначен, для того чтобы разорвать связь между отправителем запроса и получателем, который этот запрос обрабатывает. Вместо непосредственного вызова одной функции из другой первая функция отправляет запрос цепочке получателей. Первый получатель в цепочке может либо обработать запрос и прервать цепочку (не передавая запрос дальше), либо передать запрос следующему получателю. У второго получателя есть такой же выбор и так далее, пока запрос не дойдет до последнего получателя (который может отбросить запрос или возбудить исключение).

Представьте себе пользовательский интерфейс, который получает события для обработки. Одни события поступают от пользователя (например, события мыши и клавиатуры), другие - от системы (например, события таймера).

```python
"""
*What is this pattern about?
The Chain of responsibility is an object oriented version of the
`if ... elif ... elif ... else ...` idiom, with the
benefit that the condition–action blocks can be dynamically rearranged
and reconfigured at runtime.
This pattern aims to decouple the senders of a request from its
receivers by allowing request to move through chained
receivers until it is handled.
Request receiver in simple form keeps a reference to a single successor.
As a variation some receivers may be capable of sending requests out
in several directions, forming a `tree of responsibility`.
*TL;DR
Allow a request to pass down a chain of receivers until it is handled.
"""

import abc


class Handler(metaclass=abc.ABCMeta):

    def __init__(self, successor=None):
        self.successor = successor

    def handle(self, request):
        """
        Handle request and stop.
        If can't - call next handler in chain.
        As an alternative you might even in case of success
        call the next handler.
        """
        res = self.check_range(request)
        if not res and self.successor:
            self.successor.handle(request)

    @abc.abstractmethod
    def check_range(self, request):
        """Compare passed value to predefined interval"""


class ConcreteHandler0(Handler):
    """Each handler can be different.
    Be simple and static...
    """

    @staticmethod
    def check_range(request):
        if 0 <= request < 10:
            print("request {} handled in handler 0".format(request))
            return True


class ConcreteHandler1(Handler):
    """... With it's own internal state"""

    start, end = 10, 20

    def check_range(self, request):
        if self.start <= request < self.end:
            print("request {} handled in handler 1".format(request))
            return True


class ConcreteHandler2(Handler):
    """... With helper methods."""

    def check_range(self, request):
        start, end = self.get_interval_from_db()
        if start <= request < end:
            print("request {} handled in handler 2".format(request))
            return True

    @staticmethod
    def get_interval_from_db():
        return (20, 30)


class FallbackHandler(Handler):
    @staticmethod
    def check_range(request):
        print("end of chain, no handler for {}".format(request))
        return False


def main():
    """
    >>> h0 = ConcreteHandler0()
    >>> h1 = ConcreteHandler1()
    >>> h2 = ConcreteHandler2(FallbackHandler())
    >>> h0.successor = h1
    >>> h1.successor = h2
    >>> requests = [2, 5, 14, 22, 18, 3, 35, 27, 20]
    >>> for request in requests:
    ...     h0.handle(request)
    request 2 handled in handler 0
    request 5 handled in handler 0
    request 14 handled in handler 1
    request 22 handled in handler 2
    request 18 handled in handler 1
    request 3 handled in handler 0
    end of chain, no handler for 35
    request 27 handled in handler 2
    request 20 handled in handler 2
    """


if __name__ == "__main__":
    import doctest
    doctest.testmod(optionflags=doctest.ELLIPSIS)
```

#### Команда (Command)

паттерн Команда применяется для инкапсуляции команд в виде объектов. Например, с его помощью можно построить последовательность команд для отложенного выполнения или создать команды, допускающие отмену.

```python
"""
*TL;DR
Encapsulates all information needed to perform an action or trigger an event.
*Examples in Python ecosystem:
Django HttpRequest (without `execute` method):
 https://docs.djangoproject.com/en/2.1/ref/request-response/#httprequest-objects
"""

import os


class MoveFileCommand:
    def __init__(self, src, dest):
        self.src = src
        self.dest = dest

    def execute(self):
        self.rename(self.src, self.dest)

    def undo(self):
        self.rename(self.dest, self.src)

    def rename(self, src, dest):
        print("renaming {} to {}".format(src, dest))
        os.rename(src, dest)


def main():
    """
    >>> from os.path import lexists
    >>> command_stack = [
    ...     MoveFileCommand('foo.txt', 'bar.txt'),
    ...     MoveFileCommand('bar.txt', 'baz.txt')
    ... ]
    # Verify that none of the text files exist
    >>> assert not lexists("foo.txt")
    >>> assert not lexists("bar.txt")
    >>> assert not lexists("baz.txt")
    # Create empty file
    >>> open("foo.txt", "w").close()
    # Commands can be executed later on
    >>> for cmd in command_stack:
    ...     cmd.execute()
    renaming foo.txt to bar.txt
    renaming bar.txt to baz.txt
    # And can also be undone at will
    >>> for cmd in reversed(command_stack):
    ...     cmd.undo()
    renaming baz.txt to bar.txt
    renaming bar.txt to foo.txt
    >>> os.unlink("foo.txt")
    """


if __name__ == "__main__":
    import doctest
    doctest.testmod()
```

#### Интерпретатор (Interpreter)

Паттерн Интерпретатор формализует два типичных требования: предоставить средства, с помощью которых пользователь мог бы вводить в программу нестроковые значения, и дать пользователям возможность создавать программы.

На самом примитивном уровне  приложение получает от пользователя, или от другой программы, строки, которые необходимо каким-то образом интерпретировать (и, быть может, выполнить).

Примером широко распространенного воплощения таких требований является создание предметно-ориентированных языков (DSL).

```python
"""
Интерпретатор (Interpreter) - паттерн поведения классов.
Для заданного языка определяет представление его грамматики,
а также интерпретатор предложений этого языка.
"""


class RomanNumeralInterpreter(object):
    """Интерпретатор римских цифр"""
    def __init__(self):
        self.grammar = {
            'I': 1,
            'V': 5,
            'X': 10,
            'L': 50,
            'C': 100,
            'D': 500,
            'M': 1000
        }

    def interpret(self, text):
        numbers = map(self.grammar.get, text)  # строки в значения
        if None in numbers:
            raise ValueError('Ошибочное значение: %s' % text)
        result = 0  # накапливаем результат
        temp = None  # запоминаем последнее значение
        while numbers:
            num = numbers.pop(0)
            if temp is None or temp >= num:
                result += num
            else:
                result += (num - temp * 2)
            temp = num
        return result


interp = RomanNumeralInterpreter()
print interp.interpret('MMMCMXCIX') == 3999  # True
print interp.interpret('MCMLXXXVIII') == 1988  # True
```

#### Итератор (Iterator)

паттерн Итератор позвояет последовательно обойти элементы коллекции или агрегированного объекта, не раскрывая деталей их внутреннего устройства. Он настолько полезен, что в Python встроена его поддержка, а кроме того, предоставляются специальные методы, которые мы можем реализовать в собственных классах, чтобы органично поддержать итерирование.

Итерирование можно поддержать тремя способами: следуя протоколу последовательности, пользуясь вариантом встроенной функции iter() с двумя агрументами или следуя протоколу итератора.

```python
#!/usr/bin/env python3
# Copyright © 2012-13 Qtrac Ltd. All rights reserved.
# This program or module is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version. It is provided for educational
# purposes and is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.


class Bag:

    def __init__(self, items=None):
        self.__bag = {}
        if items is not None:
            for item in items:
                self.add(item)


    def clear(self):
        self.__bag.clear()


    def add(self, item):
        self.__bag[item] = self.__bag.get(item, 0) + 1


    def __delitem__(self, item):
        if self.__bag.get(item) is not None:
            self.__bag[item] -= 1
            if self.__bag[item] <= 0:
                del self.__bag[item]
        else:
            raise KeyError(str(item))


    def count(self, item):
        return self.__bag.get(item, 0)


    def __len__(self):
        return sum(count for count in self.__bag.values())


    def __iter__(self):
        return (item for item, count in self.__bag.items()
                for _ in range(count))


    items = __iter__


    def __contains__(self, item):
        return item in self.__bag

```

#### Посредник (Mediator)

Паттерн Посредник представляет средства для создания объекта - посредника - который инкапсулирует взаимодействия между другими объектами. Это позволяет осуществлять взаимодействия между объектами, которые ничего не знают друг о друге. Например, в случае нажатия кнопки соответствующий ей объект должен только известить посредника, а уж тот уведомит все объекты, которых интересует нажатие этой кнопки.

Посредник обеспечивает слабую связанность системы, избавляя объекты от необъодимости явно ссылаться друг на друга и позволяя тем самым независимо изменять взаимодействия между ними.

```python
"""
https://www.djangospin.com/design-patterns-python/mediator/
Objects in a system communicate through a Mediator instead of directly with each other.
This reduces the dependencies between communicating objects, thereby reducing coupling.
*TL;DR
Encapsulates how a set of objects interact.
"""


class ChatRoom:
    """Mediator class"""

    def display_message(self, user, message):
        print("[{} says]: {}".format(user, message))


class User:
    """A class whose instances want to interact with each other"""

    def __init__(self, name):
        self.name = name
        self.chat_room = ChatRoom()

    def say(self, message):
        self.chat_room.display_message(self, message)

    def __str__(self):
        return self.name


def main():
    """
    >>> molly = User('Molly')
    >>> mark = User('Mark')
    >>> ethan = User('Ethan')
    >>> molly.say("Hi Team! Meeting at 3 PM today.")
    [Molly says]: Hi Team! Meeting at 3 PM today.
    >>> mark.say("Roger that!")
    [Mark says]: Roger that!
    >>> ethan.say("Alright.")
    [Ethan says]: Alright.
    """


if __name__ == '__main__':
    import doctest
    doctest.testmod()
```

Еще пример

```python
#!/usr/bin/env python3
# Copyright © 2012-13 Qtrac Ltd. All rights reserved.
# This program or module is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version. It is provided for
# educational purposes and is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.

import collections


def main():
    form = Form()
    test_user_interaction_with(form)


class Form:

    def __init__(self):
        self.create_widgets()
        self.create_mediator()


    def create_widgets(self):
        self.nameText = Text()
        self.emailText = Text()
        self.okButton = Button("OK")
        self.cancelButton = Button("Cancel")


    def create_mediator(self):
        self.mediator = Mediator(((self.nameText, self.update_ui),
                (self.emailText, self.update_ui),
                (self.okButton, self.clicked),
                (self.cancelButton, self.clicked)))
        self.update_ui()


    def update_ui(self, widget=None):
        self.okButton.enabled = (bool(self.nameText.text) and
                                 bool(self.emailText.text))


    def clicked(self, widget):
        if widget == self.okButton:
            print("OK")
        elif widget == self.cancelButton:
            print("Cancel")


class Mediator:

    def __init__(self, widgetCallablePairs):
        self.callablesForWidget = collections.defaultdict(list)
        for widget, caller in widgetCallablePairs:
            self.callablesForWidget[widget].append(caller)
            widget.mediator = self


    def on_change(self, widget):
        callables = self.callablesForWidget.get(widget)
        if callables is not None:
            for caller in callables:
                caller(widget)
        else:
            raise AttributeError("No on_change() method registered for {}"
                    .format(widget))


class Mediated:

    def __init__(self):
        self.mediator = None


    def on_change(self):
        if self.mediator is not None:
            self.mediator.on_change(self)


class Button(Mediated):

    def __init__(self, text=""):
        super().__init__()
        self.enabled = True
        self.text = text


    def click(self):
        if self.enabled:
            self.on_change()


    def __str__(self):
        return "Button({!r}) {}".format(self.text,
                "enabled" if self.enabled else "disabled")


class Text(Mediated):

    def __init__(self, text=""):
        super().__init__()
        self.__text = text


    @property
    def text(self):
        return self.__text


    @text.setter
    def text(self, text):
        if self.text != text:
            self.__text = text
            self.on_change()


    def __str__(self):
        return "Text({!r})".format(self.text)


def test_user_interaction_with(form):
    form.okButton.click()           # Ignored because it is disabled
    print(form.okButton.enabled)    # False
    form.nameText.text = "Fred"
    print(form.okButton.enabled)    # False
    form.emailText.text = "fred@bloggers.com"
    print(form.okButton.enabled)    # True
    form.okButton.click()           # OK
    form.emailText.text = ""
    print(form.okButton.enabled)    # False
    form.cancelButton.click()       # Cancel


if __name__ == "__main__":
    main()

```

#### Хранитель (Memento)

Паттерн хранитель служит для сохранения и восстановленя состояния объекта, не нарушая инкапсуляцию.

В языке Python имеется готовая поддержка этого паттерна; с помощью модуля `pickle` мы можем сериализовать и десериализовать произвольные объекты Python (с некоторыми ограничениями, например, нельзя сериализовать файловый объект).

Даже в тех редких случаях, когда мы сталкиваемся с ограничением сериализации, всегда можно добавить собственную поддержку этого механизам, например, реализовав специальные методы `__getstate__()` и `__setstate__()` и, возможно, метод `__getnewargs__()`. Аналогично если мы захотим использовать формат JSON для своих классов, то сможем расширить кодировщик и декодировщик ищ модуля `json`.

Можно было бы придумать собственный формат и протоколы, но смысла в это немного, так как Python и так предоставляет развитую поддержку этого паттерна.

```python
"""
http://code.activestate.com/recipes/413838-memento-closure/
*TL;DR
Provides the ability to restore an object to its previous state.
"""

from copy import copy
from copy import deepcopy


def memento(obj, deep=False):
    state = deepcopy(obj.__dict__) if deep else copy(obj.__dict__)

    def restore():
        obj.__dict__.clear()
        obj.__dict__.update(state)

    return restore


class Transaction:
    """A transaction guard.
    This is, in fact, just syntactic sugar around a memento closure.
    """

    deep = False
    states = []

    def __init__(self, deep, *targets):
        self.deep = deep
        self.targets = targets
        self.commit()

    def commit(self):
        self.states = [memento(target, self.deep) for target in self.targets]

    def rollback(self):
        for a_state in self.states:
            a_state()


class Transactional:
    """Adds transactional semantics to methods. Methods decorated  with
    @Transactional will rollback to entry-state upon exceptions.
    """

    def __init__(self, method):
        self.method = method

    def __get__(self, obj, T):
        def transaction(*args, **kwargs):
            state = memento(obj)
            try:
                return self.method(obj, *args, **kwargs)
            except Exception as e:
                state()
                raise e

        return transaction


class NumObj:
    def __init__(self, value):
        self.value = value

    def __repr__(self):
        return '<%s: %r>' % (self.__class__.__name__, self.value)

    def increment(self):
        self.value += 1

    @Transactional
    def do_stuff(self):
        self.value = '1111'  # <- invalid value
        self.increment()  # <- will fail and rollback


def main():
    """
    >>> num_obj = NumObj(-1)
    >>> print(num_obj)
    <NumObj: -1>
    >>> a_transaction = Transaction(True, num_obj)
    >>> try:
    ...    for i in range(3):
    ...        num_obj.increment()
    ...        print(num_obj)
    ...    a_transaction.commit()
    ...    print('-- committed')
    ...    for i in range(3):
    ...        num_obj.increment()
    ...        print(num_obj)
    ...    num_obj.value += 'x'  # will fail
    ...    print(num_obj)
    ... except Exception:
    ...    a_transaction.rollback()
    ...    print('-- rolled back')
    <NumObj: 0>
    <NumObj: 1>
    <NumObj: 2>
    -- committed
    <NumObj: 3>
    <NumObj: 4>
    <NumObj: 5>
    -- rolled back
    >>> print(num_obj)
    <NumObj: 2>
    >>> print('-- now doing stuff ...')
    -- now doing stuff ...
    >>> try:
    ...    num_obj.do_stuff()
    ... except Exception:
    ...    print('-> doing stuff failed!')
    ...    import sys
    ...    import traceback
    ...    traceback.print_exc(file=sys.stdout)
    -> doing stuff failed!
    Traceback (most recent call last):
    ...
    TypeError: ...str...int...
    >>> print(num_obj)
    <NumObj: 2>
    """


if __name__ == "__main__":
    import doctest
    doctest.testmod(optionflags=doctest.ELLIPSIS)
```

#### Наблюдатель (Observer)

Паттерн Наблюдатель поддерживает отношения зависимости многие-ко-многим между объектами, например, когда изменяется состояние одного объекта, уведомляются все связанные с ним объекты. В наши дни, наверное самый распростарненный пример этого паттерна и его вариантов - парадигма модель-представление-контроллер (MVC). В этой парадигме модель описывает данные, одно или несколько предствалений эти данные визиалируют, а одни или несколько контроллеров осуществляют посредничество между вводом (например, взаимодействие с пользователем) и моделью. И любые изменения в модели автоматически отражаются в ассоциированных с ней представлениях.

У подхода MVC есть одно популярное упрощение - использовать только модели и представления, но поручить представлениям как визуализацию данных, так и передачу модели входных данных; иными словами, представления совмещены с контроллерами. В терминах паттерна Наблюдатель это означает, что представления - наблюдатели, а модель - наблюдаемый объект.

В качестве примеров можно назвать триггеры в базах данных, систему сигнализации Django, механизм сигналов и слотов в библиотеке QT и многочисленные применения технологии WebSockets.

```python
"""
http://code.activestate.com/recipes/131499-observer-pattern/
*TL;DR
Maintains a list of dependents and notifies them of any state changes.
*Examples in Python ecosystem:
Django Signals: https://docs.djangoproject.com/en/2.1/topics/signals/
Flask Signals: http://flask.pocoo.org/docs/1.0/signals/
"""


class Subject:
    def __init__(self):
        self._observers = []

    def attach(self, observer):
        if observer not in self._observers:
            self._observers.append(observer)

    def detach(self, observer):
        try:
            self._observers.remove(observer)
        except ValueError:
            pass

    def notify(self, modifier=None):
        for observer in self._observers:
            if modifier != observer:
                observer.update(self)


class Data(Subject):
    def __init__(self, name=''):
        Subject.__init__(self)
        self.name = name
        self._data = 0

    @property
    def data(self):
        return self._data

    @data.setter
    def data(self, value):
        self._data = value
        self.notify()


class HexViewer:
    def update(self, subject):
        print('HexViewer: Subject {} has data 0x{:x}'.format(subject.name, subject.data))


class DecimalViewer:
    def update(self, subject):
        print('DecimalViewer: Subject %s has data %d' % (subject.name, subject.data))


def main():
    """
    >>> data1 = Data('Data 1')
    >>> data2 = Data('Data 2')
    >>> view1 = DecimalViewer()
    >>> view2 = HexViewer()
    >>> data1.attach(view1)
    >>> data1.attach(view2)
    >>> data2.attach(view2)
    >>> data2.attach(view1)
    >>> data1.data = 10
    DecimalViewer: Subject Data 1 has data 10
    HexViewer: Subject Data 1 has data 0xa
    >>> data2.data = 15
    HexViewer: Subject Data 2 has data 0xf
    DecimalViewer: Subject Data 2 has data 15
    >>> data1.data = 3
    DecimalViewer: Subject Data 1 has data 3
    HexViewer: Subject Data 1 has data 0x3
    >>> data2.data = 5
    HexViewer: Subject Data 2 has data 0x5
    DecimalViewer: Subject Data 2 has data 5
    # Detach HexViewer from data1 and data2
    >>> data1.detach(view2)
    >>> data2.detach(view2)
    >>> data1.data = 10
    DecimalViewer: Subject Data 1 has data 10
    >>> data2.data = 15
    DecimalViewer: Subject Data 2 has data 15
    """


if __name__ == "__main__":
    import doctest
    doctest.testmod()
```

#### Состояние (State)

Паттерн Состояние предназначен для создания объектов, поведение которых изменяется при изменении состояния; это означает, что у объекта есть режими работы. Извне создается впечатление, что изменился класс объекта.

К обработке состояния, хранящегося внутри класса, есть два основных подхода. Первый - использование методов, чувствительных к состоянию. Второй - использование определяемых состоянием методов.

```python
"""
Implementation of the state pattern
http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/
*TL;DR
Implements state as a derived class of the state pattern interface.
Implements state transitions by invoking methods from the pattern's superclass.
"""


class State:

    """Base state. This is to share functionality"""

    def scan(self):
        """Scan the dial to the next station"""
        self.pos += 1
        if self.pos == len(self.stations):
            self.pos = 0
        print("Scanning... Station is {} {}".format(self.stations[self.pos], self.name))


class AmState(State):
    def __init__(self, radio):
        self.radio = radio
        self.stations = ["1250", "1380", "1510"]
        self.pos = 0
        self.name = "AM"

    def toggle_amfm(self):
        print("Switching to FM")
        self.radio.state = self.radio.fmstate


class FmState(State):
    def __init__(self, radio):
        self.radio = radio
        self.stations = ["81.3", "89.1", "103.9"]
        self.pos = 0
        self.name = "FM"

    def toggle_amfm(self):
        print("Switching to AM")
        self.radio.state = self.radio.amstate


class Radio:

    """A radio. It has a scan button, and an AM/FM toggle switch."""

    def __init__(self):
        """We have an AM state and an FM state"""
        self.amstate = AmState(self)
        self.fmstate = FmState(self)
        self.state = self.amstate

    def toggle_amfm(self):
        self.state.toggle_amfm()

    def scan(self):
        self.state.scan()


def main():
    """
    >>> radio = Radio()
    >>> actions = [radio.scan] * 2 + [radio.toggle_amfm] + [radio.scan] * 2
    >>> actions *= 2
    >>> for action in actions:
    ...    action()
    Scanning... Station is 1380 AM
    Scanning... Station is 1510 AM
    Switching to FM
    Scanning... Station is 89.1 FM
    Scanning... Station is 103.9 FM
    Scanning... Station is 81.3 FM
    Scanning... Station is 89.1 FM
    Switching to AM
    Scanning... Station is 1250 AM
    Scanning... Station is 1380 AM
    """


if __name__ == '__main__':
    import doctest
    doctest.testmod()
```

Еще пример

```python
"""
Состояние (State) - паттерн поведения объектов.
Позволяет объекту варьировать свое поведение в зависимости от внутреннего состояния.
Извне создается впечатление, что изменился класс объекта.
"""


class LampStateBase(object):
    """Состояние лампы"""
    def get_color(self):
        raise NotImplementedError()


class GreenLampState(LampStateBase):
    def get_color(self):
        return 'Green'


class RedLampState(LampStateBase):
    def get_color(self):
        return 'Red'


class BlueLampState(LampStateBase):
    def get_color(self):
        return 'Blue'


class Lamp(object):
    def __init__(self):
        self._current_state = None
        self._states = self.get_states()

    def get_states(self):
        return [GreenLampState(), RedLampState(), BlueLampState()]

    def next_state(self):
        if self._current_state is None:
            self._current_state = self._states[0]
        else:
            index = self._states.index(self._current_state)
            if index < len(self._states) - 1:
                index += 1
            else:
                index = 0
            self._current_state = self._states[index]
        return self._current_state

    def light(self):
        state = self.next_state()
        print state.get_color()


lamp = Lamp()
[lamp.light() for i in range(3)]
# Green
# Red
# Blue
[lamp.light() for i in range(3)]
# Green
# Red
# Blue
```

#### Стратегия (Strategy)

Паттерн Стратегия позволяет инкапсулировать набор взаимозаменяемых алгоритмов, из которых пользователь выбирает тот, что ему нужен.

```python
"""
Стратегия (Strategy) - паттерн поведения объектов.
Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.
Стратегия позволяет изменять алгоритмы независимо от клиентов, которые ими пользуются.
"""


class ImageDecoder(object):
    @staticmethod
    def decode(filename):
        raise NotImplementedError()


class PNGImageDecoder(ImageDecoder):
    @staticmethod
    def decode(filename):
        print 'PNG decode'


class JPEGImageDecoder(ImageDecoder):
    @staticmethod
    def decode(filename):
        print 'JPEG decode'


class GIFImageDecoder(ImageDecoder):
    @staticmethod
    def decode(filename):
        print 'GIF decode'


class Image(object):
    @classmethod
    def open(cls, filename):
        ext = filename.rsplit('.', 1)[-1]
        if ext == 'png':
            decoder = PNGImageDecoder
        elif ext in ('jpg', 'jpeg'):
            decoder = JPEGImageDecoder
        elif ext == 'gif':
            decoder = GIFImageDecoder
        else:
            raise RuntimeError('Невозможно декодировать файл %s' % filename)
        byterange = decoder.decode(filename)
        return cls(byterange, filename)

    def __init__(self, byterange, filename):
        self._byterange = byterange
        self._filename = filename


Image.open('picture.png')  # PNG decode
Image.open('picture.jpg')  # JPEG decode
Image.open('picture.gif')  # GIF decode
```

Еще пример

```python
"""
*What is this pattern about?
Define a family of algorithms, encapsulate each one, and make them interchangeable.
Strategy lets the algorithm vary independently from clients that use it.
*TL;DR
Enables selecting an algorithm at runtime.
"""


class Order:
    def __init__(self, price, discount_strategy=None):
        self.price = price
        self.discount_strategy = discount_strategy

    def price_after_discount(self):
        if self.discount_strategy:
            discount = self.discount_strategy(self)
        else:
            discount = 0
        return self.price - discount

    def __repr__(self):
        fmt = "<Price: {}, price after discount: {}>"
        return fmt.format(self.price, self.price_after_discount())


def ten_percent_discount(order):
    return order.price * 0.10


def on_sale_discount(order):
    return order.price * 0.25 + 20


def main():
    """
    >>> Order(100)
    <Price: 100, price after discount: 100>
    >>> Order(100, discount_strategy=ten_percent_discount)
    <Price: 100, price after discount: 90.0>
    >>> Order(1000, discount_strategy=on_sale_discount)
    <Price: 1000, price after discount: 730.0>
    """


if __name__ == "__main__":
    import doctest
    doctest.testmod()
```

#### Шаблонный метод (Template method)

Паттерн Шаблонный метод позволяет определить шаги алгоритма, оставив реализацию некоторых шагов подклассам.

Паттерн Шаблонный метод в некоторых отношениях похож на паттерн Мост.

```python
"""
Шаблонный метод (Template method) - паттерн поведения классов.
Шаблонный метод определяет основу алгоритма и позволяет подклассам переопределить некоторые шаги алгоритма,
не изменяя его структуру в целом.
"""


class ExampleBase(object):
    def template_method(self):
        self.step_one()
        self.step_two()
        self.step_three()

    def step_one(self):
        raise NotImplementedError()

    def step_two(self):
        raise NotImplementedError()

    def step_three(self):
        raise NotImplementedError()


class Example(ExampleBase):
    def step_one(self):
        print 'Первый шаг алгоритма'

    def step_two(self):
        print 'Второй шаг алгоритма'

    def step_three(self):
        print 'Третий шаг алгоритма'


example = Example()
example.template_method()

# Первый шаг алгоритма
# Второй шаг алгоритма
# Третий шаг алгоритма
```

Еще пример

```python
"""
An example of the Template pattern in Python
*TL;DR
Defines the skeleton of a base algorithm, deferring definition of exact
steps to subclasses.
*Examples in Python ecosystem:
Django class based views: https://docs.djangoproject.com/en/2.1/topics/class-based-views/
"""


def get_text():
    return "plain-text"


def get_pdf():
    return "pdf"


def get_csv():
    return "csv"


def convert_to_text(data):
    print("[CONVERT]")
    return "{} as text".format(data)


def saver():
    print("[SAVE]")


def template_function(getter, converter=False, to_save=False):
    data = getter()
    print("Got `{}`".format(data))

    if len(data) <= 3 and converter:
        data = converter(data)
    else:
        print("Skip conversion")

    if to_save:
        saver()

    print("`{}` was processed".format(data))


def main():
    """
    >>> template_function(get_text, to_save=True)
    Got `plain-text`
    Skip conversion
    [SAVE]
    `plain-text` was processed
    >>> template_function(get_pdf, converter=convert_to_text)
    Got `pdf`
    [CONVERT]
    `pdf as text` was processed
    >>> template_function(get_csv, to_save=True)
    Got `csv`
    Skip conversion
    [SAVE]
    `csv` was processed
    """


if __name__ == "__main__":
    import doctest
    doctest.testmod()
```

#### Посетитель (Visitor)

Паттерн Посетитель используется, когда нужно применить некую функцию к каждому элементу коллекции или объекту-агрегатору. Это не то же самое, что типичное использование паттерна Итератор - где мы обходим коллекцию или агрегат и вызываем некий метод для каждого элемента, - поскольку в случае "посетителя" вызывается внешнняя функция, а не метод.

В Python имеется встроенная поддержва этого паттерна. Например конструкция `new_list = map(function, old_sequence)` означает, что `function()` вызывается для каждого элемента `old_sequence`, в результате чего порождается `new_list`

```python
"""
Постетитель (Visitor) - паттерн поведения объектов.
Описывает операцию, выполняемую с каждым объектом из некоторой структуры.
Паттерн посетитель позволяет определить новую операцию, не изменяя классы этих объектов.
"""


class FruitVisitor(object):
    """Посетитель"""
    def draw(self, fruit):
        methods = {
            Apple: self.draw_apple,
            Pear: self.draw_pear,
        }
        draw = methods.get(type(fruit), self.draw_unknown)
        draw(fruit)

    def draw_apple(self, fruit):
        print 'Яблоко'

    def draw_pear(self, fruit):
        print 'Груша'

    def draw_unknown(self, fruit):
        print 'Фрукт'


class Fruit(object):
    """Фрукты"""
    def draw(self, visitor):
        visitor.draw(self)


class Apple(Fruit):
    """Яблоко"""


class Pear(Fruit):
    """Груша"""


class Banana(Fruit):
    """Банан"""


visitor = FruitVisitor()

apple = Apple()
apple.draw(visitor)
# Яблоко

pear = Pear()
pear.draw(visitor)
# Груша

banana = Banana()
banana.draw(visitor)
# Фрукт
```

Еще пример

```python
"""
http://peter-hoffmann.com/2010/extrinsic-visitor-pattern-python-inheritance.html
*TL;DR
Separates an algorithm from an object structure on which it operates.
An interesting recipe could be found in
Brian Jones, David Beazley "Python Cookbook" (2013):
- "8.21. Implementing the Visitor Pattern"
- "8.22. Implementing the Visitor Pattern Without Recursion"
*Examples in Python ecosystem:
- Python's ast.NodeVisitor: https://github.com/python/cpython/blob/master/Lib/ast.py#L250
which is then being used e.g. in tools like `pyflakes`.
- `Black` formatter tool implements it's own: https://github.com/ambv/black/blob/master/black.py#L718
"""


class Node:
    pass


class A(Node):
    pass


class B(Node):
    pass


class C(A, B):
    pass


class Visitor:
    def visit(self, node, *args, **kwargs):
        meth = None
        for cls in node.__class__.__mro__:
            meth_name = 'visit_' + cls.__name__
            meth = getattr(self, meth_name, None)
            if meth:
                break

        if not meth:
            meth = self.generic_visit
        return meth(node, *args, **kwargs)

    def generic_visit(self, node, *args, **kwargs):
        print('generic_visit ' + node.__class__.__name__)

    def visit_B(self, node, *args, **kwargs):
        print('visit_B ' + node.__class__.__name__)


def main():
    """
    >>> a, b, c = A(), B(), C()
    >>> visitor = Visitor()
    >>> visitor.visit(a)
    generic_visit A
    >>> visitor.visit(b)
    visit_B B
    >>> visitor.visit(c)
    visit_B C
    """


if __name__ == "__main__":
    import doctest
    doctest.testmod()
```

#### Поведенческие паттерны. Итог

Для некоторых поведенческих паттернов в Python имеется прямая поддержка; остальные нетрудно реализовать самостоятельно. Паттерны Цепочка ответственности, Посредник и Наблюдатель можно реализовать традиционным способом или с помощью сопрограмм, и все они являются вариациями на тему разрыва связи между взаимодействующими объектами. Паттерн Команда можно использовать для отложенного вычисления и реализации механизма выполнения-отмена. Поскольку Python - интерпретируемый язык (на уровне байт-кода), то паттерн Интерпретатор можно реализовать с помощью самого Python и даже изолировать интерпретируемый код в отдельном процессе. Поддержка паттерна Итератор (и - неявно - паттерна посетитель) встроена в Python. Паттерн Хранитель неплохо поддержан в стандартной библиотеке Python (например, с помощью модулей `pickle` и `json`). У паттернов Состояние, Стратегия и Шаблонный метод прямой поддержки нет, но все они легко реализуются.


