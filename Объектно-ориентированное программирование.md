# Объектно-ориентированное программирование
## Общие положения и концепция
**Объектно ориентированное программирование** — парадигма программирования, с помощью которой программу можно представить в виде совокупности взаимодействующих между собой объектов, каждый из которых является экземпляром определенного класса, и каждый класс может наследоваться от другого класса, тем самым приобретая свойства и методы родителя.

**Класс** можно представить в виде шаблона на основе которого будут создаваться объекты определенного типа, которые будут иметь свойства и методы описанные в этом классе.

**Объект** определенного класса можно назвать экземпляром этого класса. При создании экземпляра, описываются все необходимые свойства и объект будет иметь доступ ко всем методам и атрибутам класса.

**Атрибуты класса / Свойства / Поля класса** — это определенные данные, которые понадобятся при создании объекта для определения его структуры.

**Методы** — это функции класса, которые содержат набор инструкций для оперирования объектами этого класса . Методы имеют доступ ко всем свойствам объекта для которого вызываются. Можно сказать, что метод определяет поведение объекта для которого вызывается.

**Магический метод или атрибут** — (magic or dunder – double underscore). Каждый отдельный магический метод автоматически вызывается  в определенный промежуток времени. 
### Инкапсуляция | Понятие
Класс должен восприниматься как единая целостная конструкция. Все внутренние манипуляции с его данными должны быть сокрыты в этом классе и в идеале не доступны обычному пользователю извне. 

Простыми словами, программист, который использует этот класс для разработки чего-либо, имел бы доступ только к разрешенным методами и свойствам, которые необходимы для его проекта. 

Пример для понимания:
При вождении автомобиля водителю необходимо знать его характеристики или размеры. Обладать некоторым набором инструкций для управления этим автомобилем. Но совершенно нет необходимости иметь доступ к двигателю, коробке передач, тормозной системе и оперировать ими напрямую. 
Инкапсуляция — это принцип в ООП, при котором происходит разделение методов и свойств класса по уровням доступа. 
Наследование | Понятие
Это принцип, когда общие свойства и методы присущие нескольким классам выносятся в отдельный базовый класс и от него наследуются другими. 

Таким образом соблюдается принцип DRY — Don’t repeat yourself — исключается повторение одинаковый элементов. 
### Полиморфизм | Понятие
Возможность через единый интерфейс работать с объектами разных классов. В программировании различают два типа полиморфизма:
#### Ad-hoc
Реализуется через перегрузку функций и приведение различных типов данных. В Python не используется. Нужно изучить отдельно.
#### Параметрический
Дает возможность оперировать объектами разных классов через единый базовый класс. 
# Атрибуты классов и объектов
```
class Point:
	    COLOR = ‘red’
	    CIRCLE = 1
```
```__dict__``` — магическая переменная / магический атрибут  класса, который хранит  и все атрибуты и методы класса в коллекции наподобие словаря — mappingproxy
```__doc__``` — возвращает докстринг класса.

Хорошей практикой считается создание документации для ключевых классов.

```
Point.__dict__
mappingproxy({'__module__': '__main__', 'color': 'red', 'circle': 2, '__dict__': <attribute '__dict__' of 'Point' objects>, '__weakref__': <attribute '__weakref__' of 'Point' objects>, '__doc__': None, '__annotations__': {}})
```
Атрибуты класса являются общими для всех экземпляров класса и они могут на них ссылаться. 

```
>> a = Point()
>> a.COLOR
>> ‘red’
```
## Внимательнее
Если через объект ссылаясь к атрибуту класса попытаться присвоить ему новое значение, у экземпляра появится собственный локальный атрибут с таким же именем, как у атрибута класса, а последний останется без изменений.
```
>> a.color = ‘green’
>> a.__dict__
>> {‘color’: ‘green’}
>> Point.__dict__
>> {..., ‘color’: ‘red’, …}
```
## Создание локального атрибута экземпляра
Эти атрибуты создаются для каждого отдельного экземпляра и в отличие от атрибутов класса, которые общие для всех объектов, они независимы.
```
>> a.x = 1
>> a.y = 2
```
## Функции delattr(), getattr(), setattr(), hasattr()
### Добавить новый атрибут класса
Используя этот же синтаксис в отношение класса можно добавлять новые свойства.
```
>> Point.type_pt = ‘disc’
```
Также существует возможность создания нового свойства или изменение существующего при помощи функции setattr(class, ‘attr_name’, ‘attr_value’)
```
>> setattr(Point, ‘prop’, 1)
>> Point.prop
>> 1
```
### Получить значение атрибута
При помощи функции getattr(class, attr_name, False) можно обратиться к определенному свойству. Только в отличие от обращения  типа class.attr, в этой функции третьим аргументом можно задать значение, которое вернется в случае отсутствия искомого свойства класса.

Если же обращаться к несуществующему атрибуту через точку или с помощью getattr() без третьего аргумента, то возникнет исключение с соответствующим сообщением. 
### Проверка на существование атрибута
Проверить существует ли тот или иной атрибут можно при помощи функции hasattr(class, ‘attr_name’).
```
>> hasattr(Point, ‘color’)
>> True
```
Важно уточнить, что используя эту функцию проверки можно обратиться к атрибуту класса, но это не будет значить что в пространстве имен экземпляра тоже есть атрибут с таким именем, просто этот экземпляр имеет доступ к этому атрибуту. 
```
>>hasattr(a, ‘color’)
>> True
>> a.__dict__
>> {}
```
### Удаление атрибута0
Удалить атрибут в пространстве имен (класса или экземпляра) можно используя оператор del.
```
>> del Point.prop
```
Еще один способ удаления атрибута из пространства имен это использовать функцию delattr(class, 'attr_name')

* Удалить можно только существующие атрибуты. В противном случае возникнет исключение 

* Если удалить локальный атрибут экземпляра, то обратно вернется ссылка к атрибуту класса. 
# Паттерн Singleton
**Файл: singleton.py**

Паттерн Singleton предоставляет механизм для создания только одного экземпляра класса. При попытке создания нового объекта этого класса, будет возвращаться уже созданный ранее экземпляр.

В Python это реализуется переопределением магического метода ```__new__()```. Перед этим нужно объявить приватный атрибут класса, который будет принимать в себя ссылку на создаваемый объект и установить значение None. 

Далее нужно переопределить ```__new__ ()```таким образом, чтобы если переменная еще не содержит ссылку на объект, то присвоить ей эту ссылку забрав ее у object используя ```super()```.

Во всех остальных случаях, ```__new__()``` будет возвращать приватный атрибут, который содержит в себе ссылку на ранее созданный объект, так как уже приватный атрибут класса не будет переопределяться внутри ```__new__()```.
# Декораторы @classmethod & @staticmethod
**Файл: about_static.py**
```
class Vector:
   MIN_COORD = 0  # Атрибуты класса с заглавной
   MAX_COORD = 100 # Считается хорошей практикой

   @classmethod
   def validate(cls, arg):
       return cls.MIN_COORD <= arg <= cls.MAX_COORD

   @staticmethod
   def norm2(x, y):
       return x * x + y * y
```
## Метод класса
При помощи декоратора ```@classmethod``` можно объявить метод класса, который будет работать с атрибутами класса, но не сможет обращаться к локальным атрибутам объекта, так как принимает ссылку на класс, а не на объект.

Метод класса можно вызывать через класс, где он объявлен или через экземпляр класса, так как объект все равно содержит информацию о классе и интерпретатор поймет с каким классом нужно взаимодействовать. Хорошей практикой считается второй вариант, обращение в методу класса через ссылку на экземпляр, так как если в будущем придется поменять название класса, метод не будет требовать редактирования. 
## Статические методы
Статические методы определяются при помощи декоратора ```@staticmethod``` и их отличие заключается в том, что они не имеют доступа ни к атрибутам класса, ни к атрибутам экземпляра. 

Можно сказать, что это независимая, самостоятельная функция объявленная в пространстве имен класса для удобства, которая использует некоторый вспомогательный код близкий к тематике класса. Не принимает ссылки на объект или класс. 

В глобальном пространстве имен вызывается через название класса. В пространстве имен методов, можно обращаться через ```self```.
# Механизм инкапсуляции
**Файлы: encapsulation.py, about_property.py**

Ограничение доступа к методам и данным класса извне можно назвать основой механизма инкапсуляции. Если классифицировать методы по доступу, то можно выделить три режима: public, protected, private.
## Public
```attribute``` — без подчеркиваний в начале — публичное свойство public. К атрибутам и методам можно обращаться из глобального пространства имен. 
## Protected
```_attribute``` — с одним подчеркиванием в начале — защищенный режим доступа protected. Служит для обращения внутри класса и во всех его дочерних классах.
Стоит понимать, что режим доступа protected в Python лишь сигнализирует разработчику, что атрибут или метод является защищенным, но никак не ограничивает его действия с ним.
## Private
```__arrtibute``` — с двумя подчеркиваниями в начале — режим доступа private. Служит для обращения только внутри класса, где метод определен.
   
Если попробовать обратиться к приватному атрибуту или методу извне, то  интерпретатор не сможет его найти и возникнет AttributeError. В пространстве имен класса можно без проблем взаимодействовать с ними.

Существует способ узнать кодовое имя приватного атрибута и используя его обратиться к атрибуту в глобальном пространстве имен — использовать функцию dir(). Она вернет список всех атрибутов и методов класса, где можно найти срощенные с именем класса названия приватных атрибутов. 

Но такой подход не рекомендуется и возможен только в самых крайних случаях. Работать с приватными или защищенными свойствами и методами принято только при помощи интерфейсных методов. 
## Интерфейсные методы | Сеттеры и геттеры
Следуя принципу инкапсуляции — … чтобы не нарушить целостность работы алгоритма внутри класса, следует взаимодействовать с ним только с помощью публичных свойств и методов… — для переопределения или получения приватных данных принято использовать интерфейсные методы внутри класса, которые называются setter и getter.
## Свойства property 
Как известно, если у объекта или класса определены приватные атрибуты, к ним нужно обращаться или переопределять при помощи методов, которые называются сеттеры и геттеры. 

Таких атрибутов может быть достаточно много и разработчику придется определить к каждому атрибуту свой геттер и сеттер и держать в голове имя каждого метода.

Один из способов решить эту проблему – воспользоваться объектом property.

Можно сказать, что главной опцией объектов property является создание общего имени для сеттера, геттера или делитера, которое хранит ссылки на них и через это имя, в зависимости от используемого оператора (присвоения, удаления, отсутствия оператора) можно вызвать нужный метод.
## Модуль accessify
Служит для установки дополнительной защиты методов.
```
>> pip install accessify
>> from accessify import private, protected
```
Можно обернуть метод  в нужный декоратор и он приобретет нужный режим доступа и нельзя будет получить его кодовое имя с помощью dir(). Но декорировать нужно обычный публичный метод. Если применить декоратор к приватному методу, то он отобразится в списке dir() / ```__dict__```.

# Паттерн «Моносостояние» | Monostate
**Файл: monostate.py**

Механизм, который позволяет создавать множество экземпляров определенного класса имеющих общие локальные атрибуты, и когда изменение атрибутов любого отдельного экземпляра этого класса вызывает изменение свойств всех остальных, называется паттерном «Моносостояние»
## Реализация в Python
Для этого нужно создать приватный атрибут, который имеет тип словаря Python, и перечислить там необходимые данные. 
Далее определить инициализатор, который принимает только один аргумент — ссылку на объект self, и указать, что при создании каждого нового экземпляра, локальные атрибуты объекта будут принимать значение приватного атрибута класса. Это делается через переопределение магического атрибута ```__dict__```, который возвращает атрибуты и методы объекта. 
# Функция hash() и хэши объектов 
**Файл:  hash.py** 

Хеширование — это преобразование информации при помощи специальных математических алгоритмов. В результате возникает хеш — отображение данных в виде короткой строки или числа, в идеале — уникальной для каждого набора информации. 

В программировании ассоциативные массивы, в Python представлены в виде словаря, используют хеширование для ключей. 

Функция ```hash()``` в Python вычисляет хеш для неизменяемого объекта по определенному алгоритму.

* Если объекты a == b (равны), то равен и их хеш.
* Равенство хешей hash(a) == hash(b) не гарантирует равенство объектов.
* Если хеши не равны hash(a) != hash(b), можно смело утверждать, что и объекты не равны. 
* Изменяемые объекты являются нехешируемыми. 

Объекты пользовательских классов в Python воспринимаются как неизменяемые объекты и у них можно вычислить хэш используя функцию hash().

Если создать два экземпляра одного класса с одинаковыми локальными атрибутами, они будут представлять из себя два разных объекта с разными адресами в памяти.

Если в пользовательском классе переопределить магический ```__eq__()```, то стандартный алгоритм вычисления хеша для объектов этого класса перестает работать. 

Для вычисления хеша объектов применяется магический метод ```__hash__()```. Если переопределить его поведение в пользовательском классе, можно сделать так, чтобы хеш вычислялся не для объектов в целом, а для локальных атрибутов класса. 
Таким образом если переопределить два магических метода: ```__hash__() и __eq__()```, можно сделать так, что два экземпляра класса будут равны при сравнении и будут иметь одинаковый хеш. Но адреса в памяти у объектов будут разные.
# Функция bool() и магический __ bool__()
**Файл: bool.py**

Для пустых объектов встроенных типов функция bool() возвращает False, в остальных случаях True. 

По умолчанию функция bool() возвращает True для любых объектов пользовательских классов. 

Изменить это поведение возможно, если переопределить один из магических методов:
```__len__()``` — вызывается функцией bool(), если не переопределен магический метод ```__bool__()```. Если возвращаемое значение ```__len__()``` будет больше 0, функция bool() вернет True и наоборот.
```__bool__()``` вызывается в приоритетном порядке функцией bool(). Если переопределен этот метод, ```__len__()``` не будет вызываться. 


Изменить поведение булевого метода может быть  полезно для пользовательского класса, когда нужно вернуть логическое состояние экземпляра, которое будет зависеть от заданных локальных атрибутов. 
# Магические / dunder-методы
__магический метод__(self) — dunder от double underscore — специальные методы языка, который определяются / переопределяются в классах и имеют по два подчеркивания спереди и сзади.
## ```__init__(), __del__(), __new__()```
**Файл: singleton.py**

### ```__new__()```
* в Python3 все классы неявно наследуются от базового класса object.

Магический метод ```__new__()``` неявно вызывается интерпретатором перед созданием экземпляра класса и возвращает ссылку по которой будет создан объект и далее при помощи конструктора ```__init__()``` примет необходимые свойства.
```
class Point:
   def __new__(cls, *args, **kwargs):  #Переопределение
     	print('__new__ calling')
return super().__new__(cls)  #Возвращаем ссылку на класс
   def __init__(self, x, y):
       print('__init__ calling')
       self.x = x
       self.y = y
* cls — ссылка на текущий класс
* self — ссылка на создаваемый объект
```
### ```__init__() — конструктор / инициализатор```
```
class Point:
   color = 'red'
   circle = 1

   def __init__(self, x, y):
       self.x = x
       self.y = y
* параметры конструктора принято называть аналогично атрибутам объекта.
* хоть метод и магический, ничего не мешает устанавливать параметры по умолчанию, как в обычной функции
```
```__init__()``` — инициализатор объекта класса / его еще называют конструктором. Вызывается при  создании экземпляра класса, после магического метода __new__().
Позволяет задать необходимые атрибуты объекта при его создании. 
```
>> pt = Point(1, 2)
```
### ```__del__ — финализатор / деструктор``` 
Автоматически вызывается непосредственно перед уничтожением экземпляра класса.
 
Когда на объект пропадает ссылка, то есть происходит переопределение переменной со ссылкой на некоторый экземпляр класса, сборщик мусора Python понимает, что этот объект больше не используется и удаляет его из памяти. При этом вызывается магический метод ```__del__()```. 

В крайне редких случаях, можно переопределить этот метод и добавить дополнительный функционал, который будет реализован перед удалением объекта. 


## ```__setattr__(), __getattribute__(), __getattr__() и __delattr__()```
**Файл: magic_attr_meths.py**
### Важно понимать
Принято разделять атрибуты и методы класса. Хотя названия методов тоже являются атрибутами класса и их можно получить при помощи магического атрибута ```__dict__```.
Как известно атрибуты класса являются общими для всех экземпляров класса. Через объект можно свободно обращаться к атрибутам класса, так как экземпляр содержит ссылку на пространство имен класса. 

Когда интерпретатору дается команда извлечь / получить атрибут с определенным, названием, сначала производится поиск в пространстве имен объекта, затем если соответствующий объект не найден, поиск переходит в пространство имен класса.

Если нужно обратиться к атрибутам класса внутри методов, то лучше это делать через ссылку на объект ```self```, а не через название класса, так как название класса в будущем может измениться, а self встроен в интерпретатор. 

Если через ссылку на объект self попытаться присвоить атрибуту класса новое значение, атрибут класса не будет переопределен, а в пространстве имен объекта будет создан новый атрибут с именем атрибута класса. Так работает оператор присваивания в классах Python. 
Стоит запомнить, что через self можно обратиться к атрибуту класса, но не стоит пытаться присвоить ему новое значение, так как интерпретатор сначала ищет имя атрибута в локальном пространстве объекта и не найдя его там, понимая что используется оператор присваивания, создает новый атрибут объекта.

В этом случае нужно использовать декоратор метода класса @classmethod и использовать ссылку на класс cls. И через эту ссылку переопределять атрибут класса.  Используя такой метод, можно быть уверенным, что взаимодействуют только атрибуты класса.
### ```__setattr__```
```__setattr__(self, key, value)``` — автоматически вызывается при изменении свойства key класса / при присвоении атрибуту определенного  значения.
При переопределении дает возможность управлять изменением того или иного атрибута. Например, запрет на присвоение атрибуту определенного значения или запрет на создание нового атрибута с определенным названием:
```
def __setattr__(self, key, value):
   # Добавляем новый функционал
   print('__setattr__ is calling')  # Строчка, чтобы показать, что метод выполняется при обращении
   if key == 'z':
       raise AttributeError('Unacceptable attribute name')
   else:
       return object.__setattr__(self, key, value)  # После переопределения нужно не забывать возвращать базовый метод
```
### ```__getattribute__```
```__getattribute__(self, item)``` — автоматически вызывается при получении свойства класса с именем item / обращении к свойству класса с указанным именем. При переопределении дает возможность управлять обращением / получением того или иного атрибута.

Случаи когда нужно переопределять этот метод редки. В качестве примера можно сделать такое переопределение:
```
   def __getattribute__(self, item):  # Переопределяем базовый метод
        # Добавляем новый функционал
        print('__getattribute__ is calling')  # Строчка, чтобы показать, что метод выполняется при обращении
        # Код ниже закрывает доступ к указанному атрибуту
        if item == 'x':
            raise ValueError('Access to the attribute is denied')
        else:
            return object.__getattribute__(self, item) # После переопределения нужно не забывать возвращать базовый метод
```
### ```__getattr__```
```__getattr__(self, item)``` — автоматически вызывается каждый раз при получении / обращении к  несуществующему свойству класса с именем item.
При переопределении можно изменить поведение при попытке получения несуществующего атрибута. Например, если атрибут не существует,  вместо ошибки, запрос будет возвращать False:
```
def __getattr__(self, item):
   print('__getattr__ is calling for ' + item) # Строчка, чтобы показать, что метод выполняется при обращении
   return False
__delattr__
__delattr__(self, item) — автоматически вызывается при удалении свойства item; неважно существует это свойство или нет. 
```
## Дескрипторы
**Файл: descriptors.py**

Дескриптор – класс в котором переопределены магические методы ```__get__(), __set__() или  __delete__()```. При помощи этих методов, через объект дескриптора можно управлять свойствами в другом классе. Можно сказать, что эти методы являются предопределенными сеттером, геттером и делитером. 

* Классу-дескриптору можно задать любое удобное имя.

* Если в дескрипторе содержится только магический метод ```__get__()```, то  это ```non-data descriptor```, если есть еще и сеттер, то это ```data descriptor```.

* Дескриптор данных имеет высший приоритет, как и property. Например, если создать локальный атрибут экземпляра с именем совпадающим с именем дескриптора, при попытке получить этот атрибут, сработает геттер дескриптора и вернется атрибут заданный дескриптором.

* non-data descriptor может только считывать данные и имеет приоритет обычного атрибута класса. То есть если при попытке через дескриптор задать новое значение атрибуту, будет создан локальный атрибут с именем атрибута класса, а не новым заданным именем в ```__set_name__()``` методе.

Если рассматривать data descriptor, нужно создать класс с методами:
```__set_name__(), __set__(), __get__ и __delete__(опционально).```

Как только в классе объявляется экземпляр дескриптора, автоматически срабатывает метод ```__set_name__()```. Метод принимает аргументы: ссылка на экземпляр – ```self```,  ссылка на класс где объявлен дескриптор – owner и имя, которому присваивается ссылка на экземпляр класса – name.

Через параметр ```name```, в объекте дескриптора создается локальное свойство, которое является строкой и к нему в начале добавляется одно или два подчеркивания, в зависимости от режима доступа, который нужно предоставить. 

Далее при создании объекта класса, срабатывает инициализатор, где через дескрипторы, присваиваются локальные свойства. В момент присваивания срабатывает магический метод ```__set__()``` дескриптора.

Метод ```__set__()``` принимает аргументы: ```self``` – ссылка на экземпляр дескриптора, instance – ссылка на экземпляр класса (в котором объявлен дескриптор) и value – значение которое присваивается атрибуту экземпляра класса в инициализаторе.
Присваивание значения происходит используя функцию ```setattr(instance, self.name, value)```   
## ```__call__() | Functors```
**Файл: functor.py**

Магический метод ```__call__()``` запускается при *вызове класса и далее для создания экземпляра срабатывает определенный алгоритм:, максимально упрощенно вызываются методы ```__new__()``` и ```__init__()```.

Если в классе переопределить метод ```__call__()```, этот класс будет называться функтор / functor и к его объекту можно будет обращаться как к функции. 

Это может быть полезно, когда вызов определенного метода зависит от входных данных и эти вызовы должны происходить неявно.

Еще переопределением ```__call__()``` можно создать класс декоратор, приняв функцию, которую нужно дополнить, как свойство объекта. Имя класса-декоратора будет передано в синтаксический сахар – синтаксис декоратора. 
## ```__str__(), __repr__(), __len__, __abs__```
**Файл: about_str_len.py**

```__str__()``` — автоматически вызывается для отображения информации об объекте класса для пользователей. Например, для print(). Если переопределить можно изменить отображение информации.

```__repr__()``` — для отображения информации об объекте класса в режиме отладки. Вызывается если обратиться к объекту в консоли.

```
 class Cat:
	def __init__(self, name):
	self.name = name


def __repr__(self):
	return f'<instance_{self.name}>_{self.__class__}'


def __str__(self):
	return self.name


if __name__ == '__main__':
c = Cat('Alex')
print(c) # __str__() is calling.
```
```__len__()``` — позволяет применять функцию len() к экземпляру класса для возвращения длины какого-либо атрибута класса.

```__abs__()``` — позволяет применять функцию abs() к экземпляру класса. 
## ```__add__(), __sub__(), __mul__(), __truediv__()```
**Файл: sec_converter.py**

Если определить их в классе, то с объектами можно будет выполнять арифметические операции используя арифметические операторы.

* все эти методы вторым параметром принимают other — значение операнда. 
```
 def add(self, other)
	return self.attr + other
* при выполнении арифметических операций между экземпляром и числовым типом, эти методы предполагают, что экземпляр будет левым операндом. Если поставить экземпляр в качестве правого операнда, возникнет исключение. Этого можно избежать определив для каждого специальный одноименный метод-модификатор с приставкой r в начале. Например:
	def __radd__(self, other):
		return self + other
* в случае, когда используется оператор приращения (+=, -=, /= , ...) нужно определить модификацию метода с приставкой i, с единственным отличием от основного метода, что возвращает не новый объект, а ссылку на тот же, только в теле меняет локальный атрибут. Таким образом при использовании оператора приращения, избегается создание нового объекта. Например:
	def iadd(self, other):
		<def add algorithm>
		self.attr += other
		return self
```
## ```__eq__, __ne__, __lt__, __gt__ и другие```
**Файл: comparison.py**
```
__eq__()  для ==
__ne__() для !=
__lt__() для <
__gt__ () для >
__le__()  для <=
__ge__()  для >=
```

* по умолчанию если к объектам определенного класса применить оператор сравнения на равенство операндов ==, он сравнит адреса в памяти этих объектов — id. Если нужно сравнить какой-либо другой атрибут, то нужно определить это поведение в магическом методе ```__eq__()```. 
* если ```__ne__()``` не переопределен в классе, где определен ```__eq__()```, интерпретатор будет инвертировать метод сравнения:
	instance1 != instance2, он представит в виде not(instance1 == instance2). Это можно проверить в режиме отладки.
* если не определить один из методов проверки на больше или меньше ```(__lt__(), __gt__())``` и попытаться сравнить используя обратный оператор,интерпретатор, как в случае с проверкой на равенство, сравнит через уже определенный метод, заменив оператор на нужный. Аналогично и с <= >=.
Пример реализации:
```
@staticmethod
def __verify_data(other):
	if not isinstance(other, (Clock, int)):
		raise AttributeError('Сравнивать можно только int или объект Clock!')
	item = other if isinstance(other, int) else other.seconds
	return item


def __eq__(self, other):
	item = self.__verify_data(other)
	return self.seconds == item
```
## ```__getitem__(), __setitem__() и __delitem__()```
**Файл: collections.py**
```
__getitem__(self, item) — получения значения по ключу; 
__setitem__(self, key, value) — запись значения value по ключу key;
__delitem__(self, key) — удаление элемента по ключу.
```
Переопределив эти методы можно изменить поведение, чтобы к пользовательскому объекту можно было обращаться, изменять или удалять по индексу или ключу, как в определенной коллекции. 
## ```__iter__(), __next__()``
**Файл: iterable.py**
```
__iter__(self) — получение итератора для перебора объекта;
__next__(self) — переход к следующему значение и его считывание.
```
Определив эти методы можно пользовательский объект сделать итерируемым. 
# Наследование | Inheritance
**Файл: inheritance.py**

Механизм, при котором класс наследник определяется на основе класса родителя и перенимает все его свойства и методы называется наследованием.

Как известно каждый класс имеет собственное пространство имен. При наследовании дочерний класс получает доступ к пространству имен родителя — базового класса.

Общие атрибуты и методы дочерних классов можно определить в базовом классе и таким образом избежать повторения кода. 

Определение одноименного атрибута или метода базового класса в дочернем, называется переопределением атрибута или метода.
## Поиск атрибутов
При вызове определенного метода или при обращении к атрибуту через экземпляр дочернего класса, поиск метода и атрибута интерпретатор в первую очередь выполняет в дочернем классе и если его там нет, поиск переходит в базовый класс.  

Например, если в базовом классе определен конструктор ```__init__()```, а в дочернем его нет, интерпретатор при создании объекта дочернего класса, не найдя у него конструктор, воспользуется конструктором базового класса.

Если в дочернем классе переопределены атрибуты или методы базового класса, интерпретатор выберет их — то есть можно сказать, у переопределенных атрибутов и методов в дочернем классе выше приоритет исполнения.
## Пример для понимания
Есть базовый класс. В базовом классе определен некоторый метод. Есть дочерний класс и он наследуется от базового. Если через объект дочернего класса вызвать этот метод, интерпретатор не найдя его в пространстве имен дочернего класса, перейдет в базовый, найдет его там и вызовет с ссылкой на объект дочернего класса через self.

Важно понимать, что параметр self базового класса может ссылаться не только на свои экземпляры, но и на экземпляры дочерних классов. Это регулируется тем, через объект какого класса был вызван этот метод. 

Если нужно вызвать метод внутри какого-либо метода, нужно удостовериться что этот метод определен в этом классе или его родителях, а не в его дочерних классах.
## Наследование от встроенных классов | object
**Файл: about_object.py**

Начиная с третьей версии языка пользовательские классы неявно наследуются от встроенного базового класса ```object```. При определении нового класса не нужно вручную прописывать базовый класс object, как это было во второй версии языка, можно сказать, что наследование происходит автоматически.

В object уже определены большинство магических методов и им задано стандартное поведение. В пользовательских классах можно переопределять эти методы, тем самым меняя их поведение полностью или частично. 

Если создать два класса: первый неявно наследуется от object, второй наследуется от первого, то для второго класса наследника, базовым классом будет являться первый класс и неявного наследования от object уже не будет. Но второй класс будет иметь доступ к атрибутам и методам object. так как при наследовании дочерний класс перенимает все свойства и поведение класса родителя. А так как класс родитель неявно наследуется от object, у него есть доступ к атрибутам и методам object. Так вот этот доступ передается всем последующим наследникам.

Стоит учитывать момент, что если переопределить какой-либо магический метод в первом классе, дочерний класс наследует этот переопределенный метод, так как доступ к методам и атрибутам object происходит через первый класс.

Функция ```issubclass()``` проверяет, является переданный первым аргументом класс наследником второго.

Функция ```isinstance()``` проверяет, является ли переданный первым аргументом объект экземпляром какого-ли переданного вторым аргументом класса. 

Все встроенные типы в Python являются классами. Так что существует возможность определить пользовательский класс на базе встроенного и изменить его поведение. 
## Функция super() | Делегирование
**Файл: about_super.py**

* Делеги́рование полномо́чий — это процесс передачи части функций руководителя другим управляющим или сотрудникам для достижения конкретных целей организации. 
* ```super()``` возвращает ссылку на объект-посредник, через который происходит вызов методов базового класса. Можно сказать в результате работы функции super() содержится ссылка на базовый класс, через которую и вызываются методы. Это лучше, чем явно указывать название класса, так как если название класса поменяется, нужно будет менять и это обращение.
* вызов через ```super()``` методов базового класса называется делегированием.

### Важно понимать
Если в дочернем классе определить новый уникальный метод или атрибут это является расширением (extending) базового класса. К методам и свойствам базового класса, к которым появляется доступ при наследовании, добавляется новый атрибут или метод в дочернем классе.

Если в базовом классе уже определен некоторый метод (или атрибут) и в дочернем определить метод с аналогичным названием это является переопределением (overriding) базового метода. При переопределении можно изменить поведение метода полностью или частично.
### Пример для понимания super()
Механизм наследования применяется во избежание повторения кода. 
Если у классов есть одинаковые атрибуты и методы, их нужно вынести в базовый класс.
Если функционал какого-то метода в базовом классе не решает поставленную задачу в дочернем, его можно переопределить полностью.

Но бывают случаи, когда какой-то метод нужно переопределить частично, оставить базовый функционал как есть и добавить новый. Эту проблему решает функция super().

Для этого нужно переопределить метод базового класса в дочернем, затем в теле метода через функцию super() вызвать базовый метод, передать необходимые аргументы и и только после этого прописать новый функционал. 

Можно сказать, что часть работы, которую может выполнить, через super() делает базовый метод, а работу с которой не может справиться выполняет переопределенный метод в дочернем классе.

## Пример инкапсуляция при наследовании
**Файл: inherit_ex.py***

Как известно при создании приватных атрибутов класса к ним добавляется префикс с именем класса. Если класс наследник использует конструктор родителя, то и названия атрибутов будут иметь префикс с именем родителя. 
Приватные атрибуту жестко привязываются к классу, где определяются. Из дочернего класса к ним нельзя получить доступ. 

Чтобы иметь доступ к атрибутам созданным в базовом классе из дочерних классов, нужно делать их защищенными, а не приватными. Это относится и к атрибутам класса и к методам. 
## Множественное наследование
**Файл: mixins.py**

В питоне допускается множественное наследование, когда один дочерний класс наследуется от нескольких базовых. 
* один из примеров использования множественного наследования это классы ```Mixin```.

```Mixin``` — независимые базовые классы, в которых определены дополнительные методы или атрибуты, не предназначенные для самостоятельного использования. Примеси не должны иметь экземпляров и наследовать свойства и поведения других классов. Единственная их цель предоставить дочерним классам дополнительный функционал, которого нет в основном базовом классе. 
### Важно понимать
При использовании множественного наследования нужно убедиться, что конструкторы дополнительных / вспомогательных базовых классов, принимают только один аргумент ```self```, без дополнительных параметров. 
Иначе это может привести к сложностям и путанице с параметрами, которые они принимают. Так как имеет значение в каком порядке прописаны базовые классы при множественном наследовании. И параметры переданные в один конструктор могут отличаться от параметров передаваемых в другой.

Если в базовых классах определены методы с одинаковыми названиями, то естественно будет вызываться метод класса стоящего первым в иерархии наследования. 

Если требуется вызвать непосредственно метод миксина (базового класса ниже в иерархии), то нужно явно указать имя класса и вызвать метод, а качестве параметра передав объект, для кого он вызывается:
```
>> Mixin.foo(object)
```
#### Поиск атрибутов
При множественном наследовании поиск атрибутов включает все базовые классы в том порядке, как они прописаны при наследовании, и поиск замыкается классом ```object```.

Пример для понимания:
```
class Base:
	def foo1(self):
		…
class Mixin:
	def foo2(self):
		…
class Child(Base, Mixin):
	def bar(self):
		…
При такой иерархии наследования, поиск атрибутов будет осуществляться в таком порядке:

Child –> Base –>  Mixin –>  object
```
##### ```__mro__```
MRO — Method resolution Ordering — порядок исполнения методов.

Магический атрибут, который содержит ссылку на упорядоченную коллекцию, с названиями классов, которые обходятся при поиске атрибутов.

# Полиморфизм и абстрактные методы
**Файл: polimorfizm.py**

* Абстрактные методы — методы, которые не имеют собственной реализации и их нужно переопределить в дочерних классах. 
* К сожалению, в питоне нет реализации абстрактных методов, в этом случае выполняется лишь имитация их поведения,  путем генерации исключения NotImplementedError.  

Простыми словами, полиморфизм это возможность работы с совершенно разными объектами Python единым образом (через единый интерфейс).
## Пример для понимания
Допустим, есть несколько классов и у каждого класса есть метод расчета периметра. Как сделать так, например чтобы при переборе множества объектов этих классов, у них вызывался их метод?

Для этого нужно воспользоваться механизмом полиморфизма. Создать класс, где определен метод расчета периметра, без реализации — который будет вызывать лишь исключение NotImplementedError.

Затем создать необходимые классы, которые наследуются от базового, где определен этот метод. В этих классах, нужно переопределить базовый метод расчета периметра, с собственной логикой для каждого отдельного класса. 

Теперь для любого объекта этих классов можно вызвать метод расчета периметра, который переопределен в каждом классе с собственной логикой. А в случае, если в каком-то классе, этот метод забыли переопределить, возникнет исключение. 

Так в питоне реализуется механизм параметрического полиморфизма, где метод базового класса, имитируя поведение абстрактного метода, представляет единый интерфейс, для объектов дочерних. 

# Разное
## Коллекция __slots__
**Файл: about_slots.py**
	
Данная коллекция накладывает запрет на создание локальных атрибутов, название которых не входит в нее и таким образом уменьшает размер занимаемой памяти объектом и немного ускоряет работу с этими свойствами.
Одной из причин ускорения и уменьшения затрат памяти является отсутствие коллекции ```__dict__```.

```__slots__ = (‘x’, ‘y’)``` — данная запись означает, что локальные атрибуты объектов этого класса могут иметь названия перечисленные в кортеже.

При наследовании дочерние классы не наследуют ```__slots__```, но перечисленные в ней свойства в базовом классе, не будут созданы в дочернем. 

# Обработка исключений в ООП Python
**Файл: about_exceptions.py**

Встроенные исключения можно разделить на две группы:
* исключения в момент исполнения
* исключения при компиляции / сборке / до исполнения

Обработка исключений в питоне применяется для исключений в момент исполнения программы, интерпретатором — строчка за строчкой. 

У исключений в питоне есть целая иерархия во главе которой стоит класc BaseException. От него наследуются дочерние классы исключений: Exception, SystemExit, GeneratorExit и KeyboardInterrupt. Основным среди перечисленных классов исключений является Exception. От него наследуются все исключения, которые не связаны с системой. И на его основе определяются все пользовательские классы исключений.
## Подробная иерархия наследования
```
BaseException
 ├── BaseExceptionGroup
 ├── GeneratorExit
 ├── KeyboardInterrupt
 ├── SystemExit
 └── Exception
      ├── ArithmeticError
      │    ├── FloatingPointError
      │    ├── OverflowError
      │    └── ZeroDivisionError
      ├── AssertionError
      ├── AttributeError
      ├── BufferError
      ├── EOFError
      ├── ExceptionGroup [BaseExceptionGroup]
      ├── ImportError
      │    └── ModuleNotFoundError
      ├── LookupError
      │    ├── IndexError
      │    └── KeyError
      ├── MemoryError
      ├── NameError
      │    └── UnboundLocalError
      ├── OSError
      │    ├── BlockingIOError
      │    ├── ChildProcessError
      │    ├── ConnectionError
      │    │    ├── BrokenPipeError
      │    │    ├── ConnectionAbortedError
      │    │    ├── ConnectionRefusedError
      │    │    └── ConnectionResetError
      │    ├── FileExistsError
      │    ├── FileNotFoundError
      │    ├── InterruptedError
      │    ├── IsADirectoryError
      │    ├── NotADirectoryError
      │    ├── PermissionError
      │    ├── ProcessLookupError
      │    └── TimeoutError
      ├── ReferenceError
      ├── RuntimeError
      │    ├── NotImplementedError
      │    └── RecursionError
      ├── StopAsyncIteration
      ├── StopIteration
      ├── SyntaxError
      │    └── IndentationError
      │         └── TabError
      ├── SystemError
      ├── TypeError
      ├── ValueError
      │    └── UnicodeError
      │         ├── UnicodeDecodeError
      │         ├── UnicodeEncodeError
      │         └── UnicodeTranslateError
      └── Warning
           ├── BytesWarning
           ├── DeprecationWarning
           ├── EncodingWarning
           ├── FutureWarning
           ├── ImportWarning
           ├── PendingDeprecationWarning
           ├── ResourceWarning
           ├── RuntimeWarning
           ├── SyntaxWarning
           ├── UnicodeWarning
           └── UserWarning
```
## Пользовательские классы исключений
При определении пользовательских классов исключений, принято наследоваться от класса ```Exception```, который уже содержит большинство необходимых встроенных классов исключений.
```
class CustomException(Exception):
	“““Exception docstring”””
	<exception logic>

* Можно строить пользовательскую иерархию исключений, создав базовый класс исключения и наследоваться от него.
```
# Менеджер контекста в ООП Python
**Файл: context_manager.py**

Менеджер контекста — объект, который получает уведомление при начале определенного контекста (блок кода) и об его окончании, при этом реализуя определенную логику поведения.
```
with <context_manager_object> as <name>:
	<code>
```

В классе менеджера контекста реализовано два метода:
```__enter__()``` — срабатывает в момент создания объекта менеджера контекста.
```__exit__()``` — срабатывает в момент завершения работы объекта менеджера контекста или при возникновении исключения.

## Пример для понимания
Если в классе реализованы  два магических метода ```__enter__() и __exit__()```, он становится менеджером контекста и для создания объекта потребуется воспользоваться оператором with.

В методе ```__enter__()``` реализуется логика работы с входными данными и ссылка на результат работы возвращается в имя, определенное в конструкции ```with```. Например, открытие файлового потока с помощью ```open()```.

В методе ```__exit__()``` реализуется поведение при завершении работы менеджера. Набор инструкций, в случае отсутствия или наличия ошибок. Если исключения отсутствуют, параметры метода принимают None. Если в ходе выполнения кода внутри блока менеджера возникли исключения, информация о них будет передана в соответствующие параметры метода для дальнейшей обработки.
Например, в этом методе происходит закрытие файлового потока. 

Если метод возвращает ```False```, возникшие в ходе работы исключения не будут обработаны и программа остановится. 
Если ```True```, то исключения будут обрабатываться и программа завершится успешно,

Например, в указанном выше файле определен класс менеджера контекста, который принимает список и возвращает его копию. Далее программа работает с копией и если не возникло ошибок, менеджер заменяет оригинал элементами из этой копиеи. Если возникло исключение, работа прекращается, а оригинальный файл остается без изменения. 
# Вложенные классы
Вложенный класс реализует независимое от внешнего класса пространство имен, где можно определить дополнительные параметры и логику, что в некоторых случаях может упростить реализацию того или иного функционала, но не более. 

Обращаясь через внешний класс можно создавать объекты вложенного класса. Но плохой практикой считается обращаться из вложенного класса к атрибутам внешнего. Это можно сделать в конструкторе внутреннего, но не рекомендуется. 
# Метаклассы
```
«Метаклассы — это глубокая магия, о которой 99% пользователей даже не нужно задумываться. Если вы думаете нужно ли вам их использовать — вам не нужно. Люди, которым они нужны, точно знают, зачем они им и не нуждаются в объяснениях, почему…» © Тим Питерс
```
В питоне всё является объектом определенного класса. Классы также являются объектами, которые позволяют создавать другие объекты. Сущность, которая создает обычные классы называется метакласс — некоторая отправная точка в ООП питона.

Метакласс представлен объектом ```type()``` — который может принимать 1 или 3 параметра.

Если в него передать объект или ссылку на объект, он вернет название класса переданного объекта.
```
>> def foo(self): print(self.MAX_COORD)
>>> Point = type('Point', (), {'MAX_COORD': 100, 'foo': foo})
>>> pt = Point()
>>> pt.foo()
100
>>> type(pt)
<class '__main__.Point'>
```
Функция может принимать 3 аргумента — имя класса, коллекцию родительских классов и словарь с атрибутами и методами.
В этом случае объект type() начинает работать по-другому:
динамически создает новый класс (тип данных). 
Например, все стандартные (встроенные в питон) типы объектов (типы данных) созданы при помощи объекта  type(). 
```
>> type(int)
>> <class ‘type’>
```
# Пользовательские метаклассы
**Файл: user_metaclass.py**

В питоне можно создавать пользовательские метаклассы, которые неявно или явно будут созданы объектом type().
```
Метакласс в виде функции:
def create_user_metaclass(class_name, base, attrs):
	<some_logic>
	return type(class_name, base, attrs)

class User(metaclass=create_user_metaclass):
	<extra_logic>
Пользовательский метакласс:
	class Meta(type):
		def __new__(cls, name, base, attrs):
			<logic>
			return type.__new__(cls, name, base, attrs)

	class User(metaclass=Meta):
		<extra_logic>
```
# Немного о Data Classes
**Файл: about_dataclasses.py**

Встроенный модуль dataclasses содержит инструменты, помогающие упростить создание классов, которые хранят данные. Вместо того чтобы создавать инициализатор, можно воспользоваться декоратором @dataclass этого модуля и определить класс с более простым синтаксисом:
```
@dataclass	
class Thing:
“““все параметры со значениями по умолчанию передаются в последнюю очередь...”””
	attr_1: <type> = <optional - default value>
	attr_2: <type>
	mutable_attr: field(default_factory=list) # — создает независимый изменяемый объект у каждого отдельного экземпляра.
	…
	attr_n: <type>
```
Хоть внутри класса явно не прописан инициализатор, при создании экземпляра класса, будут созданы указанные локальные атрибуты. 

В классе созданном при помощи декоратора @dataclass магический метод ```__eq__()``` переопределен таким образом, что он сравнивает не адреса в памяти объектов, как это работает у классов созданных обычных образом, а сравнивает локальные атрибуты. И если локальные атрибуты двух разных объектов равны, для него равны и объекты. 
