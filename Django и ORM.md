Django и ORM
========================
# Django

Найти ответы на эти вопросы
 ORM: lazy_query(select_related и prefetch_related),  values('id'), SubQuery, alias, annotate, Q, F, OuterRef, Middleware, Manager, как работает сервер на Джанго, работа с несколькими БД

## Возможности Django
- ORM, API доступа к БД с поддержкой транзакций
- встроенный интерфейс администратора, с уже имеющимися переводами на многие языки
- диспетчер URL на основе регулярных выражений
- расширяемая система шаблонов с тегами и наследованием
- система кеширования
- интернационализация
- подключаемая архитектура приложений, которые можно устанавливать на любые Django-сайты
- «generic views» — шаблоны функций контроллеров
- авторизация и аутентификация, подключение внешних модулей аутентификации: LDAP, OpenID и прочие.
- система фильтров («middleware») для построения дополнительных обработчиков запросов, как например включённые в дистрибутив фильтры для кеширования, сжатия, нормализации URL и поддержки анонимных сессий
- библиотека для работы с формами (наследование, построение форм по существующей модели БД)
- встроенная автоматическая документация по тегам шаблонов и моделям данных, доступная через административное приложение

---
## Django ORM

Django ORM — Object-Relational Mapping, «объектно-реляционное отображение». 
Object — объекты, которые созданы на основе классов, 
relational — реляционные базы данных, а mapping — связь между системой объектов и базами данных.

---
## 


---
## Что такое Middleware, для чего, как реализуется

Middleware – особый объект, который обычно изменяет входящий запрос или исходящий ответ. Например, добавляет заголовки, делает предварительные проверки. Middleware нужен, когда требуется подвергнуть обработке все запросы приложения.

На уровне языка это объект с методами `process_request` и `process_response`. Методы должны вернуть принятый объект (запрос или ответ) для дальнейшей обработки или выкинуть исключение, если что-то не в порядке. В этом случает дальнейшая обработка прекращается.

Чтобы включить Middleware, достаточно добавить путь к нему в список `MIDDLEWARE`.

## Назовите основные мидлвари. Зачем они нужны

- `SessionMiddleware` – поддержка сессий. Добавляет в запрос объект `session`
- `CsrfViewMiddleware` – проверяет, что POST-запросы отправлены с текущего домена
- `AuthenticationMiddleware` – авторизует пользователя. Добавляет в запрос поле `user`
- `MessageMiddleware` – передает пользователю короткие сообщения

## Опишите алгоритм работы CSRF middleware

На каждый запрос система генерирует уникальный токен и выставляет его в куках. В каждой форме размещается скрытое поле `csrf-token` с этим же токеном. При отправке формы методом `POST` Джанго проверяет, что поле формы и значение в куках совпадают. Если нет, это значит, что запрос подделан или отправлен с другого домена.

Чтобы освободить какую-то вьюху от проверки (если это API, например), достаточно обернуть ее декоратором `csrf_except`.

Промежуточный слой CSRF и шаблонный тег предоставляют легкую-в-использовании защиту против Межсайтовой подделки запроса. Этот тип атак случается, когда злонамеренный Web сайт содержит ссылку, кнопку формы или некоторый javascript, который предназначен для выполнения некоторых действий на вашем Web сайте, используя учетные данные авторизованного пользователя, который посещал злонамеренный сайт в своем браузере. Сюда также входит связанный тип атак, ‘login CSRF’, где атакуемый сайт обманывает браузер пользователя, авторизируясь на сайте с чужими учетными данными.

Первая защита против CSRF атак - это гарантирование того, что GET запросы (и другие ‘безопасные’ методы, определенные в 9.1.1 Safe Methods, HTTP 1.1, [RFC 2616#section-9.1.1](https://tools.ietf.org/html/rfc2616.html#section-9.1.1)) свободны от побочных эффектов. Запросы через ‘небезопасные’ методы, такие как POST, PUT и DELETE могут быть защищены при помощи шагов, описанных ниже.

*Как это работает:*

CSRF базируется на следующих вещах:

1. CSRF кука, которая устанавливается как случайное число (сессия независимого случайного слова, как это еще иногда называют), к которой другие сайты не будут иметь доступа. Эта кука устанавливается при помощи CsrfViewMiddleware. Она должно быть постоянной, но так как нет способа установить куки, у которых никогда не истекает время жизни, то она отправляется с каждым ответом, который вызывал django.middleware.csrf.get_token() (функция использовалась внутри для получения CSRF токена).

2. Все POST формы содержат скрытое поле ‘csrfmiddlewaretoken’. Значение поля равно CSRF куке. Эта часть выполняет шаблонным тегом.
3. Все HTTP запросы, которые не GET, HEAD, OPTIONS или TRACE, должны содержать CSRF куку, и поле ‘csrfmiddlewaretoken’ с правильным значением. Иначе пользователь получит 403 ошибку. Эта проверка выполняется в CsrfViewMiddleware.
4. В дополнение для HTTPS запросов в CsrfViewMiddleware проверяется “referer”(источник запроса). Это необходимо для предотвращения MITM-атаки(Man-In-The-Middle), которая возможна при использовании HTTPS и токена не привязанного к сессии, т.к. клиенты принимают(к сожалению) HTTP заголовок ‘Set-Cookie’, несмотря на то, что коммуникация с сервером происходит через HTTPS. (Такая проверка не выполняется для HTTP запросов т.к. “Referer” заголовок легко подменить при использовании HTTP.) Если указана настройка CSRF_COOKIE_DOMAIN, значение “referer” будет сравниваться с этим значением. Значение поддерживает под-домены. Например, CSRF_COOKIE_DOMAIN = '.example.com' позволить отправлять POST запросы с www.example.com и api.example.com. Если настройка не указана, “referer” должен быть равен HTTP заголовку Host. Чтобы расширить список доступных доменов, кроме текущего хоста и домена кук, используйте CSRF_TRUSTED_ORIGINS.

Такой подход гарантирует, что только формы, отправленные с доверенных доменов, могут передавать POST данные.

GET игнорируются сознательно (и все другие запросы, которые считаются “безопасными” в соответствии с RFC 2616). Эти запросы никогда не должны выполнять каких-либо потенциально опасные действия, и CSRF атаки через GET запрос должен быть безвредным. RFC 2616 определяет POST, PUT и DELETE как “небезопасные”.

## Что такое сигналы? Зачем нужны? Назовите основные

Сигналы – это события в экосистеме Джанго. С помощью сигналов подсистемы оповещают приложение о том, что случилось. Чтобы читать сигналы, программист регистрирет обработчики сигналов. Сигналы распространяются синхронно. Это значит, подписав на один сигнал сотню обработчиков, мы увеличим время, необходимое на отдачу ответа.

Основные сигналы это начало запроса и его окончание, перед сохранением модели и после, обращение к базе данных.

**Важно:** сигналы моделей работают поштучно, то есть для одной модели. При пакетной обработке, например, `queryset.all().delete()` или `queryset.all().update({'foo'=42})`, события об удалении или изменения не будут вызваны.

## Как реализуется связь m2m на уровне базы данных

Если есть модели A и B со связью многие ко многим, то создается таблица-мост с именем `a_to_b`, которая хранит ключ на A, ключ на B и дополнительные сведения, например, время, когда была создана связь. Эта таблица сцепляется с A и B оператором `JOIN`.

## Чем лучше отправлять форму — GET или POST

Форму можно отправлять обоими способами. В первом случае переменные прикрепляются к строке запроса после вопросительного знака. Во втором – передаются в теле запроса.

Техническое ограничение метода GET в том, что им нельзя передать файл, в отличие от POST.

Форму желательно передавать методом POST по следующим причинам:

- GET-запросы могут быть кешированы, особенно в браузерах семейства IE
- GET-запросы оседают в логах провайдера, сервера, истории браузера. Пароль и логин в таком случае может засветиться во многих местах
- некоторые вирусы отслеживают содержимое адресной строки и пересылают третьим лицам.

## Как работает Serializer в Django REST Framework

Serializer преобразует информацию, хранящуюся в базе данных и определенную с помощью моделей Django, в формат, который легко и эффективно передается через API.

Модели Django интуитивно представляют данные, хранящиеся в базе, но API должен передавать информацию в менее сложной структуре. Хотя данные будут представлены как экземпляры классов Model, их необходимо перевести в формат JSON для передачи через API.

Сериализатор DRF производит это преобразование. Когда пользователь передает информацию (например, создание нового экземпляра) через API, сериализатор берет данные, проверяет их и преобразует в нечто, что Django может сложить в экземпляр модели. Аналогичным образом, когда пользователь обращается к информации через API, соответствующие экземпляры передаются в сериализатор, который преобразовывает их в формат, который может быть легко передан пользователю как JSON.

Наиболее распространенной формой, которую принимает сериализатор DRF, является тот, который привязан непосредственно к модели Django:

```python
class ThingSerializer(serializers.ModelSerializer):
  class Meta:
    model = Thing
    fields = (‘name’, )
```

Настройки fields позволяют точно указать, какие поля доступны этому сериализатору. В качестве альтернативы, может быть установлен exclude вместо fields, которое будет включать все поля модели, кроме тех, которые указаны в exclude.

Сериализаторы — это невероятно гибкий и мощный компонент DRF. Хотя подключение сериализатора к модели является наиболее распространенным, сериализаторы могут использоваться для создания любой структуры данных Python через API в соответствии с определенными параметрами.

## Что такое Meta в классах Django и для чего нужен

Django во многом работает через метаклассы.

Если коротко, то метаклассы - это классы, которые конструируют другие классы. Объявляются они через атрибут класса `__metaclass__` (в джанге через слой совместимости с python 3 через модуль six до версии 2).

Поэтому когда Django конструирует ваш класс, она делает это с помощью своего метакласса. Чтобы при конструировании ей знать какие-то параметры вашего класса, ну, например модель или поля в вашем случае, она ищет в вашем классе класс с названием Meta.

Вообще вся эта магия с метаклассами очень важна в джанге и поэтому лучше саму логику становления класса не переопределять.

Если взять за пример Serializer, то можно посмотреть на код джанги:

```python
@six.add_metaclass(SerializerMetaclass)
class Serializer(BaseSerializer):
  ...
```

SerializerMetaclass - это тот самый метакласс, который конструирует класс ModelForm.

## За что отвечает Meta в сериализаторе

В классе Meta сериализатора можно задать модель по которой будет создан сериализатор, поля, которые будут включены (или exclude для исключения), `list_serializer_class`, например для того чтобы задать специфическую валидацию списков и тд.

## Какая разница в быстродействии между django и Flask (и почему)

Насчет быстродействия затрудняюсь ответить, потому что это довольно каверзный вопрос, тестов лично я не проводил. Но, что касается отличий этих двух фреймворков:

- Flask предоставляет простоту, гибкость и аккуратность в работе, позволяя пользователю самому выбирать, как реализовать те или иные вещи.
- Django предоставляет пакет «все включено»: у вас есть панель админа, интерфейсы баз данных, ORM, и структура каталогов для ваших приложений и проектов.

Под каждую задачу нужно брать свой инструмент, Django хорошо подойдет для новостных сайтов, блогов и тд, благодаря тому что у него уже из коробки есть многое (в том числе админка), да и создавался он именно под такой тип сайтов. Flask же из коробки напротив, практически ничего не имеет и лучше подойдет для каких-либо микросервисов или приложений для которых стек технологий с которыми поставляется Django не подходит.

## Как в django работает система аутентификации

Django поставляется с системой аутентификации пользователей. Она обеспечивает пользовательские аккаунты, группы, права и сессии на основе куки.

Система аутентификации Django отвечает за оба аспекта: аутентификацию и авторизацию. Если коротко, то аутентификация проверяет пользователя, а авторизация определяет, что аутентифицированный пользователь может делать. Далее термин “аутентификация” будет использоваться для обозначения обоих аспектов ([User authentication in Django](https://docs.djangoproject.com/en/2.2/topics/auth/)).

Система аутентификации состоит из:

- Пользователей
- Прав: Бинарные (да/нет) флаги, определяющие наличие у пользователя права выполнять определённые действия.
- Групп: Общий способ назначения меток и прав на множество пользователей.
- Настраиваемой системы хеширования паролей
- Инструментов для форм и представлений для аутентификации пользователей или для ограничения доступа к контенту
- Системы плагинов

Аутентификационная система Django старается быть очень простой и не предоставляет некоторые фичи, распространённые в других системах веб аутентификации. Такие фичи реализованы в сторонних пакетах:

- Проверка сложности пароля
- Ограничение попыток входа
- Аутентификация через сторонние сервисы (OAuth, например)
- 
---
## select_related и prefetch_related

В Django select_related и prefetch_related предназначены для остановки потока запросов к базе данных, вызванных доступом к связанным объектам.

### select_related

Django предлагает QuerySet-метод под названием select_related(), который позволяет извлекать связанные объекты для взаимосвязей один-ко-многим. Это транслируется в один более сложный набор запросов, но зато позволяет избегать дополнительных запросов при доступе к связанным объектам. Метод select_related предназначен для полей ForeignKey и OneToOne. Он работает, выполняя SQL-инструкцию JOIN и включая поля связанного объекта в инструкцию SELECT.

Мы используем select_related, когда объект, который вы собираетесь выбрать, является одним объектом, что означает пересылку ForeignKey, OneToOne и обратный OneToOne.

select_related работает путем создания соединения SQL и включения полей связанного объекта в оператор SELECT. По этой причине select_related получает связанные объекты в том же запросе к базе данных.
```py
queryset = Book.objects.all()
for book in queryset:
        books.append({'id': book.id, 'name': book.name)

Number of SQL Queries : 101        
```
Один запрос для заполнения всех книг и, выполняя итерацию каждый раз, мы получаем доступ к издателю, который выполняет другой отдельный запрос.

Давайте изменим запрос с помощью select_related следующим образом и посмотрим, что произойдет.
```py
queryset = Book.objects.select_related('publisher').all()
for book in queryset:
        books.append({'id': book.id, 'name': book.name)

Number of SQL Queries : 1
        
```
### prefetch_related

Метод select_related() поможет повышать производительность при извлечении связанных объектов во взаимосвязях один-ко-многим. Однако он не работает для взаимосвязей многие-ко-многим или многие-к-одному (поля ManyToMany или обратного внешнего ключа ForeignKey). Django предлагает другой QuerySet-метод под названием prefetch_related, который в дополнение к взаимосвязям, поддерживаемым методом select_related(), успешно работает для взаимосвязей многие-ко-многим и многие-к-одному. Метод prefetch_related() выполняет отдельный поиск по каждой взаимосвязи и соединяет результаты с помощью Python. Этот метод также поддерживает упреждающую выборку полей GenericRelation и GenericForeignKey.


Мы используем prefetch_related, когда собираемся получить набор вещей.

Это означает обработку ManyToMany и обратных ManyToMany, ForeignKey. prefetch_related выполняет отдельный поиск для каждой связи и выполняет «объединение» в Python.

Он отличается от select_related. prefetch_related выполнял JOIN с использованием Python, а не в базе данных.
```py
queryset = Store.objects.all()
for store in queryset:
        books = [book.name for book in store.books.all()]
        stores.append({'id': store.id, 'name': store.name, 'books': books})

Number of Queries : 11
```
У нас в базе 10 магазинов и в каждом магазине по 10 книг. Здесь происходит один запрос для выборки всех хранилищ, и во время итерации по каждому хранилищу выполняется другой запрос, когда мы получаем доступ к полю books ManyToMany.

Давайте уменьшим количество запросов с помощью prefetch_related.

```py
queryset = Store.objects.prefetch_related('books')
    for store in queryset:
        books = [book.name for book in store.books.all()]
        stores.append({'id': store.id, 'name': store.name, 'books': books})

Number of Queries : 2
```
Здесь производительность запросов улучшилась, с 11 до 2 запросов. Я хочу, чтобы вы поняли, что здесь делает prefetch_related.

Возьмем еще один пример для prefetch_related.

В коде команды управления я произвольно устанавливаю цену книги от 50 до 300. Теперь мы найдем дорогие книги (цена от 250 до 300) в каждом магазине.

```py
queryset = Store.objects.prefetch_related('books')
    for store in queryset:
        books = [book.name for book in store.books.filter(price__range=(250, 300))]
        stores.append({'id': store.id, 'name': store.name, 'books': books})

Number of Queries : 12
```
Несмотря на то, что мы используем prefetch_related, наши запросы скорее увеличились, чем уменьшились. Но почему?

Используя предварительную выборку, мы говорим Django предоставить все результаты для JOIN, но когда мы используем фильтр (price__range = (250, 300)), мы меняем основной запрос, и тогда Django не присоединяется к правильным результатам для нас.

По этой причине у нас есть 12 запросов, 11 запросов, повторяющихся по хранилищам, и один запрос для получения всех результатов в режиме предварительной выборки.

Решим проблему с Prefetch.
```py
queryset = Store.objects.prefetch_related(
        Prefetch('books', queryset=Book.objects.filter(price__range=(250, 300))))
for store in queryset:
    books = [book.name for book in store.books.all()]
    stores.append({'id': store.id, 'name': store.name, 'books': books})

Number of Queries : 2
```

select_releted - [select_related и prefetch_related в Django](https://django.fun/ru/articles/tutorials/select_related-i-prefetch_related-v-django/)

[Django and the N+1 Queries Problem | Scout APM Blog](https://scoutapm.com/blog/django-and-the-n1-queries-problem)

---


Разобралась со своей историей с токенами, вдруг кому пригодится: для создания юзера у меня был обычный modelserializer, в нем пользователь создается с обычным паролем, а джосер ожидает хэшированный пароль. Для этого нужно использовать from djoser.serializers import UserCreateSerializer. Тогда пользователь создается с хэшированным паролем, который распознает джосер и токен выдается корректно.

---
Вакансия на Django Middle 200-250k. Вопросы:
1) Что такое HTTP/HTTPS?
2) Из чего состоит запрос? Методы HTTP?
3) Что делает TRACE и CONNECT HTTP?
4) Как работает SSL?
5) RESTful и REST
6) Шифрует HTTPS GET запрос(URL)?
7) Куки
8) Где будет быстрее итерация по: list, str, dict, tuple? и почему?
9) Итератор vs генератор
10) Можно ли обращаться по индексу к генератору?
11) GIL в Python
12) Потоки vs процессы
13) Синхронизация потоков
14) Асинхронность. Короутины
15) MRO и решение кофликтов наследования в python
16) Duck typing
17) Метаклассы в Django
18) Профилирование кода. (Django debug tools)
19) Уникальные поля у PG
20) Индексы и их типы в PG
21) Транзакции в PG и уровни изоляции
22) Сигналы в Django
23) Сессии
24) Оптимизация запросов в БД Django
25) Anotate & Agregate ORM DJANGO
26) ValuesList
27) Как получать и обрабатывать данные из БД порциями (задача, есть 20кк записей, их надо обновлять каждые 2 часа, как сделать?)