Django и ORM
========================
# Django


## Возможности Django
- ORM, API доступа к БД с поддержкой транзакций
- встроенный интерфейс администратора, с уже имеющимися переводами на многие языки
- диспетчер URL на основе регулярных выражений
- расширяемая система шаблонов с тегами и наследованием
- система кеширования
- интернационализация
- подключаемая архитектура приложений, которые можно устанавливать на любые Django-сайты
- «generic views» — шаблоны функций контроллеров
- авторизация и аутентификация, подключение внешних модулей аутентификации: LDAP, OpenID и прочие.
- система фильтров («middleware») для построения дополнительных обработчиков запросов, как например включённые в дистрибутив фильтры для кеширования, сжатия, нормализации URL и поддержки анонимных сессий
- библиотека для работы с формами (наследование, построение форм по существующей модели БД)
- встроенная автоматическая документация по тегам шаблонов и моделям данных, доступная через административное приложение

---
## Django ORM

Django ORM — Object-Relational Mapping, «объектно-реляционное отображение». 
Object — объекты, которые созданы на основе классов, 
relational — реляционные базы данных, а mapping — связь между системой объектов и базами данных.

---
## 


---
## Что такое Middleware, для чего, как реализуется

Middleware – особый объект, который обычно изменяет входящий запрос или исходящий ответ. Например, добавляет заголовки, делает предварительные проверки. Middleware нужен, когда требуется подвергнуть обработке все запросы приложения.

На уровне языка это объект с методами `process_request` и `process_response`. Методы должны вернуть принятый объект (запрос или ответ) для дальнейшей обработки или выкинуть исключение, если что-то не в порядке. В этом случает дальнейшая обработка прекращается.

Чтобы включить Middleware, достаточно добавить путь к нему в список `MIDDLEWARE`.

## Назовите основные мидлвари. Зачем они нужны

- `SessionMiddleware` – поддержка сессий. Добавляет в запрос объект `session`
- `CsrfViewMiddleware` – проверяет, что POST-запросы отправлены с текущего домена
- `AuthenticationMiddleware` – авторизует пользователя. Добавляет в запрос поле `user`
- `MessageMiddleware` – передает пользователю короткие сообщения

## Опишите алгоритм работы CSRF middleware

На каждый запрос система генерирует уникальный токен и выставляет его в куках. В каждой форме размещается скрытое поле `csrf-token` с этим же токеном. При отправке формы методом `POST` Джанго проверяет, что поле формы и значение в куках совпадают. Если нет, это значит, что запрос подделан или отправлен с другого домена.

Чтобы освободить какую-то вьюху от проверки (если это API, например), достаточно обернуть ее декоратором `csrf_except`.

Промежуточный слой CSRF и шаблонный тег предоставляют легкую-в-использовании защиту против Межсайтовой подделки запроса. Этот тип атак случается, когда злонамеренный Web сайт содержит ссылку, кнопку формы или некоторый javascript, который предназначен для выполнения некоторых действий на вашем Web сайте, используя учетные данные авторизованного пользователя, который посещал злонамеренный сайт в своем браузере. Сюда также входит связанный тип атак, ‘login CSRF’, где атакуемый сайт обманывает браузер пользователя, авторизируясь на сайте с чужими учетными данными.

Первая защита против CSRF атак - это гарантирование того, что GET запросы (и другие ‘безопасные’ методы, определенные в 9.1.1 Safe Methods, HTTP 1.1, [RFC 2616#section-9.1.1](https://tools.ietf.org/html/rfc2616.html#section-9.1.1)) свободны от побочных эффектов. Запросы через ‘небезопасные’ методы, такие как POST, PUT и DELETE могут быть защищены при помощи шагов, описанных ниже.

*Как это работает:*

CSRF базируется на следующих вещах:

1. CSRF кука, которая устанавливается как случайное число (сессия независимого случайного слова, как это еще иногда называют), к которой другие сайты не будут иметь доступа. Эта кука устанавливается при помощи CsrfViewMiddleware. Она должно быть постоянной, но так как нет способа установить куки, у которых никогда не истекает время жизни, то она отправляется с каждым ответом, который вызывал django.middleware.csrf.get_token() (функция использовалась внутри для получения CSRF токена).

2. Все POST формы содержат скрытое поле ‘csrfmiddlewaretoken’. Значение поля равно CSRF куке. Эта часть выполняет шаблонным тегом.
3. Все HTTP запросы, которые не GET, HEAD, OPTIONS или TRACE, должны содержать CSRF куку, и поле ‘csrfmiddlewaretoken’ с правильным значением. Иначе пользователь получит 403 ошибку. Эта проверка выполняется в CsrfViewMiddleware.
4. В дополнение для HTTPS запросов в CsrfViewMiddleware проверяется “referer”(источник запроса). Это необходимо для предотвращения MITM-атаки(Man-In-The-Middle), которая возможна при использовании HTTPS и токена не привязанного к сессии, т.к. клиенты принимают(к сожалению) HTTP заголовок ‘Set-Cookie’, несмотря на то, что коммуникация с сервером происходит через HTTPS. (Такая проверка не выполняется для HTTP запросов т.к. “Referer” заголовок легко подменить при использовании HTTP.) Если указана настройка CSRF_COOKIE_DOMAIN, значение “referer” будет сравниваться с этим значением. Значение поддерживает под-домены. Например, CSRF_COOKIE_DOMAIN = '.example.com' позволить отправлять POST запросы с www.example.com и api.example.com. Если настройка не указана, “referer” должен быть равен HTTP заголовку Host. Чтобы расширить список доступных доменов, кроме текущего хоста и домена кук, используйте CSRF_TRUSTED_ORIGINS.

Такой подход гарантирует, что только формы, отправленные с доверенных доменов, могут передавать POST данные.

GET игнорируются сознательно (и все другие запросы, которые считаются “безопасными” в соответствии с RFC 2616). Эти запросы никогда не должны выполнять каких-либо потенциально опасные действия, и CSRF атаки через GET запрос должен быть безвредным. RFC 2616 определяет POST, PUT и DELETE как “небезопасные”.

## Что такое сигналы? Зачем нужны? Назовите основные

Сигналы – это события в экосистеме Джанго. С помощью сигналов подсистемы оповещают приложение о том, что случилось. Чтобы читать сигналы, программист регистрирет обработчики сигналов. Сигналы распространяются синхронно. Это значит, подписав на один сигнал сотню обработчиков, мы увеличим время, необходимое на отдачу ответа.

Основные сигналы это начало запроса и его окончание, перед сохранением модели и после, обращение к базе данных.

**Важно:** сигналы моделей работают поштучно, то есть для одной модели. При пакетной обработке, например, `queryset.all().delete()` или `queryset.all().update({'foo'=42})`, события об удалении или изменения не будут вызваны.

## Как реализуется связь m2m на уровне базы данных

Если есть модели A и B со связью многие ко многим, то создается таблица-мост с именем `a_to_b`, которая хранит ключ на A, ключ на B и дополнительные сведения, например, время, когда была создана связь. Эта таблица сцепляется с A и B оператором `JOIN`.

## Чем лучше отправлять форму — GET или POST

Форму можно отправлять обоими способами. В первом случае переменные прикрепляются к строке запроса после вопросительного знака. Во втором – передаются в теле запроса.

Техническое ограничение метода GET в том, что им нельзя передать файл, в отличие от POST.

Форму желательно передавать методом POST по следующим причинам:

- GET-запросы могут быть кешированы, особенно в браузерах семейства IE
- GET-запросы оседают в логах провайдера, сервера, истории браузера. Пароль и логин в таком случае может засветиться во многих местах
- некоторые вирусы отслеживают содержимое адресной строки и пересылают третьим лицам.

## Как работает Serializer в Django REST Framework

Serializer преобразует информацию, хранящуюся в базе данных и определенную с помощью моделей Django, в формат, который легко и эффективно передается через API.

Модели Django интуитивно представляют данные, хранящиеся в базе, но API должен передавать информацию в менее сложной структуре. Хотя данные будут представлены как экземпляры классов Model, их необходимо перевести в формат JSON для передачи через API.

Сериализатор DRF производит это преобразование. Когда пользователь передает информацию (например, создание нового экземпляра) через API, сериализатор берет данные, проверяет их и преобразует в нечто, что Django может сложить в экземпляр модели. Аналогичным образом, когда пользователь обращается к информации через API, соответствующие экземпляры передаются в сериализатор, который преобразовывает их в формат, который может быть легко передан пользователю как JSON.

Наиболее распространенной формой, которую принимает сериализатор DRF, является тот, который привязан непосредственно к модели Django:

```python
class ThingSerializer(serializers.ModelSerializer):
  class Meta:
    model = Thing
    fields = (‘name’, )
```

Настройки fields позволяют точно указать, какие поля доступны этому сериализатору. В качестве альтернативы, может быть установлен exclude вместо fields, которое будет включать все поля модели, кроме тех, которые указаны в exclude.

Сериализаторы — это невероятно гибкий и мощный компонент DRF. Хотя подключение сериализатора к модели является наиболее распространенным, сериализаторы могут использоваться для создания любой структуры данных Python через API в соответствии с определенными параметрами.

## Что такое Meta в классах Django и для чего нужен

Django во многом работает через метаклассы.

Если коротко, то метаклассы - это классы, которые конструируют другие классы. Объявляются они через атрибут класса `__metaclass__` (в джанге через слой совместимости с python 3 через модуль six до версии 2).

Поэтому когда Django конструирует ваш класс, она делает это с помощью своего метакласса. Чтобы при конструировании ей знать какие-то параметры вашего класса, ну, например модель или поля в вашем случае, она ищет в вашем классе класс с названием Meta.

Вообще вся эта магия с метаклассами очень важна в джанге и поэтому лучше саму логику становления класса не переопределять.

Если взять за пример Serializer, то можно посмотреть на код джанги:

```python
@six.add_metaclass(SerializerMetaclass)
class Serializer(BaseSerializer):
  ...
```

SerializerMetaclass - это тот самый метакласс, который конструирует класс ModelForm.

## За что отвечает Meta в сериализаторе

В классе Meta сериализатора можно задать модель по которой будет создан сериализатор, поля, которые будут включены (или exclude для исключения), `list_serializer_class`, например для того чтобы задать специфическую валидацию списков и тд.

## Какая разница в быстродействии между django и Flask (и почему)

Насчет быстродействия затрудняюсь ответить, потому что это довольно каверзный вопрос, тестов лично я не проводил. Но, что касается отличий этих двух фреймворков:

- Flask предоставляет простоту, гибкость и аккуратность в работе, позволяя пользователю самому выбирать, как реализовать те или иные вещи.
- Django предоставляет пакет «все включено»: у вас есть панель админа, интерфейсы баз данных, ORM, и структура каталогов для ваших приложений и проектов.

Под каждую задачу нужно брать свой инструмент, Django хорошо подойдет для новостных сайтов, блогов и тд, благодаря тому что у него уже из коробки есть многое (в том числе админка), да и создавался он именно под такой тип сайтов. Flask же из коробки напротив, практически ничего не имеет и лучше подойдет для каких-либо микросервисов или приложений для которых стек технологий с которыми поставляется Django не подходит.

## Как в django работает система аутентификации

Django поставляется с системой аутентификации пользователей. Она обеспечивает пользовательские аккаунты, группы, права и сессии на основе куки.

Система аутентификации Django отвечает за оба аспекта: аутентификацию и авторизацию. Если коротко, то аутентификация проверяет пользователя, а авторизация определяет, что аутентифицированный пользователь может делать. Далее термин “аутентификация” будет использоваться для обозначения обоих аспектов ([User authentication in Django](https://docs.djangoproject.com/en/2.2/topics/auth/)).

Система аутентификации состоит из:

- Пользователей
- Прав: Бинарные (да/нет) флаги, определяющие наличие у пользователя права выполнять определённые действия.
- Групп: Общий способ назначения меток и прав на множество пользователей.
- Настраиваемой системы хеширования паролей
- Инструментов для форм и представлений для аутентификации пользователей или для ограничения доступа к контенту
- Системы плагинов

Аутентификационная система Django старается быть очень простой и не предоставляет некоторые фичи, распространённые в других системах веб аутентификации. Такие фичи реализованы в сторонних пакетах:

- Проверка сложности пароля
- Ограничение попыток входа
- Аутентификация через сторонние сервисы (OAuth, например)
- 
---
## select_related и prefetch_related

В Django select_related и prefetch_related предназначены для остановки потока запросов к базе данных, вызванных доступом к связанным объектам.

### select_related

Django предлагает QuerySet-метод под названием select_related(), который позволяет извлекать связанные объекты для взаимосвязей один-ко-многим. Это транслируется в один более сложный набор запросов, но зато позволяет избегать дополнительных запросов при доступе к связанным объектам. Метод select_related предназначен для полей ForeignKey и OneToOne. Он работает, выполняя SQL-инструкцию JOIN и включая поля связанного объекта в инструкцию SELECT.

Мы используем select_related, когда объект, который вы собираетесь выбрать, является одним объектом, что означает пересылку ForeignKey, OneToOne и обратный OneToOne.

select_related работает путем создания соединения SQL и включения полей связанного объекта в оператор SELECT. По этой причине select_related получает связанные объекты в том же запросе к базе данных.
```
queryset = Book.objects.all()
for book in queryset:
        books.append({'id': book.id, 'name': book.name)

Number of SQL Queries : 101        
```
Один запрос для заполнения всех книг и, выполняя итерацию каждый раз, мы получаем доступ к издателю, который выполняет другой отдельный запрос.

Давайте изменим запрос с помощью select_related следующим образом и посмотрим, что произойдет.

```
queryset = Book.objects.select_related('publisher').all()
for book in queryset:
        books.append({'id': book.id, 'name': book.name)

Number of SQL Queries : 1
        
```
### prefetch_related

Метод select_related() поможет повышать производительность при извлечении связанных объектов во взаимосвязях один-ко-многим. Однако он не работает для взаимосвязей многие-ко-многим или многие-к-одному (поля ManyToMany или обратного внешнего ключа ForeignKey). Django предлагает другой QuerySet-метод под названием prefetch_related, который в дополнение к взаимосвязям, поддерживаемым методом select_related(), успешно работает для взаимосвязей многие-ко-многим и многие-к-одному. Метод prefetch_related() выполняет отдельный поиск по каждой взаимосвязи и соединяет результаты с помощью Python. Этот метод также поддерживает упреждающую выборку полей GenericRelation и GenericForeignKey.


Мы используем prefetch_related, когда собираемся получить набор вещей.

Это означает обработку ManyToMany и обратных ManyToMany, ForeignKey. prefetch_related выполняет отдельный поиск для каждой связи и выполняет «объединение» в Python.

Он отличается от select_related. prefetch_related выполнял JOIN с использованием Python, а не в базе данных.
```
queryset = Store.objects.all()
for store in queryset:
        books = [book.name for book in store.books.all()]
        stores.append({'id': store.id, 'name': store.name, 'books': books})

Number of Queries : 11
```
У нас в базе 10 магазинов и в каждом магазине по 10 книг. Здесь происходит один запрос для выборки всех хранилищ, и во время итерации по каждому хранилищу выполняется другой запрос, когда мы получаем доступ к полю books ManyToMany.

Давайте уменьшим количество запросов с помощью prefetch_related.

```
queryset = Store.objects.prefetch_related('books')
    for store in queryset:
        books = [book.name for book in store.books.all()]
        stores.append({'id': store.id, 'name': store.name, 'books': books})

Number of Queries : 2
```
Здесь производительность запросов улучшилась, с 11 до 2 запросов. Я хочу, чтобы вы поняли, что здесь делает prefetch_related.

Возьмем еще один пример для prefetch_related.

В коде команды управления я произвольно устанавливаю цену книги от 50 до 300. Теперь мы найдем дорогие книги (цена от 250 до 300) в каждом магазине.

```
queryset = Store.objects.prefetch_related('books')
    for store in queryset:
        books = [book.name for book in store.books.filter(price__range=(250, 300))]
        stores.append({'id': store.id, 'name': store.name, 'books': books})

Number of Queries : 12
```
Несмотря на то, что мы используем prefetch_related, наши запросы скорее увеличились, чем уменьшились. Но почему?

Используя предварительную выборку, мы говорим Django предоставить все результаты для JOIN, но когда мы используем фильтр (price__range = (250, 300)), мы меняем основной запрос, и тогда Django не присоединяется к правильным результатам для нас.

По этой причине у нас есть 12 запросов, 11 запросов, повторяющихся по хранилищам, и один запрос для получения всех результатов в режиме предварительной выборки.

Решим проблему с Prefetch.
```

queryset = Store.objects.prefetch_related(
        Prefetch('books', queryset=Book.objects.filter(price__range=(250, 300))))
for store in queryset:
    books = [book.name for book in store.books.all()]
    stores.append({'id': store.id, 'name': store.name, 'books': books})

Number of Queries : 2
```

select_releted - [select_related и prefetch_related в Django](https://django.fun/ru/articles/tutorials/select_related-i-prefetch_related-v-django/)

---

Разобралась со своей историей с токенами, вдруг кому пригодится: для создания юзера у меня был обычный modelserializer, в нем пользователь создается с обычным паролем, а джосер ожидает хэшированный пароль. Для этого нужно использовать from djoser.serializers import UserCreateSerializer. Тогда пользователь создается с хэшированным паролем, который распознает джосер и токен выдается корректно.

---

Леонид Агапов, [30.08.2023 21:24]
Ниже приведены 50 вопросов на собеседование для позиции Junior Python Backend разработчика на вебфреймворках Django и Flask:

1. Что такое веб-фреймворк?
2. Чем отличаются Django и Flask?
3. Какие основные компоненты входят в Django?
4. Какие основные компоненты входят в Flask?
5. Что такое ORM?
6. Какие ORM-библиотеки используются в Django и Flask?
7. Что такое миграции базы данных?
8. Какие инструменты используются для работы с миграциями в Django и Flask?
9. Какие типы запросов HTTP вы знаете?
10. Какие типы ответов HTTP вы знаете?
11. Что такое RESTful API?
12. Какие методы HTTP используются для работы с ресурсами в RESTful API?
13. Что такое маршрутизация (routing)?
14. Какие инструменты используются для маршрутизации в Django и Flask?
15. Что такое шаблонизация?
16. Какие шаблонизаторы используются в Django и Flask?
17. Что такое сессии и как они работают в Django и Flask?
18. Какие виды аутентификации вы знаете?
19. Какие виды авторизации вы знаете?
20. Какие виды кэширования вы знаете и как они реализуются в Django и Flask?
21. Что такое мидлвары (middleware)?
22. Какие мидлвары используются в Django и Flask?
23. Что такое валидация данных?
24. Какая библиотека используется для валидации данных в Django и Flask?
25. Какие инструменты используются для тестирования кода в Django и Flask?
26. Что такое многопоточность и как она реализуется в Python?
27. Какие инструменты используются для работы с асинхронным кодом в Django и Flask?
28. Что такое сигналы (signals) в Django?
29. Какие инструменты используются для работы с базами данных в Django и Flask?
30. Что такое механизм миграции баз данных?
31. Какие базы данных поддерживаются Django и Flask?
32. Какие инструменты используются для обработки форм в Django и Flask?
33. Что такое межсайтовая подделка запроса (CSRF)?
34. Какие инструменты используются для защиты от CSRF-атак в Django и Flask?
35. Что такое сигналы (signals) в Flask?
36. Что такое декораторы и как они используются в Django и Flask?
37. Какие инструменты используются для работы с файлами и загрузки файлов в Django и Flask?
38. Что такое кукисы (cookies) и как они работают в Django и Flask?
39. Какие инструменты используются для отправки электронной почты в Django и Flask?
40. Что такое межпроцессовое взаимодействие (IPC)?
41. Какие инструменты используются для межпроцессового взаимодействия в Django и Flask?
42. Что такое кэширование и как оно реализуется в Django и Flask?
43. Какие инструменты используются для кэширования данных в Django и Flask?
44. Что такое микросервисная архитектура и как она реализуется в Django и Flask?
45. Какие инструменты используются для развертывания приложений Django и Flask?
46. Что такое среда выполнения (runtime)?
47. Какие инструменты используются для управления средой выполнения в Django и Flask?
48. Что такое документирование кода и как оно реализуется в Django и Flask?
49. Какие инструменты используются для документирования кода в Django и Flask?
50. Что такое контейнеризация и как она реализуется в Django и Flask?

Ответы:

1. Веб-фреймворк - это программная платформа, которая предоставляет разработчикам набор инструментов и библиотек для создания веб-приложений.
2. Django - это полноценный веб-фреймворк, который предоставляет множество готовых компонентов для разработки веб-приложений, таких как ORM, система маршрутизации, система шаблонов и т. д. Flask - это более легковесный микрофреймворк, который предоставляет базовый набор инструментов для создания веб-приложений.
3. Основные компоненты Django: ORM (Object-Relational Mapping), система маршрутизации, система шаблонов, система аутентификации и авторизации, система управления базами данных, система миграции баз данных.
4. Основные компоненты Flask: система маршрутизации, система шаблонов, система аутентификации и авторизации, система управления базами данных.
5. ORM (Object-Relational Mapping) - это техника программирования, которая позволяет работать с базами данных с использованием объектно-ориентированной парадигмы.
6. В Django используется ORM-библиотека Django ORM, а в Flask - ORM-библиотека SQLAlchemy.
7.

Леонид Агапов, [30.08.2023 21:24]
Миграции баз данных - это процесс автоматического обновления структуры базы данных при изменении моделей данных.
8. В Django для работы с миграциями используется инструмент Django ORM, а в Flask - инструмент Flask-Migrate.
9. Типы запросов HTTP: GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS.
10. Типы ответов HTTP: 200 OK, 201 Created, 204 No Content, 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 500 Internal Server Error и т. д.
11. RESTful API - это архитектурный стиль разработки веб-сервисов, который основан на использовании протокола HTTP и позволяет создавать легко масштабируемые и гибкие веб-приложения.
12. Методы HTTP для работы с ресурсами в RESTful API: GET (получение данных), POST (создание нового ресурса), PUT (обновление существующего ресурса), DELETE (удаление ресурса).
13. Маршрутизация (routing) - это процесс определения, какой код должен быть выполнен при обращении к определенному URL-адресу.
14. В Django для маршрутизации используется система URLconf, а в Flask - декораторы маршрутизации.
15. Шаблонизация - это процесс разделения кода и представления данных, позволяющий создавать динамические HTML-страницы.
16. В Django используется шаблонизатор Django Template, а в Flask - шаблонизатор Jinja2.
17. Сессии - это механизм хранения данных на сервере, связанных с определенным клиентом, для поддержки состояния между запросами.
18. В Django и Flask используются различные методы аутентификации, такие как базовая аутентификация, токены доступа, OAuth и др.
19. Авторизация - это процесс проверки прав доступа к определенным ресурсам или функциям веб-приложения.
20. В Django и Flask используются различные методы авторизации, такие как ролевая авторизация, политики доступа и др.
21. Мидлвары (middleware) - это компоненты, которые выполняются перед и после обработки запросов веб-приложения и позволяют выполнять определенные операции, такие как логирование, обработка ошибок и др.
22. В Django используется система мидлваров Django Middleware, а в Flask - декораторы мидлваров.
23. Валидация данных - это процесс проверки корректности данных перед их использованием в приложении.
24. В Django используется библиотека Django Forms, а в Flask - библиотека WTForms.
25. В Django используется инструмент Django Testing Framework, а в Flask - инструмент Flask-Testing.
26. Многопоточность - это возможность программы выполнять несколько потоков одновременно для увеличения производительности.
27. В Django и Flask для работы с асинхронным кодом используются инструменты asyncio и aiohttp.
28. Сигналы (signals) в Django - это способ отправки и обработки событий в приложении.
29. В Django используется система сигналов Django Signals.
30. В Django и Flask для работы с базами данных используются ORM-библиотеки, такие как Django ORM и SQLAlchemy.
31. В Django поддерживаются различные базы данных, такие как PostgreSQL, MySQL, SQLite, Oracle и др., а в Flask - любая база данных, поддерживаемая SQLAlchemy.
32. В Django для обработки форм используется инструмент Django Forms, а в Flask - инструмент WTForms.
33. Межсайтовая подделка запроса (CSRF) - это атака, при которой злоумышленник отправляет запрос от имени авторизованного пользователя без его согласия.
34. В Django и Flask для защиты от CSRF-атак используются различные методы, такие как использование токенов CSRF, проверка Referer-заголовка и др.
35. Сигналы (signals) в Flask - это способ отправки и обработки событий в приложении.
36. Декораторы - это специальные функции, которые позволяют изменять поведение других функций или классов.
37. В Django и Flask для работы с файлами и загрузки файлов используются инструменты FileField и Flask-Uploads.
38. Куки (cookies) - это небольшие текстовые файлы, которые хранятся на компьютере пользователя и используются для хранения информации о состоянии сеанса.
39. В Django для отправки электронной почты используется инструмент Django Email, а в Flask - инструмент Flask-Mail.
40. Межпроцессовое взаимодействие (IPC) - это механизм передачи данных между процессами или потоками в операционной системе.
41. В Django и Flask для межпроцессов

Леонид Агапов, [30.08.2023 21:25]
ого взаимодействия используются различные методы, такие как использование сокетов, очередей сообщений и др.
42. Кэширование - это процесс сохранения данных в быстродействующей памяти для ускорения доступа к ним.
43. В Django и Flask для кэширования данных используются инструменты Django Cache и Flask-Caching.
44. Микросервисная архитектура - это подход к разработке приложений, при котором они разбиваются на небольшие независимые сервисы, каждый из которых выполняет определенные функции.
45. В Django и Flask для развертывания приложений используются инструменты, такие как Gunicorn, uWSGI, Nginx и др.
46. Среда выполнения (runtime) - это среда, в которой выполняется программа, включая операционную систему, библиотеки и другие зависимости.
47. В Django и Flask для управления средой выполнения используются инструменты, такие как virtualenv, pipenv, Docker и др.
48. Документирование кода - это процесс создания документации, которая описывает функции, классы и другие элементы кода.
49. В Django и Flask для документирования кода используются инструменты, такие как Sphinx, MkDocs и др.
50. Контейнеризация - это технология, которая позволяет упаковывать приложение и его зависимости в отдельный контейнер, который можно запускать на любой платформе без изменений.

Это лишь небольшой набор вопросов, которые могут быть заданы на собеседовании. Важно помнить, что конкретные вопросы могут отличаться в зависимости от компании и позиции, поэтому рекомендуется изучить документацию Django и Flask, а также пройти практические задания и упражнения, чтобы быть готовым к собеседованию.