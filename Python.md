Python
========================
---
## Какие типы данных вы знаете?

В Python есть несколько стандартных типов данных:

1. Numbers (числа) - int(5), float(5.2), complex (-5i, 3+2i)
2. Strings (строки) - str('текст')
3. Lists (списки) - list [1, 2, 'c']
4. Dictionaries (словари) - dict {'color': 'red', 'model': 'VC6'}
5. Tuples (кортежи) - tuple ('red', 'blue', 'green')
6. Sets (множества) - контейнеры, содержащие уникальные значения. Подразделяются на **изменяемые set** и **неизменяемые frozenset** множества. set {1, 3, 9, 'Ку'}
7. Boolean (логический тип данных) - True False
8. NoneType - None (пустое значение)
9. Байтовые типы – bytes (байты), bytearray (изменяемая байтовая строка), memoryview (предоставление доступа к внутренним данным объекта). bytes(3) = b'\x00\x00\x00'

Эти типы данных можно, в свою очередь, классифицировать по нескольким признакам:

1. изменяемые (mutable) - списки, словари и множества
2. неизменяемые (unmutable) - числа, строки и кортежи, frozenset - все что можно захешировать.
3. упорядоченные (списки, кортежи, строки и словари)
4. неупорядоченные (множества)
    
Подробнее -  [Типы данных в Python](https://proglib.io/p/samouchitel-po-python-dlya-nachinayushchih-chast-3-tipy-dannyh-preobrazovanie-i-bazovye-operacii-2022-10-14)

Чтобы узнать тип данных, нужно воспользоваться встроенной функцией type():

---

## Что такое хеширование
 
hash() - встроенная функция. Она принимает объект и возвращает его хеш. Хеши используются для быстрого сравнения ключей словаря во время поиска по нему.

Хеш - это результат хеширования, т.е. операции по преобразованию данных в строку или число фиксированной длины. В Pyhton хеш - это целые числа. Два одинаковых объекта должны иметь одинаковый хеш, но обратное не обязательно верно.

Существует также метод __hash__(), его наличие у объекта, позволяет передать этот объект функции hash(), потому что "под капотом" функция вызывает именно этот метод. Этот метод есть только у неизменяемых объектов (str, int, tuple). Объекты, которые им обладают, могут входить в set, frozenset или быть ключами dict.

Ситуация, когда хеш-функция для разных входных данных выдаёт одно и то же значение, называется «коллизией».
Коллизии могут случаться у всех без исключения хеш-функций, поэтому в реализации хеш-таблицы обязательно должна быть заложена логика разрешения коллизий. 

### Решения проблемы коллизии методом двойного хеширования

Мы будем (как несложно догадаться из названия) использовать две хеш-функции, возвращающие взаимопростые натуральные числа.


Одна хеш-функция (при входе g) будет возвращать натуральное число s, которое будет для нас начальным. То есть первое, что мы сделаем, попробуем поставить элемент g на позицию s в нашем массиве. Но что, если это место уже занято? Именно здесь нам пригодится вторая хеш-функция, которая будет возвращать t — шаг, с которым мы будем в дальнейшем искать место, куда бы поставить элемент g.

глубже - [Реализация словаря в Python / Хабр](https://habr.com/ru/companies/otus/articles/448350/)

еще - [Хеш-таблицы | Python: Cловари и множества](https://ru.hexlet.io/courses/python-dicts/lessons/hash-table/theory_unit)

еще - 5 Глава грокаем алгоритмы 

---
### Хеш-таблица
  
  Хеш-таблица (англ. hash table)  — это один из способов реализовать ассоциативный массив, при котором все данные записываются и хранятся в виде пар (key, value) в ячейках обыкновенного массива. Эти ячейки называются корзинами (англ. bucket). 

![qownnotes-media-CntZfr](media/qownnotes-media-CntZfr.png)

еще - [Хеш-таблицы / Хабр](https://habr.com/ru/articles/509220/)

---

## Итератор и Генератор.

### Определение итератора
**Итератор (iterator)** - это объект, который возвращает свои элементы по одному за раз. (например в цикле For).
В Python итератор это любой объект у которого есть метод ```__next__ , __iter__```. 


 ```__iter__``` - Метод возвращает сам итератор.
 
 ```__next__``` - Метод возвращает следующий элемент, если он есть, или возвращает исключение StopIteration.

### Ограничения итератора
1. Нельзя получить длину итератора функцией len();
2. Итератор не поддерживает получение элемента по индексу;
3. К итератору нельзя применить обычные операции среза или функцию slice()
4. После прохождения по итератору, он остается пустым; (для повторного использования его нужно создать вновь)

Недостаток типа Iterator состоит в том, что при первом его вызове вычисляются сразу все значения последовательности, к тому же все они хранятся в памяти до их исчерпания. Этот недостаток решает тип generator (генератор).

### Генератор
**Generator*** Генератор - это функция, которая возвращает итератор. Generator не хранит значения последовательности в памяти, а генерирует/вычисляет результат на лету.

Функция считается генератором, если:

1. Cодержит одно или несколько выражений yield.
2. При вызове возвращает объект типа generator, но не начнет выполнение.
3. Методы __iter__() и __next__() реализуются автоматически.
4. После каждого вызова функция приостанавливается, а управление передается вызывающей стороне.
5. Локальные переменные и их состояния запоминаются между последовательными вызовами.
6. Когда вычисления заканчиваются по какому то условию, автоматически вызывается StopIteration.

```Важно! Так как генератор - это "улучшенный" итератор, следовательно на тип generator распространяются такие же ограничения как и тип тип iterator.```

1. generator.send(value): - Метод возобновляет выполнение и “отправляет " значение в функцию генератора. 
2. generator.close(): - Метод вызывает исключение GeneratorExit в точке, где функция генератора была приостановлена.
3. throw() — заставить его бросить исключение.

Итератор - [Итератор Iterator, протокол итератора в Python](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-iterator-iterator/)

Генератор - [Генератор generator в Python и выражение yield](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-generator-generator/)

[Итераторы в Python для самых маленьких / Хабр](https://habr.com/ru/companies/domclick/articles/674194/)

1. пример кастомного итератора

```
    class TumbochkaIterator:
    def __init__(self, some_objects):
        self.some_objects = some_objects
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current < len(self.some_objects):
            result = self.some_objects[self.current]
            self.current += 1
            return result
        raise StopIteration
```
2. Перепише цикл For через While
```
try:
    iteraton = iter(object)
    while True:
        print(next(iterator))
except StopIteration:
    pass        
```
3. пример функции генератора Python, которая определяет следующее значение в последовательности Фибоначчи.
```
def fibonacci(xterms):
    # первые два условия
    x1 = 0
    x2 = 1
    count = 0

    if xterms <= 0:
        print("Укажите целое число больше 0")
    elif xterms == 1:
        print("Последовательность Фибоначчи до", xterms, ":")
        print(x1)
    else:
        while count < xterms:
            xth = x1 + x2
            x1 = x2
           x2 = xth
           count += 1
           yield xth

fib = fibonacci(5)

print(next(fib))
print(next(fib))
print(next(fib))
```
---
## Итераторы и генераторы

- [Генераторы-итераторы Python](https://xakep.ru/2014/10/06/generatora-iteratory-python/)
- [Итерируемый объект, итератор и генератор](https://habr.com/ru/post/337314/)

### Что такое контейнер

Контейнер – это тип данных, который инкапсулирует в себе значения других типов. Списки, кортежи, множества, словари и т.д. являются контейнерами.

### Что такое итерабельный объект

*Итерабельный объект* (в оригинальной терминологии – «iterable») – это объект, который может возвращать значения по одному за раз.
Примеры: все контейнеры и последовательности (списки, строки и т.д.), файлы, а также экземпляры любых классов, в которых определён метод `__iter__()` или `__getitem__()`.
Итерабельные объекты могут быть использованы внутри цикла `for`, а также во многих других случаях, когда ожидается последовательность (функции `sum()`, `zip()`, `map()` и т.д.).

**Подробнее**:

Рассмотрим итерируемый объект (`Iterable`). В стандартной библиотеке он объявлен как абстрактный класс `collections.abc.Iterable`:

```python
class Iterable(metaclass=ABCMeta):

    __slots__ = ()

    @abstractmethod
    def __iter__(self):
        while False:
            yield None

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Iterable:
            return _check_methods(C, "__iter__")
        return NotImplemented
```

У него есть абстрактный метод `__iter__` который должен вернуть объект итератора. И метод `__subclasshook__` который проверяет наличие у класса метод `__iter__`. Таким образом, получается, что итерируемый объект это любой объект который реализует метод `__iter__`

```python
class SomeIterable1(collections.abc.Iterable):
    def __iter__(self):
        pass

class SomeIterable2:
    def __iter__(self):
        pass

print(isinstance(SomeIterable1(), collections.abc.Iterable))
# True
print(isinstance(SomeIterable2(), collections.abc.Iterable))
# True
```

Но есть один момент, это функция `iter()`. Именно эту функцией использует например цикл for для получения итератора. Функция `iter()` в первую очередь для получения итератора из объекта, вызывает его метод `__iter__`. Если метод не реализован, то она проверяет наличие метода `__getitem__` и если он реализован, то на его основе создается итератор. `__getitem__` должен принимать индекс с нуля. Если не реализован ни один из этих методов, тогда будет вызвано исключение `TypeError`.

```python
from string import ascii_letters

class SomeIterable3:
    def __getitem__(self, key):
        return ascii_letters[key]

for item in SomeIterable3():
    print(item)
```

### Что такое итератор

*Итератор* (iterator) – это объект, который представляет поток данных. Повторяемый вызов метода `__next__()` (`next()` в Python 2) итератора или передача его встроенной функции `next()` возвращает последующие элементы потока.

Если больше не осталось данных, выбрасывается исключение `StopIteration`. После этого итератор исчерпан и любые последующие вызовы его метода `__next__()` снова генерируют исключение `StopIteration`.

Итераторы обязаны иметь метод `__iter__`, который возвращает сам объект итератора, так что любой итератор также является итерабельным объектом и может быть использован почти везде, где принимаются итерабельные объекты.

**Подробнее:**

Итераторы представлены абстрактным классом `collections.abc.Iterator`:

```python
class Iterator(Iterable):

    __slots__ = ()

    @abstractmethod
    def __next__(self):
        'Return the next item from the iterator. When exhausted, raise StopIteration'
        raise StopIteration

    def __iter__(self):
        return self

    @classmethod
    def __subclasshook__(cls, C):
        if cls is Iterator:
            return _check_methods(C, '__iter__', '__next__')
        return NotImplemented
```

`__next__` Возвращает следующий доступный элемент и вызывает исключение `StopIteration`, когда элементов не осталось.
`__iter__` Возвращает `self`. Это позволяет использовать итератор там, где ожидается итерируемых объект, например `for`.
`__subclasshook__` Проверяет наличие у класса метода `__iter__` и `__next__`

### Что такое генератор

В зависимости от контекста, может означать либо функцию-генератор, либо итератор генератора (чаще всего, последнее).
Методы `__iter__` и `__next__` у генераторов создаются автоматически.

С точки зрения реализации, *генератор* в Python — это языковая конструкция, которую можно реализовать двумя способами: как функция с ключевым словом `yield` или как генераторное выражение. В результате вызова функции или вычисления выражения, получаем объект-генератор типа `types.GeneratorType`. Канонический пример - генератор, порождающий последовательность чисел Фибоначчи, которая, будучи бесконечна, не смогла бы поместиться ни в одну коллекцию. Иногда термин применяется для самой генераторной функции, а не только объекта, возвращенного ей в качестве результата.

Так как в объекте-генераторе определены методы `__next__` и `__iter__`, то есть реализован протокол итератора, с этой точки зрения, в Python любой генератор является итератором.

Когда выполнение функции-генераторы завершается (при помощи ключевого слова `return` или достижения конца функции), возникает исключение `StopIteration`.

### Что такое генераторная функция

*Генераторная функция* - функция, в теле которой встречается ключевое слово `yield`. Будучи вызвана, такая функция возвращает объект-генератор (generator object) (итератор генератора (generator iterator)).

### Что делает yield

`yield` замораживает состояние функции-генератора и возвращает текущее значение. После следующего вызова `__next__()` функция-генератор продолжает своё выполнение с того места, где она была приостановлена.

### В чем отличие \[x for x in y\] от (x for x in y)

Первое выражение возвращает список (списковое включение), второе – генератор.

### Что особенного в генераторе

Генератор хранит в памяти не все элементы, а только внутреннее состояние для вычисления очередного элемента. На каждом шаге можно вычислить только следующий элемент, но не предыдущий. Пройти генератор в цикле можно только один раз.

### Как объявить генератор

- использовать синтаксис `(x for x in seq)`
- оператор `yield` в теле функции вместо `return`
- встроенная функция `iter`, которая вызывает у объекта метод `__iter__()`. Этот метод должен возвращать генератор.

### Как получить из генератора список

Передать его в конструктор списка: `list(x for x in some_seq)`. Важно, что после этого по генератору уже нельзя будет итерироваться.

### Что такое подгенератор

В Python 3 существуют так называемые подгенераторы (subgenerators). Если в функции-генераторе встречается пара ключевых слов `yield from`, после которых следует объект-генератор, то данный генератор делегирует доступ к подгенератору, пока он не завершится (не закончатся его значения), после чего продолжает своё исполнение.

На самом деле `yield` является выражением. Оно может принимать значения, которые отправляются в генератор. Если в генератор не отправляются значения, результат данного выражения равен `None`.

`yield from` также является выражением. Его результатом является то значение, которое подгенератор возвращает в исключении `StopIteration` (для этого значение возвращается при помощи ключевого слова `return`).

### Какие методы есть у генераторов

- `__next__()` – начинает или продолжает исполнение функции-генератора. Результат текущего yield-выражения будет равен None. Выполнение затем продолжается до следующего yield-выражения, которое передаёт значение туда, где был вызван `__next__`. Если генератор завершается без возврата значения при помощи `yield`, возникает исключение `StopIteration`. Метод обычно вызывается неявно, то есть циклом `for` или встроенной функцией `next()`.
- `send(value)` – продолжает выполнение и отправляет значение в функцию-генератор. Аргумент value становится значением текущего yield-выражения. Метод `send()` возвращает следующее значение, возвращённое генератором, или выбрасывает исключение `StopIteration`, если генератор завершается без возврата значения. Если `send()` используется для запуска генератора, то единственным допустимым значением является `None`, так как ещё не было выполнено ни одно yield-выражение, которому можно присвоить это значение.
- `throw(type[, value[, traceback]])` – выбрасывает исключение типа type в месте, где был приостановлен генератор, и возвращает следующее значение генератора (или выбрасывает `StopIteration`). Если генератор не обрабатывает данное исключение (или выбрасывает другое исключение), то оно выбрасывается в месте вызова.
- `close()` – выбрасывает исключение `GeneratorExit` в месте, где был приостановлен генератор. Если генератор выбрасывает `StopIteration` (путём нормального завершения или по причине того, что он уже закрыт) или `GeneratorExit` (путём отсутствия обработки данного исключения), `close` просто возвращается к месту вызова. Если же генератор возвращает очередное значение, выбрасывается исключение `RuntimeError`. Метод `close()` ничего не делает, если генератор уже завершён.

### Можно ли извлечь элемент генератора по индексу

Нет, будет ошибка. Генератор не поддерживает метод `__getitem__`.

### Что возвращает итерация по словарю

Ключ. Порядок следования ключей не гарантируется (в 3.6 гарантируется неофициально, в 3.7 гарантируется). Для маленьких словарей порядок будет тот же, что и в объявлении. Для больших порядок зависит от расположения элементов в памяти. Особый класс `OrderedDict` учитывает порядок добавления ключей.

```python
for key in {'foo': 1, 'bar': 2}:
    process_key(key)
```

### Как итерировать словарь по парам ключ-значение

Метод словаря `.items()` возвращает генератор кортежей `(key, value)`.



---
## Последовательности

### Что такое последовательность

Последовательностью в Python называется итерабельный объект, который поддерживает эффективный доступ к элементам с использованием целочисленных индексов через специальный метод `__getitem__()` и поддерживает метод `__len__()`, который возвращает длину последовательности.
К основным встроенным типам последовательностей относятся list, tuple, range, str и bytes.

Последовательности также опционально могут реализовывать методы `count()`, `index()`, `__contains__()` и `__reversed__()` и другие.

### Какие операции поддерживают большинство последовательностей

- `x in s`, `x not in s` – находится ли элемент x в последовательности s (для строк и последовательностей байтов – является ли x подстрокой s)
- `s + t` – конкатенация последовательностей
- `s * n, n * s` – конкатенация n нерекурсивных копий последовательности s
- `s[i]` – i-й элемент последовательности s
- `s[i:j]` – срез последовательности s от i до j
- `s[i:j:k]` – срез последовательности s от i до j с шагом k
- `len(s)` – длина последовательности
- `min(s)` – минимальный элемент последовательности
- `max(s)` – максимальный элемент последовательности
- `s.index(x[, i[, j]])` – индекс первого вхождения x (опционально – начиная с позиции i и до позиции j)
- `s.count(x)` – общее количество вхождений x в s
- `sum(s)` – сумма элементов последовательности

Неизменяемые последовательности обычно реализуют операцию hash(s) – хеш-значение объекта.

Большинство изменяемых последовательностей поддерживают следующие операции:

- `s[i] = x` – элемент с индексом i заменяется на x
- `s[i:j] = t`, `s[i:j:k] = t` – элементы с индексами от i до j (с шагом k) заменяются содержимым итерабельного объекта t
- `del s[i:j]`, `del s[i:j:k]` – удаление соответствующих элементов из последовательности
- `s.append(x)` – добавление x в конец последовательности
- `s.clear()` – удаление всех элементов последовательности
- `s.copy()` – нерекурсивная копия последовательности
- `s.extend(t)` – добавление всех элементов итерабельного объекта в конец последовательности
- `s.insert(i, x)` – вставка элемента x по индексу i
- `s.pop()`, `s.pop(i)` – возврат значения по индексу i (по умолчанию – последний элемент) и удаление его из последовательности
- `s.remove(x)` – удаление первого вхождения x
- `s.reverse()` – разворот последовательности в обратном порядке

### Какие виды строк бывают в питоне

Зависит от версии Питона. Во второй ветке два типа: однобайтные строки и Юникод представлены классами str и unicode соответственно. В третьем Питоне есть один вид строк str, который представляет собой Юникод. Однобайтных строк нет, вместо них есть тип bytes, то есть цепочка байт.

### Можно ли изменить отдельный символ внутри строки

Нет, строки неизменяемы. Операции замены, форматирования и конкатенации возвращают новую строку.

### Как соединить список строк в одну. Как разбить строку на список строк

Чтобы соединить, нужен метод строки `.join()`. Чтобы разбить, метод `.split()`.

### Как кодировать и декодировать строки

Кодировать – перевести Юникод в байтовую строку. Вызвать метод `.encode()` у строки.

Декодировать – восстановить строку из цепочки байт. Вызвать метод `.decode()` у объекта `str` или `bytes` (версии Питона 2 и 3 соответственно).

В обоих случаях явно передавать кодировку, иначе будет использована та, что определена в системе по умолчанию. Быть готовым поймать исключения `UnicodeEncodeError`, `UnicodeDecodeError`.

### Чем список отличается от кортежа

Списки – это изменяемые последовательности, обычно используемые для хранения однотипных данных (хотя Python не запрещает хранить в них данные разных типов). Представлены классом list.

Кортежи – это неизменяемые последовательности, обычно используемые, чтобы хранить разнотипные данные. Представлены классом tuple.

На уровне языка отличаются тем, что в кортеж нельзя добавить или убрать элемент. На уровне интерпретатора различий нет. Обе коллекции представлены массивом указателей на структуру `PyObject`.

Для списка определены функции, которые добавляют в такой массив новый элемент, удаляют имеющийся, соединяют два массива в один. Они вызываются методами списка `.append()`, `.pop()`, `.sort()` и т.д.

### Что такое диапазон

Диапазоны – неизменяемые последовательности чисел, которые задаются началом, концом и шагом. Представлены классом range (в Python 2 – xrange; range в Python 2 – это функция, которая возвращает список).
Параметры конструктора должны быть целыми числами (либо экземпляры класса int, либо любой объект с методом `__index__`)
Поддерживает все общие для последовательностей операции, кроме конкатенации и повторения, а также, в версиях Python до 3.2, срезов и отрицательных индексов.

### Как сделать список уникальным (без повторяющихся элементов)

Вариант со множеством. Не гарантирует порядок элементов. Порядок сохраняется только для маленьких списков.

```python
list(set([1, 2, 2, 2, 3, 3, 1]))
>>> [1, 2, 3]
```

Вариант с OrderedDict. Гарантирует порядок элементов.

```python
>>> from collections import OrderedDict
>>> list(OrderedDict.fromkeys([1, 2, 2, 2, 3, 3, 1]))
[1, 2, 3]
```

Вариант с циклом. Медленно, но гарантирует порядок. Подходит, если элементы нельзя помещать внутрь множества (например, словари).

```python
res = []
for x in [1, 2, 2, 2, 3, 3, 1]:
    if x not in res:
        res.append(x)
>>> [1, 2, 3]
```

### Есть кортеж из трех элементов. Назначить переменным a, b, c его значения

`a, b, c = (1, 2, 3)`

### Как сравниваются последовательности

Две последовательности равны, если они имеют одинаковый тип, равную длину и соответствующие элементы обоих последовательностей равны.

Последовательности одинаковых типов можно сравнивать. Сравнения происходят в лексикографическом порядке: последовательность меньшей длины меньше, чем последовательность большей длины, если же их длины равны, то результат сравнения равен результату сравнения первых отличающихся элементов.

## Множества и отображения

### Как понять хешируемый ли объект

Объект называется хешируемым, если он имеет хеш-значение (целое число), которое никогда не изменяется на протяжении его жизненного цикла и возвращается методом `__hash__()`, и может сравниваться с другими объектами (реализует метод `__eq__()`). Равные хешируемые объекты должны иметь равные хеш-значения.
Все стандартные неизменяемые объекты хешируемые. Все стандартные изменяемые объекты не хешируемые.

### Что такое множество

Множество – это неупорядоченная коллекция хешируемых объектов, которые не повторяются.
В множествах нет понятия позиции элемента. Соответственно, они не поддерживают индексацию и срезы.
Встроенные классы множеств: set (изменяемое множество), frozenset (неизменяемое множество).

### Для чего применяются множества

Обычно используются для проверки элемента на вхождение в множество и удаление повторений элементов и выполнения таких операций, как объединение, пересечение, разница и симметрическая разница.

### Какие операции можно производить над множествами

- `set([iterable])`, `frozenset([iterable])` – создание множества (пустого или из элементов итерабельного объекта)
- `len(s)` – количество элементов множества
- `x in s`, `x not in s` – проверка нахождения элемента в множестве
- `s.isdisjoint(t)` – проверка того, что данное множество не имеет общих элементов с заданным
- `s.issubset(t)`, `s <= t` – проверка того, что все элементы множества s являются элементами множества t
- `s < t` – проверка того, что s <= t и s != t
- `s.isuperset(t)`, `s >= t` – проверка того, что все элементы множества t являются элементами множества s
- `s > t` – проверка того, что `s >= t` и `s != t`
- `s.union(t, ...)`, `s | t | ...` – создание нового множества, которое является объединением данных множеств
- `s.intersection(t, ...)`, `s & t & ...` – создание нового множества, которое является пересечением данных множеств
- `s.difference(t, ...)`, `s - t - ...` – создание нового множества, которое является разницей данных множеств
- `s.symmetric_difference(t)`, `s ^ t` – создание нового множества, которое является симметрической разницей данных множеств (то есть, разница объединения и пересечения множеств)
- `s.copy()` – неполная копия множества s

Операции над множествами, которые являются методами, принимают в качестве аргументов любые итерабельные объекты. Операции над множествами, записанные в виде бинарных операций, требуют, чтобы второй операнд операции тоже был множеством, и возвращают множество того типа, которым было первое множество.

Операции над изменяемыми множествами:

- `s.update(t, ...)`, `s |= t | ...` – добавить в данное множество элементы из других множеств
- `s.intersection_update(t, ...)`, `s &= t & ...` – оставить в данном множестве только те элементы, которые есть и в других множествах
- `s.difference_update(t, ...)`, `s -= t | ...` – удалить из данного множества те элементы, которые есть в других множествах
- `s.symmetric_difference_update(t)`, `s ^= t` – оставить или добавить в s элементы, которые есть либо в s, либо в t, но не в обоих множествах
- `s.add(element)` – добавить новый элемент в множество
- `s.remove(element)` – удалить элемент из множества; если такого элемента нет, возникает исключение KeyError
- `s.discard(element)` – удалить элемент из множества, если он в нём находится
- `s.pop()` – удалить из множества и вернуть произвольный элемент; если множество пустое, возникает исключение KeyError
- `s.clear()` – удалить все элементы множества.

### Как происходит проверка множеств на равенство

Проверка множеств на равенство происходит поэлементно, независимо от типов множеств.

### Что такое отображение

Отображение (mapping) – это объект-контейнер, который поддерживает произвольный доступ к элементам по ключам и описывает все методы, описанные в абстрактном базовом классе `collections.Mapping` (`get()`, `items()`, `keys()`, `values()`) или `collections.MutableMapping` (`clear()`, `get()`, `items()`, `keys()`, `pop()`, `popitem()`, `setdefault()`, `update()`, `values()`).
К отображениям относятся классы `dict`, `collections.defaultdict`, `collections.OrderedDict` и `collections.Counter`.

### Какие нюансы есть в использовании чисел как ключей

Числовые ключи в словарях подчиняются правилам сравнения чисел. Таким образом, `int(1)` и `float(1.0)` считаются одинаковым ключом. Однако из-за того, что значения типа float сохраняются приближенно, не рекомендуется использовать их в качестве ключей.

```python
>>> {True: 'yes', 1: 'no', 1.0: 'maybe'}
{True: 'maybe'}
```

### Какие операции можно производить над отображениями

- `len(d)` – количество элементов.
- `d[key]` – получение значения с ключом key. Если такой ключ не существует и отображение реализует специальный метод `__missing__(self, key)`, то он вызывается. Если ключ не существует и метод `__missing__` не определён, выбрасывается исключение KeyError.
- `d[key] = value` – изменить значение или создать новую пару ключ-значение, если ключ не существует.
- `key in d`, `key not in d` – проверка наличия ключа в отображении.
- `iter(d)` – то же самое, что iter(d.keys()).
- `clear()` – удалить все элементы словаря.
- `copy()` – создать неполную копию словаря.
- `(метод класса) dict.fromkeys(sequence[, value])` – создаёт новый словарь с ключами из последовательности sequence и заданным значением (по умолчанию – None).
- `d.get(key[, default])` – безопасное получение значения по ключу (никогда не выбрасывает KeyError). Если ключ не найден, возвращается значение default (по-умолчанию – None).
- `d.items()` – в Python 3 возвращает объект представления словаря, соответствующий парам (двухэлементным кортежам) вида (ключ, значение). В Python 2 возвращает соответствующий список, а метод iteritems() возвращает итератор. Аналогичный метод в Python 2.7 – viewitems().
- `d.keys()` – в Python 3 возвращает объект представления словаря, соответствующий ключам словаря. В Python 2 возвращает соответствующий список, а метод iterkeys() возвращает итератор. Аналогичный метод в Python 2.7 – viewkeys().
- `d.pop(key[, default])` – если ключ key существует, удаляет элемент из словаря и возвращает его значение. Если ключ не существует и задано значение default, возвращается данное значение, иначе выбрасывается исключение KeyError.
- `d.popitem()` – удаляет произвольную пару ключ-значение и возвращает её. Если словарь пустой, возникает исключение KeyError. Метод полезен для алгоритмов, которые обходят словарь, удаляя уже обработанные значения (например, определённые алгоритмы, связанные с теорией графов).
- `d.setdefault(key[, default])` – если ключ key существует, возвращает соответствующее значение. Иначе создаёт элемент с ключом key и значением default. default по умолчанию равен None.
- `d.update(mapping)` – принимает либо другой словарь или отображение, либо итерабельный объект, состоящий из итерабельных объектов – пар ключ-значение, либо именованные аргументы. Добавляет соответствующие элементы в словарь, перезаписывая элементы с существующими ключами.
- `d.values()` – в Python 3 возвращает объект представления словаря, соответствующий значениям. В Python 2 возвращает соответствующий список, а метод itervalues() возвращает итератор. Аналогичный метод в Python 2.7 – viewvalues().

### Что возвращает метод items

Объекты, возвращаемые методами `items()`, `keys()` и `values()` (`viewitems()`, `viewkeys()`, `viewvalues()` в Python 2.7) – это объекты *представления словаря*. Они предоставляют динамическое представление элементов словаря, то есть изменения данного словаря автоматически отображаются и на этих объектах.

Операции с представлениями словарей:

- `iter(dictview)` – получение итератора по ключам, значениям или парам ключей и значений. Все представления словарей при итерировании возвращают элементы словаря в одинаковом порядке. При попытке изменить словарь во время итерирования может возникнуть исключение RuntimeError
- `len(dictview)` – количество элементов в словаре.
- `x in dictview` – проверка существования ключа, значения или пары ключ-значение в словаре.

### Как отсортировать список словарей по определенному полю

Метод списка `.sort()` и встроенная функция `sorted()` принимают параметр `key`. Им должен быть вызываемый объект, который принимает очередной элемент (в нашем случае словарь) и возвращает значение-критерий сортировки.

Код ниже показывает, как отсортировать список людей по возрасту:

```python
users = [{'age': 30}, {'age': 20}, {'age': 10}]
users.sort(key=lambda user: user['age'])
>>> [{'age': 10}, {'age': 20}, {'age': 30}]
```

### Что может являться ключом словаря. Что не может. Почему

Ключом словаря может быть любой хешируемый неизменяемый объект: число, строка, datetime, функция и даже модуль. Такие объекты имеют метод `__hash__()`, который однозначно сопоставляет объект с некоторым числом. По этому числу словарь ищет значение для ключа.

Списки, словари и множества изменяемы и не имеют метода хеширования. При подстановке их в словарь возникнет ошибка.

Хеш кортежа вычисляется рекурсивно по всем элементам. Так, кортеж

`(1, (True, (42, ('hello', ))))`
состоит только из неизменяемых элементов, поэтому может быть ключом. Однако, такой кортеж

`(1, (True, (42, ({'hello': 'world'}, ))))`
содержит глубоко внутри словарь, поэтому хеш не может быть рассчитан.

### Есть два списка – ключи и значения. Как составить из них словарь

```python
keys = ['foo', 'bar', 'baz']
vals = [1, 2, 3]
dict(zip(keys, vals))
>>> {'baz': 3, 'foo': 1, 'bar': 2}
```

Функция `zip` отдает список пар N-ых элементов. Конструктор `dict` принимает список пар. Каждую пару он рассматривает как ключ и значение соответственно.

### Как работает хэш-таблица

Хэш-таблица это разреженный массив (массив, в котором имеются незаполненные позиции). В стандартных англоязычных учебниках ячейки хэш-таблицы называются "bucket". В хэш-таблице dict каждому элементу соотвествует ячейка, содержащая два поля: ссылку на ключ и ссылку на значение элемента. Поскольку размер всех ячеек одинаков, доступ к отдельной ячейке производится по смещению.

Python стремится оставить не менее трети ячеек пустыми; если хэш-таблица становится чрезмерно заполненной, то она копируется в новый участок памяти, где есть место для большего числа ячеек.

Для помещения элемента в хэш-таблицу нужно первым делом вычислить хэш-значение ключа элемента. Это делает встроенная функция `hash()`.

Для выборки значения с помощью выражения `my_dict[search_key]` Python обращается к функции `hash(search_key)`, чтобы получить хэш-значение search_key, и использует несколько младших битов полученного числа как смещение ячейки относительно начала хэш-таблицы (сколько именно битов зависит от текущего размера таблицы). Если найденная ячейка пуста, возбуждается исключение `KeyError`. В противном случае в найденной ячейке есть какой-то элемент - пара `ключ:значение` - и тогда Python проверяет, верно ли то, что search_key == found_key. Если да, то элемент найден и возвращается found_value. Если же search_key и found_key не совпали, то имеет место *коллизия хэширования*. Для разрешения коллизии алгоритм берет различные биты хэш-значения, производит над ними определенные действия и использует результат как смещение другой ячейки.

### Что такое коллизия

Когда хеш-функция возвращает один и тот же ответ для разных данных.

### Где будет быстрее поиск, а где перебор и почему: dict, list, set, tuple

Поиск будет быстрее в dict и set, потому что это хэш-таблицы, доступ к элементу которых выполняется за O(1). Для list и tuple поиск будет выполняться в среднем за O(n).

Исключение работает только для очень маленьких списков длиной до 5 элементов. В этом случае интерпретатору будет быстрей пробежаться по списку, чем считать хеш.

В Python 2 методы словаря `keys`, `values`, `items` возвращают список. Тоесть перед итерацией по словарю (или сету) интерпретатор сначала создает новый список, что занимает дополнительное время и память, но после создания это уже обыкновенный список. Тоесть в Python 2 итерация по словарям и сетам выполняется дольше, за счет создания нового списка и копирования в него элементов.

В Python 3 эти методы создают объект-представление. Это определенно происходит быстрее чем создание нового списка в Python2. Но итерирование по такому представлению должно происходить немного дольше, чем по списку из-за того что данные в словарях хранятся разреженно (редко, негусто). В подтверждение вышесказанного (Python 3):

```python
>>> l = list(range(1000000))
>>> d = dict.fromkeys(l)
>>> s = set(l)
>>> def iter_list():
...     for i in l:
...         pass
...
>>> def iter_dict():
...     for i in d:
...         pass
...
>>> def iter_set():
...     for i in s:
...         pass
...
>>> timeit.timeit(iter_list, number=1000)
 6.727667486004066
>>> timeit.timeit(iter_dict, number=1000)
 9.293120226997416
>>> timeit.timeit(iter_set, number=1000)
 8.627948219014797
```

## Функции

### Что такое args, kwargs. В каких случаях они требуются

Выражения `*args` и `**kwargs` объявляют в сигнатуре функции. Они означают, что внутри функции будут доступны переменные с именами `args` и `kwargs` (без звездочек). Можно использовать другие имена, но это считается дурным тоном.

`args` – это кортеж, который накапливает позиционные аргументы. `kwargs` – словарь именованных аргументов, где ключ – имя параметра, значение – значение параметра.

**Важно:** если в функцию не передано никаких параметров, переменные будут соответственно равны пустому кортежу и пустому словарю, а не `None`.

Пожалуйста, не путайте кортеж со списком. Следующий вопрос объясняет, почему.

### Почему использовать изменяемые объекты как параметры по-умолчанию плохо. Приведите пример плохого случая. Как исправить

Функция создается однажды при загрузке модуля. Именованные параметры и их дефолтные значения тоже создаются один раз и хранятся в одном из полей объекта-функции.

В нашем примере `bar` равен пустому списку. Список – изменяемая коллекция, поэтому значение `bar` может изменяться от вызова к вызову. Пример:

```python
def foo(bar=[]):
    bar.append(1)
    return bar
foo()
>>> [1]
foo()
[1, 1]
foo()
>>> [1, 1, 1]
```

Хорошим тоном считается указывать параметру пустое неизменяемое значение, например `0`, `None`, `''`, `False`. В теле функции проверять на заполненность и создавать новую коллекцию:

```python
def foo(bar=None):
    if bar is None:
        bar = []
    bar.append(1)
    return bar
foo()
>>> [1]
foo()
>>> [1]
foo()
>>> [1]
```

Сказанное выше актуально в т.ч. для множеств и словарей.

### Можно ли передавать функцию в качестве аргумента другой функции

Можно, функция в Питоне объект первого порядка: допускает присваивание, передачу в функцию, удаление.

### Можно ли объявлять функцию внутри другой функции. Где она будет видна

Можно. Такая функция будет видна только внутри первой функции.

### Что такое лямбды. Каковы их особенности

Это анонимные функции. Они не резервируют имени в пространстве имен. Лямбды
часто передают в функции `map`, `reduce`, `filter`.

Лямбды в Питоне могут состоять только из одного выражения. Используя синтаксис
скобок, можно оформить тело лямбды в несколько строк.

Использовать точку с запятой для разделения операторов нельзя.

### Допустимы ли следующие выражения

- `nope = lambda: pass`
- `riser = lambda x: raise Exception(x)`

Нет, при загрузке модуля выскочит исключение `SyntaxError`. В теле лямбды может
быть только выражение. `pass` и `raise` являются операторами.

### Как передаются значения аргументов в функцию или метод

- [How do I write a function with output parameters (call by reference)?](https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference)
- [Интересности и полезности python. Часть 3](https://habr.com/ru/post/422951/)

В таких языках как C++ есть переменные, хранящиеся на стеке и в динамической памяти. При вызове функции мы помещаем все аргументы на стек, после чего передаём управление функции. Она знает размеры и смещения переменных на стеке, соответственно может их правильно интерпретировать.
При этом у нас есть два варианта: скопировать на стек память переменной или положить ссылку на объект в динамической памяти (или на более высоких уровнях стека).
Очевидно, что при изменении значений на стеке функции, значения в динамической памяти не поменяются, а при изменении области памяти по ссылке, мы модифицируем общую память, соответственно все ссылки на эту же область памяти «увидят» новое значение.

В python отказались от подобного механизма, заменой служит механизм *связывания (assignment)* имени переменной с объектом, например при создании переменной:
`var = "john"`

Интерпретатор создаёт объект «john» и «имя» var, а затем связывает объект с данным именем.
При вызове функции, новых объектов не создаётся, вместо этого в её области видимости создаётся имя, которое связывается с существующим объектом.
Но в python есть изменяемые и неизменяемые типы. Ко вторым, например, относятся числа: при арифметических операциях существующие объекты не меняются, а создаётся новый объект, с которым потом связывается существующее имя. Если же со старым объектом после этого не связано ни одного имени, оно будет удалено с помощью механизма подсчёта ссылок.
Если же имя связано с переменной изменяемого типа, то при операциях с ней изменяется память объекта, соответственно все имена, связанные с данной областью памяти «увидят» изменения.

### Что такое замыкание

Синтаксически это выглядит как функция, находящаяся целиком в теле другой функции. При этом вложенная внутренняя функция содержит ссылки на локальные переменные внешней функции. Каждый раз при выполнении внешней функции происходит создание нового экземпляра внутренней функции, с новыми ссылками на переменные внешней.


### Что такое сопрограмма

Сопрограмма (англ. coroutine) — компонент программы, обобщающий понятие подпрограммы, который дополнительно поддерживает множество входных точек (а не одну, как подпрограмма) и остановку и продолжение выполнения с сохранением определённого положения.
Расширенные возможности генераторов в Python (выражения yield и yield from, отправка значений в генераторы) используются для реализации сопрограмм.
Сопрограммы полезны для реализации асинхронных неблокирующих операций и кооперативной многозадачности в одном потоке без использования функций обратного вызова (callback-функций) и написания асинхронного кода в синхронном стиле.
Python 3.5 включает в себе поддержку сопрограмм на уровне языка. Для этого используются ключевые слова async и await.

## Классы, объекты

### Как получить список атрибутов объекта

Функция `dir` возвращает список строк – полей объекта. Поле `__dict__` содержит словарь вида `{поле -> значение}`.

### Что такое магические методы, для чего нужны

Магическими метода называют методы, имена которых начинаются и заканчиваются двойным подчеркиванием. Магические они потому, что почти никогда не вызываются явно. Их вызывают встроенные функции или синтаксические конструкции. Например, функция `len()` вызывает метод `__len__()` переданного объекта. Метод `__add__(self, other)` вызывается автоматически при сложении оператором `+`.

Перечислим некоторые магические методы:

- `__init__`: инициализатор класса
- `__add__`: сложение с другим объектом
- `__eq__`: проверка на равенство с другим объектом
- `__iter__`: возвращает итератор

### Как в классе сослаться на родительский класс

Функция `super` принимает класс и экземпляр:

```python
class NextClass(FirstClass):
    def __init__(self, x):
        super(NextClass, self).__init__()
        self.x = x
```

### Возможно ли множественное наследование

Да, можно указать более одного родителя в классе потомка.

### Что такое MRO

*MRO* – method resolution order, порядок разрешения методов. Алгоритм, по которому следует искать метод в случае, если у класса два и более родителей.

В классических классах поиск при наследовании по ссылкам на имена осуществляется в следующем порядке:

1. Сначала экземпляр
2. Затем его класс
3. Далее все суперклассы его класса с обходом сначала с глубину, а затем слева направо

Используется первое обнаруженное вхождение. Такой порядок называется DFLR (Обход вглубину и слева направо).

При наследовании классов нового стиля применяется правило MRO (порядок разрешения методов), т.е линеаризованный обход дерева классов, причем вложенный элемент наследования становится доступным в атрибуте `__mro__` данного класса. Такой алгорим называется *C3-линеаризация*. Наследование по правилу MRO осуществляется приблизительно в следующем порядке.

1. Перечисление всех классов, наследуемых экземпляром, по правилу поиска DFLR для классических классов, причем класс включается в результат поиска столько раз, сколько он встречается при обходе.
2. Просмотр в полученном списке дубликатов классов, из которых удаляются все, кроме последнего (крайнего справа) дубликата в списке.

Упорядочение по правилу MRO применяется при наследовании и вызове встроенной функции super(), которая всегда вызывает следующий по правилу MRO класс (относительно точки вызова).

**Пример наследования в неромбовидных иерархаических деревьях:**

```python
class D:          attr = 3      #  D:3   E:2
class B(D)        pass          #   |     |
class E:          attr = 2      #   B    C:1
class C(E):       attr = 1      #    /   /
class A(B, C):    pass          #      A
X = A()                         #      |
print(X.attr)                   #      X

# DFLR = [X, A, B, D, C, E]
# MRO = [X, A, B, D, C, E, object]
# И в версии 3.х и в версии 2.х (всегда) выводит строку "3"
```

**Пример наследования в ромбовидных иерархаических деревьях:**

```python
class D:          attr = 3      #  D:3   D:3
class B(D)        pass          #   |     |
class C(D):       attr = 1      #   B    C:1
class A(B, C):    pass          #    /   /
X = A()                         #      A
print(X.attr)                   #      |
                                #      X

# DFLR = [X, A, B, D, C, D]
# MRO = [X, A, B, C, D, object] (сохраняет только последний дубликат D)
# Выводит строку "1" в версии 3.х, строку "3" в версии 2.х  ("1" если D(object))
```

### Что такое Diamond problem

При ромбовидном наследовании определить метод какого класса должен быть вызван

### Что такое миксины

Миксин (mix-in, анг. “примесь”), паттерн проектирования в ООП, когда в цепочку наследования добавляется небольшой класс-помощник. Например, есть класс

```python
class NowMixin(object):
    def now():
        return datetime.datetime.utcnow()
```

Тогда любой класс, наследованный с этим миксином, будет иметь метод `now()`.

В названия миксинов принято добавлять слово `Mixin`, так как не существует никакого механизма для понимания полноценный это класс или миксин. Миксин технически является самым обычным классом.

### Что такое контекстный менеджер. Как написать свой

В питоне есть оператор `with`. Размещенный внутри код выполняется с особенностью: до и после гарантированно срабатывают события входа в блок `with`и выхода из него. Объект, который определяет эту логику, называется контекстным менеджером.

События входа и выхода из блока определены методами `__enter__` и `__exit__`. Первый срабатывает в тот момент, когда ход исполнения программы переходит внутрь `with`. Метод может вернуть значение. Оно будет доступно низлежащему внутри блока `with` коду.

`__exit__` срабатывает в момент выхода из блока, в т.ч. и по причине исключения. В этом случае в метод будет передана тройка значений `(exc_class, exc_instance, traceback)`.

Самый распространённый контекстный менеджер – класс, порожденный функцией `open`. Он гарантирует, что файл будет закрыт даже в том случае, если внутри блока возникнет ошибка.

Нужно стараться выходить из контекстного менеджера как можно быстрее, чтобы освобождать контекст и ресурсы.

```python
with open('file.txt') as f:
    data = f.read()
process_data(data)
```

Пример реализации своего контекстного менеджера на основе класса:

```python
class Printable:
    def __enter__(self):
        print('enter')

    def __exit__(self, type, value, traceback):
        print('exit')
```

Пример реализации своего контекстного менеджера с использованием встроенной библиотеки contextlib:

```python
from contextlib import contextmanager

@contextmanager
def printable():
    print('enter')
    try:
      yield
    finally:
      print('exit')
```

Контекстные менеджеры также можно использовать для временной замены параметров, переменных окружения, транзакций БД.

### Прокомментировать выражение

`object() == object()`

Всегда ложь, поскольку по умолчанию объекты сравниваются по полю id (адрес в памяти), если только не переопределен метод `__eq__`.

### Что такое \_\_slots\_\_. Плюсы, минусы

Классы хранят поля и их значения в секретном словаре `__dict__`. Поскольку словарь – изменяемая структура, вы можете на лету добавлять и удалять из класса поля. Параметр `__slots__` в классе жестко фиксирует набор полей класса. Слоты используются когда у класса может быть очень много полей, например, в некоторых `ORM`, либо когда критична производительность, потому что доступ к слоту срабатывает быстрее, чем поиск в словаре, или когда в процессе выполнения программы создаются миллионы экземпляров класса, применение `__slots__` позволит сэкономить память.

Слоты активно используются в библиотеках `requests` и `falcon`.

Недостатотк: нельзя присвоить классу поле, которого нет в слотах. Не работают методы `__getattr__` и `__setattr__`.
Решение: включить в `__slots__` элемент `__dict__`

### В чем смысл параметров _value, __value

Поле класса с одним лидирующим подчеркиванием говорит о том, что параметр используется только внутри класса. При этом он доступен для обращения извне. Это ограничение доступа только на уровне соглашения.

```python
class Foo(object):
    def __init__(self):
        self._bar = 42

Foo()._bar
>>> 42
```

Современные IDE вроде `PyCharm` подсвечивают обращение к полю с подчеркиванием, но ошибки в процессе исполнения не будет.

Поля с двойным подчеркиванием доступны внутри класса, но недоступны извне. Это достигается хитрым приемом: интерпретатор назначает таким полям имена вида `_<ClassName>__<fieldName>`. Описанный механизм называется *name mangling* или *name decoration*

```python
class Foo(object):
    def __init__(self):
        self.__bar = 42

Foo().__bar
>>> AttributeError: 'Foo' object has no attribute '__bar'
Foo()._Foo__bar
>>> 42
```

### Что такое \_\_new\_\_. И чем он отличается от \_\_init\_\_. В какой последовательности они выполняются

Основное различие между этими двумя методами состоит в том, что `__new__` обрабатывает создание объекта, а `__init__` обрабатывает его инициализацию.

`__new__` вызывается автоматически при вызове имени класса (при создании экземпляра), тогда как `__init__` вызывается каждый раз, когда экземпляр класса возвращается `__new__`, передавая возвращаемый экземпляр в `__init__` в качестве параметра `self`, поэтому даже если вы сохранили экземпляр где-нибудь глобально/статически и возвращали его каждый раз из `__new__`, для него все-равно будет каждый раз вызываться `__init__`.

Из вышесказанного вытекает что сначала вызывается `__new__`, а потом `__init__`

### Что такое и чем отличается old-style от new-style classes

Классы нового стиля (3.х доступны только они, в 2.х при наследовании от `object`) отличаются от классических (по умолчанию в 2.х) следующими особенностями:

- Причиной создания new style classes послужила идея убрать отличие встроенных типов от определённых пользователем типов. [Unifying types and classes in Python 2.2](https://www.python.org/download/releases/2.2.3/descrintro/)
- Ромбовидные шаблоны множественного наследования имеют несколько иной порядок поиска. Поиск в них осуществляется скорее в ширину, чем в глубину, перед тем как начать обход снизу вверх (см. вопрос про MRO)
- Классы теперь обозначают типы, а типы являются классами. Так, в результате вызова встроенной функции `type(I)` возвращается класс, из которого получается экземпляр, а не тип экземпляра, что, как правило, равнозначно выражению `I.__class__`. От класса `type` могут быть произведены подклассы для создания специальных классов. Все классы наследуют от встроенного класса `object`, предоставляющего по умолчанию небольшой набор методов

### Что такое утиная типизация

Неявная типизация, латентная типизация или *утиная типизация* (англ. Duck typing) – вид динамической типизации, применяемой в некоторых языках программирования (Perl, Smalltalk, Python, Objective-C, Ruby, JavaScript, Groovy, ColdFusion, Boo, Lua, Go, C#), когда границы использования объекта определяются его текущим набором методов и свойств, в противоположность наследованию от определённого класса.
То есть считается, что объект реализует интерфейс, если он содержит все методы этого интерфейса, независимо от связей в иерархии наследования и принадлежности к какому-либо конкретному классу.

Утиная типизация решает такие проблемы иерархической типизации, как:

- невозможность явно указать (путём наследования) на совместимость интерфейса со всеми настоящими и будущими интерфейсами, с которыми он идейно совместим;
- экспоненциальное увеличение числа связей в иерархии типов при хотя бы частичной попытке это сделать.

## Модули, пакеты

### Что такое модуль

Модуль – функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом или поименованной непрерывной её части. Модули позволяют разбивать сложные задачи на более мелкие в соответствии с принципом модульности.
Файл, который содержит исходный код на языке Python, является модулем.
Модули могут объединяться в пакеты и, далее, в библиотеки.

### Как можно получить имя модуля

Название модуля доступно в его глобальной переменной `__name__`. Если модуль не импортирован, а запущен как скрипт, то `__name__` устанавливается в значение `"__main__"`.

### Что такое модульное программирование

Модульное программирование – это организация программы как совокупности небольших независимых блоков, называемых модулями, структура и поведение которых подчиняются определенным правилам. Использование модульного программирования позволяет упростить тестирование программы и обнаружение ошибок. Аппаратно-зависимые подзадачи могут быть строго отделены от других подзадач, что улучшает мобильность создаваемых программ.

### Как Python ищет модули при импорте

При импортировании модулей интерпретатор Python ищет их в директориях и архивах, список которых доступен как для чтения, так и для модификации в виде переменной path встроенного модуля sys.
По умолчанию sys.path состоит из директории с запускаемым скриптом, содержимого переменной окружения PYTHONPATH и стандартного расположения модулей, специфичного для конкретной платформы и интерпретатора.

### Что такое пакет

Модули могут объединяться в пакеты. Пакеты служат как пространства имён для модулей и способ их структурирования.
Любой пакет является модулем, но не каждый модуль является пакетом.
Как правило, модули представляются в виде файлов, а пакеты – каталогов в файловой системе (но не всегда).
Для того, чтобы каталог был пакетом, в нём должен находиться файл `__init__.py`. Он автоматически выполняется при импортировании соответствующего модуля и может содержать определённые действия для инициализации или быть пустым.

### Что вы можете сказать о конструкции import package.item

При использовании оператора from package import item, item может быть пакетом, модулем или любым именем, описанным в пакете. При использовании оператора import package.item, item должен быть модулем или пакетом.

## Исключения

### Что такое обработка исключений

Обработка *исключительных ситуаций* или обработка *исключений* (англ. exception handling) — механизм языков программирования, предназначенный для описания реакции программы на ошибки времени выполнения и другие возможные проблемы (исключения), которые могут возникнуть при выполнении программы и приводят к невозможности (бессмысленности) дальнейшей отработки программой её базового алгоритма.

Код на Python может сгенерировать исключение при помощи ключевого слова raise. После него указывается объект исключения. Также можно указать класс исключения, в таком случае будет автоматически вызван конструктор без параметров. raise может выбрасывать в качестве исключений только экземпляры класса BaseException и его наследников, а также (в Python 2) экземпляры классов старого типа.

### Для чего могут применять конструкцию try finally без except

```python
try:
    # some code
finally:
    # some code
```

Если в блоке try произойдет ошибка, то блок finally все-равно будет выполнен и внутри него можно будет сделать "cleanup", например.

### Как правильно по-разному обрабатывать исключения

Блоки except обрабатываются сверху вниз и управление передаётся не больше, чем одному обработчику. Поэтому при необходимости по-разному обрабатывать исключения, находящиеся в иерархии наследования, сначала нужно указывать обработчики менее общих исключений, а затем – более общих.
Также именно поэтому *bare except* может быть только последним (иначе SyntaxError). Причём если сначала расположить обработчики более общих исключений, то обработчики менее общих будут просто проигнорированы.

### Что будет если ошибку не обработает блок except

Если ни один из заданных блоков except не перехватывает возникнувшее исключение, то оно будет перехвачено ближайшим внешним блоков try/except, в котором есть соответствующий обработчик. Если же программа не перехватывает исключение вообще, то интерпретатор завершает выполнение программы и выводит информацию об исключении в стандартный поток ошибок sys.stderr.
Из этого правила есть два исключения:

- Если исключение возникло в деструкторе объекта, выполнение программы не завершается, а в стандартный поток ошибок выводится предупреждение “Exception ignored” с информацией об исключении.
- При возникновении исключения SystemExit происходит только завершение программы без вывода информации об исключении на экран (не касается предыдущего пункта, в деструкторе поведение данного исключения будет таким же, как и остальных).

### Что делать если нужно перехватить исключение, выполнить действия и опять возбудить это же исключение

Для того, чтобы в обработчике исключения выполнить определённые действия, а затем передать исключение дальше, на один уровень обработчиков выше (то есть, выбросить то же самое исключение ещё раз), используется ключевое слово raise без параметров.

```python
try:
    1 / 0
except ZeroDivisionError:
  # some logic
  raise
```

### Что такое сцепление исключений

В Python 3 при возбуждении исключения в блоке except, старое исключение сохраняется в атрибуте данных `__context__` и если новое исключение не обработано, то будет выведена информация о том, что новое исключение возникло при обработке старого («During handling of the above exception, another exception occurred:»).
Также, можно связывать исключения в одну цепь или заменять старые новыми. Для этого используется конструкция `raise новое_исключение from старое_исключение` либо `raise новое_исключение from None`.
В первом случае указанное исключение сохраняется в атрибуте `__cause__` и атрибут `__suppress_context__` (который подавляет вывод исключения из `__context__`) устанавливается в True. Тогда, если новое исключение не обработано, будет выведена информация о том, что старое исключение является причиной нового («The above exception was the direct cause of the following exception:»).
Во втором случае `__suppress_context__` устанавливается в True и `__cause__` в None. Тогда при выводе исключения оно, фактически, будет заменено новым (хотя старое исключение всё ещё хранится в `__context__`).

В Python 2 нет сцепления исключений. Любое исключение, выброшенное в блоке except, заменяет старое.

### Зачем нужен блок else

Блок else выполняется, если в процессе выполнения блока try не возникло исключений. Он предназначен для того, чтобы отделить код, который может вызвать исключение, которое должно быть обработано в данном блоке try/except, от кода, который может вызвать исключение того же класса, которое должно быть перехвачено на уровне выше, и свести к минимуму количество операторов в блоке try.

### Что можно передать в конструктор исключения

Исключения могут принимать в качестве параметра конструктора любые неименованные аргументы. Они помещаются в атрибуте данных args в виде кортежа (неизменяемого списка). Чаще всего используется один строковой параметр, который содержит сообщение об ошибке. Во всех исключениях определён метод `__str__`, который по умолчанию вызывает str(self.args).
В Python 2 также имеется атрибут message, в который помещается `args[0]`, если `len(args) == 1`.

### Какие есть классы исключений

- Базовые:
  - BaseException – базовый класс для всех исключений.
  - Exception – класс-наследник BaseException, базовый класс для для всех стандартных исключений, которые не указывают на обязательное завершение программы, и всех пользовательских исключений.
  - StandardError (Python 2) – базовый класс для всех встроенных исключений, кроме StopIteration, GeneratorExit, KeyboardInterrupt и SystemExit.
  - ArithmeticError – базовый класс для всех исключений, связанных с арифметическими операциями.
  - BufferError – базовый класс для исключений, связанных с операциями над буфером.
  - LookupError – базовый класс для исключений, связанных с неверным ключом или индексом коллекции.
  - EnvironmentError (Python 2) – базовый класс для исключений, связанных с ошибками, которые происходят вне интерпретатора Python. В Python 3 его роль выполняет OSError.
- Некоторые из конкретных стандартных исключений:
  - AssertionError – провал условия в операторе assert.
  - AttributeError – ошибка обращения к атрибуту.
  - FloatingPointError – ошибка операции над числами с плавающей точкой.
  - ImportError – ошибка импортирования модуля или имени из модуля.
  - IndexError – неверный индекс последовательности (например, списка).
  - KeyboardInterrupt – завершение программы путём нажатия Ctrl+C в консоли.
  - MemoryError – нехватка памяти.
  - NameError – имя не найдено.
  - NotImplementedError – действие не реализовано. Предназначено, среди прочего, для создания абстрактных методов.
  - OSError – системная ошибка.
  - OverflowError – результат арифметической операции слишком большой, чтобы быть представлен.
  - RuntimeError – общая ошибка времени выполнения, которая не входит ни в одну из категорий.
  - SyntaxError – ошибка синтаксиса.
  - IndentationError – подкласс SyntaxError – неверный отступ.
  - TabError – подкласс IndentationError – смешанное использование символов табуляции и пробелов.
  - SystemError – некритичная внутренняя ошибка интерпретатора. При возникновении данного исключения следует оставить отчёт об ошибке на сайте [bugs.python.org](https://bugs.python.org/)
  - SystemExit – исключение, которое генерируется функцией sys.exit(). Служит для завершения работы программы.
  - TypeError – ошибка несоответствия типов данных.
  - UnboundLocalError – подкласс NameError – обращение к несуществующей локальной переменной.
  - ValueError – генерируется, когда функции или операции передан объект корректного типа, но с некорректным значением, причём эту ситуацию нельзя описать более точным исключением, таким как IndexError.
  - ZeroDivisionError – деление на ноль.

### В каких случаях можно обработать SyntaxError

Ошибка синтаксиса возникает, когда синтаксический анализатор Python сталкивается с участком кода, который не соответствует спецификации языка и не может быть интерпретирован.
Поскольку, в случае синтаксической ошибки в главном модуле, она возникает до начала выполнения программы и не может быть перехвачена, учебник для начинающих в документации языка Python даже разделяет синтаксические ошибки и исключения. Однако SyntaxError – это тоже исключение, которое наследуется от Exception, и существуют ситуации, когда оно может возникнуть во время исполнения и быть обработано, а именно:

- ошибка синтаксиса в импортируемом модуле;
- ошибка синтаксиса в коде, который представляется строкой и передаётся функции eval или exec.

### Можно ли создавать собственные исключения

Можно. Они должны быть наследниками класса Exception. Принято называть исключения так, что имя их класса заканчивается словом Error.

### Для чего нужны предупреждения (warnings) и как создать собственное

Предупреждения обычно выводятся на экран в ситуациях, когда не гарантируется ошибочное поведение и программа, как правило, может продолжать работу, однако пользователя следует уведомить о чём-либо.
Базовым классом для предупреждений является Warning, который наследуется от Exception.
Базовым классом-наследником Warning для пользовательских предупреждений является UserWarning.

### Для чего нужен модуль warning

В модуле warning собраны функции для работы с предупреждениями.
Основной является функция warn, которая принимает один обязательный параметр message, который может быть либо строкой-сообщением, либо экземпляром класса или подкласса Warning (в таком случае параметр category устанавливается автоматически) и два опциональных параметра: category (по умолчанию – UserWarning) – класс предупреждения и stacklevel (по умолчанию – 1) – уровень вложенности функций, начиная с которого необходимо выводить содержимое стека вызовов (полезно, например, для функций-обёрток для вывода предупреждений, где следует задать stacklevel=2, чтобы предупреждение относилось к месту вызова данной функции, а не самой функции).

## Декораторы

- [Понимаем декораторы в Python'e, шаг за шагом. Шаг 1](https://habr.com/ru/post/141411/)
- [Понимаем декораторы в Python'e, шаг за шагом. Шаг 2](https://habr.com/ru/post/141501/)

### Что такое декораторы. Зачем нужны

Декоратор в широком смысле - паттерн проектирования, когда один объект изменяет поведение другого. В Питоне декоратор, как правило, это функция A, которая принимает функцию B и возвращает функцию C. При этом функция C задействует в себе функцию B.

Задекорировать функцию значит заменить ее на результат работы декоратора.

### Что может быть декоратором. К чему может быть применен декоратор

Декоратором может быть любой вызываемый объект: функция, лямбда, класс, экземпляр класса. В последнем случае определите метод `__call__`.

Применять декоратор можно к любому объекту. Чаще всего к функциям, методам и классам. Декорирование встречается настолько часто, что под него выделен особый оператор `@`.

```python
def auth_only(view):
    ...

@auth_only
def dashboard(request):
    ...
```

Если бы оператора декорирования не существовало, мы бы записали код выше так:

```python
def auth_only(view):
    ...

def dashboard(request):
    ...

dashboard = auth_only(dashboard)
```

### Что будет, если декоратор не возвращает ничего

Если в теле функции нет оператора `return`, вызов вернет `None`. Помним, результат декоратора замещает декорируемый объект. В нашем случае декоратор вернет `None` и функция, которую мы декорируем, тоже станет `None`. При попытке вызвать ее после декорирования получим ошибку "NoneType is not callable".

### В чем отличие \@foobar от \@foobar()

Первое -- обычное декорирование функцией foobar.

Второй случай -- декорирование функцией, которую вернет вызов foobar. По-другому это называется параметрический декоратор или фабрика декораторов. См. следующий вопрос.

### Что такое фабрика декораторов

Это функция, которая возвращает декоратор. Например, вам нужен декоратор для проверки прав. Логика проверки одинакова, но прав может быть много. Чтобы не плодить копипасту, напишем фабрику декораторов.

```python
from functools import wraps

def has_perm(perm):
    def decorator(view):
        @wraps(view)
        def wrapper(request):
            if perm in request.user.permissions:
                return view(request)
            else:
                return HTTPRedirect('/login')
        return wrapper
    return decorator

@has_perm('view_user')
def users(request):
    ...
```

### Зачем нужен wraps

`wraps` - декоратор из стандартной поставки Python, модуль `functools`. Он назначает функции-врапперу те же поля `__name__`, `__module__`, `__doc__`, что и у исходной функции, которую вы декорируете. Это нужно для того, чтобы после декорирования функция-враппер в стектрейсах выглядела как декорируемая функция.

## Метаклассы

- [Метаклассы в Python: что это такое и с чем его едят](https://proglib.io/p/metaclasses-in-python/)
- [Метаклассы в Python](https://habr.com/ru/post/145835/)

### Что такое метаклассы

Метакласс это «штука», которая создаёт классы.

Мы создаём класс для того, чтобы создавать объекты, так? А классы являются объектами. Метакласс это то, что создаёт эти самые объекты.

### Что такое type. Как работает поиск метакласса при создании объекта

`type` это метакласс, который Питон внутренне использует для создания всех классов.

Когда вы пишете:

```python
class Foo(Bar):
  pass
```

Питон делает следующее:

- Есть ли у класса Foo атрибут `__metaclass__`?
- Если да, создаёт в памяти объект-класс с именем Foo, используя то, что указано в `__metaclass__`.
- Если Питон не находит `__metaclass__`, он ищет `__metaclass__` в родительском классе Bar и попробует сделать то же самое.
- Если же `__metaclass__` не находится ни в одном из родителей, Питон будет искать `__metaclass__` на уровне модуля.
- И если он не может найти вообще ни одного `__metaclass__`, он использует `type` для создания объекта-класса.

### Как работают метаклассы

- перехватить создание класса
- изменить класс
- вернуть модифицированный

### Зачем вообще использовать метаклассы

Основное применение метаклассов это создание API. Типичный пример — Django ORM.

Она позволяет написать что-то в таком духе:

```python
class Person(models.Model):
  name = models.CharField(max_length=30)
  age = models.IntegerField()
```

Однако если вы выполните следующий код:

```python
guy = Person(name='bob', age='35')
print guy.age

```

вы получите не `IntegerField`, а `int`, причём значение может быть получено прямо из базы данных.

Это возможно, потому что `models.Model` определяет `__metaclass__`, который сотворит некую магию и превратит класс `Person`, который мы только что определили простым выражением в сложную привязку к базе данных.

Django делает что-то сложное выглядящее простым, выставляя наружу простой API и используя метаклассы, воссоздающие код из API и незаметно делающие всю работу.

## Ввод-Вывод

### Что такое файловый объект

Файловый объект – объект, предоставляющий файл-ориентированный API (методы `read()`, `write()` и т.д.) для доступа к ресурсу. В зависимости от способа создания, файловый объект может предоставлять доступ к реальному файлу на диске или другому виду устройства хранения или передачи данных (стандартные потоки ввода/вывода, буферы в памяти, сокеты и т.д.).
Файловые объекты также называют потоками.
Файловые объекты являются контекстными менеджерами.

### Какие есть виды файловых объектов

На уровне типов данных в Python 2 нет отличия между текстовыми и бинарными файлами. При открытии можно указать текстовый либо бинарный режим, но это влияет только на преобразования концов строк при выполнении под ОС Windows, а под Unix-системами, где преобразования концов строк не требуются, не влияет ни на что.

В Python 3 существует три вида файловых объектов: текстовые файлы (text files), «обычные» (небуферизированные) бинарные файлы (raw binary files) и буферизированные бинарные файлы (buffered binary files). Разные виды потоков представляются соответствующими классами модуля io.

Модуль io был обратно портирован в последние версии Python 2, поэтому в Python 2 также при желании можно использовать систему ввода-вывода, аналогичную Python 3.

### В чем отличие текстовых и бинарных файлов

Текстовые файлы записывают и считывают данные типа str и автоматически выполняют преобразования кодировок и концов строк. Бинарные файлы записывают и считывают данные типов bytes и bytearray и не производят никаких манипуляций с данными: всё записывается и считывается в таком же виде, как и сохраняется.

### Как пользоваться функцией open

Сигнатура функции в Python 2: `open(file, mode='r', buffering=-1)`.

Сигнатура функции в Python 3 (и в Python 2 при использовании функции io.open):
`open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)`.

Основные параметры:

- file – имя файла или файловый дескриптор;
- mode – режим открытия файла;
- encoding – кодировка файла;
- buffering – использовать ли буферизацию: отрицательное число (по умолчанию, указывать явно не нужно) – стандартное значение для данного вида файлового объекта, 0 – отключить буферизацию, 1 – построчная буферизация (для текстовых файлов), другое значение – включить буферизацию и задать соответствующий размер буфера.

Обязательным параметром является только первый. Чаще всего функция `open()` используется с двумя параметрами.

mode может начинаться с символов «r» (чтение), «w» (запись, очищает файл, если уже существует), «x» (исключительное создание, неуспешно, если файл уже существует), «a» (добавление, запись в конец файла).
Также параметр mode может иметь вторую букву для определения типа файла: «t» для текстового (по умолчанию) и «b» для бинарного.
Также можно добавить символ «+» для открытия в режиме чтения и записи одновременно. Порядок последних двух символов не имеет значения: «rb+» и «r+b» задают один и тот же режим.

### Для чего необходимо закрывать файлы

После окончания работы с файлом следует обязательно его закрыть при помощи метода `close()`, особенно если он был открыт для записи. При использовании буферизированного вывода данные, которые записываются в файл, не попадают в него сразу, а записываются в буфер.
Содержимое буфера записывается в файл при его заполнении или вызове методов `flush()` или `close()`. Кроме того, если файл открыт для записи, он будет заблокирован для открытия для записи другими процессами до момента закрытия. Все открытые файлы автоматически закрываются при удалении соответствующих файловых объектов из памяти сборщиком мусора интерпретатора Python и при завершении работы самого интерпретатора, однако следует держать файлы открытыми минимально требуемое время.

### Что делают методы tell и seek

Метод `tell()` возвращает текущую позицию считывания/записи в файле. Метод `seek(offset, whence)` устанавливает её. Параметр offset задаёт отступ, а whence – точку, от которой данный отступ считается: `io.SEEK_SET(0)` – начало файла, `io.SEEK_CUR(1)` – текущая позиция, `io.SEEK_END(2)` – конец файла.

### Что делают StringIO и BytesIO

Классы `io.StringIO` и `io.BytesIO`, представляют собой потоки для считывания и записи в строки или байтовые строки в памяти. Они могут быть использованы для того, чтобы использовать строки и байтовые строки в качестве текстовых и бинарных файлов.

### Являются ли файловые объекты контекстными менеджерами

Да, являются

### Что такое сериализация

Сериализация – это процесс сохранения объектов в двоичном или строковом виде для хранения, передачи и восстановления. Обратный процесс называется десериализацией. Термины-синонимы маршалинг/анмаршалинг

### json.dumps / json.dump , json.loads / json.load

Функция dumps модуля json сохраняет JSON-представление объекта в строку. Функция dump – в текстовый файл.
Функция loads модуля json загружает объект из строки. Функция load – из текстового файла.

### Что делать если нужно сериализовать данные, которые не поддерживаются стандартным модулем json

Можно использовать pickle или расширить классы JSONEncoder и JSONDecoder.

### pickle.dumps / pickle.dump, pickle.loads / pickle.load

Функции dump, dumps, load и loads модуля pickle аналогичны по своему предназначению соответствующим функциям модуля JSON, но работают с байтовыми строками и бинарными файлами.

Опциональный параметр protocol данных функций задаёт версию протокола. Последнюю версию протокола можно получить как константу pickle.HIGHEST_PROTOCOL, текущую версию по умолчанию – pickle.DEFAULT_PROTOCOL.

На момент написания данного текста существует пять версий протокола:

- 0 и 1 – это устаревшие версии, которые использовались в Python 2.2 и ниже;
- 2 – это основная версия протокола для Python 2;
- 3 – версия протокола, которая появилась в Python 3, стандартный протокол в Python 3 на текущий момент, не может быть десериализован в Python 2;
- 4 – версия протокола, появившаяся в Python 3.4, поддерживает очень большие по объёму памяти объекты, поддерживает большее количество типов объектов, добавлены некоторые оптимизации.
- 5 - версия протокола, появившаяся в Python 3.8. Он добавляет поддержку данных out-of-band и ускорение для in-band данных. PEP 574 более подробно описывает изменения.

---

### Менеджер контекста, зачем он нужен?

Синтаксис оператора контекста with:
```
    with EXPRESSION as TARGET:
        SUITE
        
with open("demo_1.txt", "w") as file:
    file.write("1!")
    
```
Менеджером контекста называется объект, реализующий методы __enter__() и __exit__().  Наиболее часто используется  с открытием файла для чтения или записи, а также создание соединения при работе с базами данных. 

подробнее - [Контекстный менеджер with в Python](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/kontekstnyj-menedzher-with/#protocol)

[Context manager в рамках языка Python / Хабр](https://habr.com/ru/companies/auriga/articles/724030/)

---
### Dunder method (ака магические)
**Dunder method** - магические методы или методы двойного подчеркивания - это способ, которым создатели классов настраивают экземпляры класса для поддержки определенных режимов поведения, поддерживаемых Python.


![qownnotes-media-OtfQYS](media/qownnotes-media-OtfQYS.png)

подробнее - [Руководство по магическим методам в Питоне / Хабр](https://habr.com/ru/articles/186608/)

[Магические методы Python, о которых вы, возможно, не слышали](https://dev-gang.ru/article/magiczeskie-metody-python-o-kotoryh-vy-vozmozhno-ne-slyshali-woy63ch626/)

---
### Декораторы
Декоратор - это функция, которая позволяет обернуть другую функцию для расширения её функциональности без непосредственного изменения её кода.

```
def outer(func):
    def wrapper(*args, **kwargs):
        print('код до декоратора')
        return func(*args, **kwargs)
    return wrapper
```
Задача: Написать параметризированный декоратор которые делает несколько попыток в случае возникнования ошибки по время выполнения. 

```
def outer(*dargs, **dkwargs): - параметры декоратора
    def inner(func): - декорированная функция
        def wrapper(*args, **kwargs): - параметры функции
            attempts = dkwargs.get("attempts")
            while attempts > 0:
                try:
                    return func(*args, *kwargs)
                except Exception as err:
                    print(f'Error {err}')
                    attempts -= 1
        return wrapper
    return inner

@outer(attempts=5)
def div(a, b):
    return a / b

div(5, 0)
    
или без синт. сахара

div = outer(attempts=5)(div)

```
Декораторы можно применять и на класс, будет выполнятся при создании экземпляпа класса.

#### иерархия выполнения декораторов (несколько @  у функции). 

Сначала интерпретатор высматривает все декораторы, которые принимают какие-либо параметры, такие декораторы в приоритете выполнения и они будут выполняться сверху вниз по очереди.
После того как все декораторы с параметрами в порядке очереди были выполнены далее идут декораторы без параметров (также сверху вниз один за другим).

YT ролики - [РАЗБИРАЕМСЯ С ДЕКОРАТОРАМИ В PYTHON С НУЛЯ (ЧАСТЬ 1) - YouTube](https://www.youtube.com/watch?v=GhgmInoT54c&list=PLlKID9PnOE5h8VJyEiEd_Uv_-tt9KX7MD&index=1)

---

### Что такое интерпретируемый язык? Что такое интерпретатор и как он работает в Python?

Интерпретатор - это программа, которая конвертирует ваши инструкции, написанные на Python, в байт-код и выполняет их. По сути интерпретатор — это программный слой между вашим исходным кодом и железом.

Существует 2 типа интерпретаторов:

1. Простой интерпретатор. Он берет одну инструкцию, транслирует и сразу выполняет ее, а затем берет следующую инструкцию.
2. Интерпретатор компилирующего типа. Это система из компилятора и интерпретатора. Компилятор переводит исходный код программы в промежуточное представление (байт-код), а интерпретатор (виртуальная машина) выполняет этот байт-код.

Интерпретатор транслирует (переводит) исходные инструкции вашей программы в байт-код (низкоуровневое, платформонезависимое представление исходного текста). Такая трансляция необходима в первую очередь для повышения скорости. 
Если Python-интерпретатор обладает правом записи, он будет сохранять байт-код в виде файла с расширением *.pyc . Если исходный текст программы не изменился с момента последней компиляции, при следующем запуске вашей программы, Python сразу загрузит файл .pyc, минуя этап компиляции.

Как только байт-код скомпилирован, он отправляется на виртуальную машину Python (PVM). Здесь выполняется байт-код на PVM. Если во время этого выполнения возникает ошибка, то выполнение останавливается с сообщением об ошибке. PVM является частью Python-интерпретатора. По сути это просто большой цикл, который выполняет перебор инструкций в байт-коде и выполняет соответствующие им операции.

#### CPython и альтернативы

**CPython**
  - Интерпретатор компилирующего типа (благодаря этому достигается большее быстродействие выполнения программ).
  - Считается эталонной реализацией языка Python.
  - Написан на C.
  - Исходный код CPython находится в открытом доступе.
  - Его разработка ведётся группой разработчиков под руководством Гвидо ван Россума — создателя Python.

**Jython**.

Основная цель данный реализации — тесная интеграция с языком Java. Работает следующим образом:
  - Java-классы выполняют компиляцию программного кода на языке Python в байт-код Java.
Полученный байт-код запускается на виртуальной машине Java (JVM).
  - Jython позволить Python-программам управлять Java-приложениями. Во время выполнения такая программа ведет себя точно так же, как настоящая программа на языке Java.

**IronPython**

Предназначена для обеспечения интеграции Python-программ с C# приложениями на Microsoft .NET Framework или Mono. Принцип работы такой же, как и у Jython.

**PyPy**

PyPy — это интерпретатор Python, написанный на Python (если быть точнее, то на RPython).
Особенностью PyPy является использование трассирующего JIT-компилятора (just-in-time), который на лету транслирует некоторые элементы в машинный код. Благодаря этому, при выполнении некоторых операций PyPy обгоняет CPython в несколько раз. Но плата за такую производительность — более высокое потребление памяти.


подробнее - [Как работает Python — интерпретатор, байт-код, PVM](https://pythonchik.ru/osnovy/kak-rabotaet-python-interpretator)

---

###  Что такое статическая и динамическая типизация и в чем это проявляется в Python?


###  В каких случаях лучше использовать кортеж, а в каких - список?
###  Как вы объясните человеку, что такое множество?
###  Что такое словари и как они работают?
###  Как работают типы данных хэшмап, связанный список, двусвязный список, массив?
###  Что такое О (о-большое)? Зачем и как используется?
###  Какая сложность вставки, извлечения, поиска элементов в словаре и списке?
###  Что такое функции и зачем они нужны?
###  Какие бывают аргументы у функций?
###  Что такое распаковка коллекций?
###  Что такое исключения? Какие они бывают? Как их использовать?
###  Что такое ООП? На каких концепциях стоит ООП?
###  Объяснить понятие класса и объекта (экземпляра).
###  Что такое инкапсуляция? Накодить пример.
###  Что такое наследование? Накодить пример.
###  Бывает ли в Python множественное наследование? Как ты относишься к этому факту?
###  Если у нескольких классов-родителей есть методы с одинаковыми названиями, то какой из них будет вызван в наследнике?
###  Что такое полиморфизм? Накодить пример.
###  Что такое staticmethod? 
###  Чем staticmethod отличается от простой функции? 
###  Когда будем использовать staticmethod, а когда простую функцию?
###  Что такое classmethod? В чём его особенности? Когда применяется?
###  Что такое магические методы и за что они отвечают?
###  Что такое конструктор объектов в Python и из чего он состоит и как работает?
###  Почему в методе __init__ есть аргумент self?
###  Что такое приватные и защищенные атрибуты? Как они работают?
### Можно ли получить доступ к приватным атрибутам в Python?
###  Какие способы конкурентного выполнения программ в Python бывают?
###  Что такое GIL и как он работает?
###  В каких случаях GIL не работает?
###  Что такое сборщик мусора и как он работает?
###  Что такое потоки и процессы? Чем отличается поток от процесса?
###  Что такое системный вызов fork?
###  Какие существуют способы синхронизации процессов и потоков?
###  Как передавать информацию из одного процесса в другой?
###  Что такое эффект гонок? Как с ним бороться?
###  Что такое асинхронность?
###  Что такое event loop и как он работает?
###  Сколько потоков и процессов работает во время асинхронного выполнения кода?
###  Для каких задач стоит использовать потоки, для каких - процессы, а для каких - асинхронность?








































    
    

