Тестирование
========================

## Что такое тестирование и зачем оно нужно?

Тестирование — это проверка соответствия программы требованиям, осуществляемая путём наблюдения за её работой в специальных, искусственно созданных ситуациях, выбранных определённым образом.


Тестировать код важно, потому что:

1. даже если баги не нашли, это помогает разработчику быть уверенным в качестве кода;
2. с помощью автотестов уменьшается количество регрессионных ошибок — багов, которые обнаруживаются в уже протестированном коде. Бывает, что после внесения изменений в программу перестает работать кусок кода, который не менял

---
## Какие виды тестов вы знаете? Что каждый из видов тестов подразумевает под собой?

Тестирование смело делится на несколько уровней глубины. Наиболее показательная классификация по уровням тестирования в данном случае такая:

Системное тестирование – тестирование полностью интегрированного программного приложения
Интеграционное тестирование – тестирование интегрированных групп программных модулей
Модульное тестирование или юнит-тестирование – тестирование отдельных модулей исходного кода приложения

[Мир Python: введение в тестирование | Python для продвинутых](https://ru.hexlet.io/courses/advanced_python/lessons/python_testing_introduction/theory_unit)

---
## Какие библиотеки для написания тестов используются?
В Python для модульного тестирования применяют PyUnit, PyTest, Nose.


---
## Что такое фикстура в pytest?

Фикстуры в pytest представляют собой функции, которые можно использовать при автоматизации тестирования для решения следующих задач:

1. выполнение действий до проведения тестирования (например, настройка тестового окружения, создание тестовых данных, различные сетевые подключения, открытие файла и пр.);

2. выполнение действий после проведения тестирования (например, удаление временных данных, формирование отчета, отключение сетевых подключений, закрытие файлов и пр.);

3. вынос типовых действий в отдельные компоненты, что позволяет избежать дублирования кода и улучить его поддержку и читаемость;

4. корректно выполнять необходимые завершающие действия (финализация), даже в случаи ошибок в тестовых сценариях или при их прерывании.


test fixtures (на сленге — «фикстуры») — это фиксированные объекты и данные для выполнения тестов. 
Перед началом теста в коде создаются объекты и данные, на которых будет проведено тестирование. Например:
- состояние базы данных,
- набор переменных среды,
- набор файлов с необходимым содержанием.

[Шпаргалка: fixture в pytest / Хабр](https://habr.com/ru/articles/731296/)

---
### Пирамида тестирования

Пирамида тестирования, также часто говорят уровни тестирования, это группировка тестов по уровню детализации и их назначению. 

Пирамиду разбивают на 4 уровня (снизу вверх), например, по ISTQB (см. wiki):

4. модульное тестирование (юнит);
3. интеграционное тестирование;
2. системное тестирования;
1. приемочное тестирование.

[Подробнее про пирамиду тестирования / Хабр](https://habr.com/ru/articles/672484/)

### Что такое mocking

- [Модуль Mock: макеты-пустышки в тестировании](https://habr.com/ru/post/141209/)

Mock на английском значит «имитация», «подделка». Принцип его работы простой: если нужно тестировать функцию, то всё, что не относится к ней самой (например, чтение с диска или из сети), можно подменить макетами-пустышками. При этом тестируемые функции не нужно адаптировать для тестов: Mock подменяет объекты в других модулях, даже если код не принимает их в виде параметров. То есть, тестировать можно вообще без адаптации под тесты.

### Что делать, если тестируемая функция использует удалённое подключение к внешним сервисам, которое иногда видает ошибку таймаута, 404 и им подобные

Если мы говорим про юнит тесты, то они не должны вызывать внешние ресурсы, то есть делать http запросы и тд. Следовательно нужно либо замокать http-клиент, который использует функция для вызова сервиса, либо, что обычно является лучшим решением, передавать то что вызывает этот сервис в функцию зависимостью (если конечно мы не тестируем сам клиент для вызова сервиса).

### Что делать, если тестируемая функция занимает много времени на выполнение повторяющихся операций внутри неё

Например, внутри цикл от 1 до 1000000, где что-то считывается, записывается, рассчитывается.

Допустим у этой функции не проблем с декомпозицией - это функция, которая выполняет одно действие и разбивать ее на несколько других не имеет никакого смысла. В таком случае я бы:

- сделал бы возможным заменить из теста верхнюю границу цикла (через параметр или мокая константу, настройку и т.д.)
- если функция вызывает для расчетов другую ресурсоёмкую функцию, стороннюю или из своей кодовой базы, то возможно замокал бы ее и проверил что она вызывается с нужными параметрами
- по возможности подготовил бы для теста такой входящий набор данных, при котором она выполялась быстро

Если функция не соответсвует условиям, описанным в первом предложении, следовало бы сначала заняться ее декомпозицией.

### Какие вы знаете виды тестов
  
- [Пирамида тестов на практике](https://habr.com/ru/post/358950/)
- [Тесты, которые должен писать разработчик](https://medium.com/front-end-in-regions-grodno/%D1%82%D0%B5%D1%81%D1%82%D1%8B-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%B4%D0%BE%D0%BB%D0%B6%D0%B5%D0%BD-%D0%BF%D0%B8%D1%81%D0%B0%D1%82%D1%8C-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA-a04cab35f45b)
- [Различные виды тестирования и их особенности](https://techrocks.ru/2018/12/08/different-types-of-testing/)

#### Unit-тесты
  
*Что проверяется?*
Модульные тесты проверяют, правильно ли работает каждый отдельный модуль (юнит) вашего кода. В идеале при планировании и написании модульных тестов нужно изолировать функционал, который нельзя разделить на более мелкие составляющие, и протестировать его.
  
  Модульные тесты не должны проверять внешние зависимости или взаимодействия. Вам определенно нужно сымитировать (mock out) api-вызовы. Борцы за чистоту модульных тестов будут также настаивать на имитации вызовов базы данных, чтобы убедиться, что ваш код, получая корректный input из внешних источников, ведет себя правильно. Модульные тесты должны быть быстрыми, иначе они значительно замедляют разработку.
  
*Когда их запускать?*
Вы должны писать и запускать модульные тесты параллельно со своим кодом.

#### Интеграционные тесты (Integration tests)
  
Этот термин употребляют чаще к тестам, покрывающим непосредственно публичный API сервиса. Фокус устремлен на проверку взаимодействия разных систем по принципу “сервис-клиент”.

*Что проверяется?*
Интеграционные тесты проверяют взаимодействие между двумя (или больше, чем двумя) отдельными юнитами вашего кода.
  
  Ваше приложение состоит из отдельных модулей, выполняющих определенные маленькие функции. Каждый из них может хорошо работать в изолированном состоянии, но ломаться в связке с другими.
  
  Интеграционные тесты также проверяют интеграцию вашего кода с внешними зависимостями, вроде соединений с базой данных или сторонними API.
  
*Когда их запускать?*
Интеграционные тесты это следующий шаг после модульных тестов.
  
*Что, если тесты провалены?*
Провал интеграционных тестов означает, что две (или больше) функции вашего приложения не работают вместе. Это могут быть два написанных вами модуля, которые приходят в противоречие из-за какой-то сложной бизнес-логики. Также провал может случиться из-за того, что изменилась структура ответа стороннего API. Провал тестов может быть предупреждением о плохой обработке ошибок в случае сбоя подключения к базе данных.
  
#### Функциональное тестирование

- Функциональное тестирование может быть определено как тестирование отдельных функций модулей.
- Это относится к тестированию программного продукта на индивидуальном уровне, чтобы проверить его функциональность.
- Оно сильно отличается от модульного или интеграционного тестирования; вы не можете написать бесчисленное множество тест-кейсов для функционального тестирования, поскольку оно является более сложным, чем модульное.
- Инструменты функционального тестирования стремятся проверить функциональные возможности (работоспособность) программного обеспечения. Тестовые примеры используются для проверки ожидаемых и неожиданных результатов тестирования программного обеспечения.
- Этот тип тестирования проводится больше с точки зрения пользователя. То есть, он рассматривает ожидание пользователя в выбранном типе ввода данных.
- Selenium является одним из наиболее распространенных инструментов, используемых для функционального тестирования.

#### Системный тест (System test, Service test)
  
  Автоматизированные тесты, проверяющие работу всей интегрированной системы. По сути, они представляют собой предельный случай интеграционных тестов. Системные тесты не проверяют бизнес-правила напрямую. Вместо этого они проверяют, что компоненты системы правильно связаны друг с другом, а взаимодействие между ними проходит по исходному плану. Тесты производительности и пропускной способности обычно относятся к этой категории.

Системное — это тестирование программы в целом. Для небольших проектов это, как правило, ручное тестирование — запустил, пощелкал, убедился, что (не) работает. Можно автоматизировать. К автоматизации есть два подхода.

Эти тесты пишутся системными архитекторами и ведущими специалистами с технической стороны. Как правило, они пишутся на том же языке и в той же среде, что и интеграционные тесты пользовательского интерфейса. Системные тесты выполняются относительно редко (в зависимости от продолжительности их выполнения), но чем чаще – тем лучше.

Системные тесты покрывают 10 % системы. Это объясняется тем, что они предназначены для проверки правильности не поведения системы, а ее конструкции. Правильность поведения нижележащего кода и компонентов уже была проверена на нижних уровнях пирамиды.

#### Проверка работоспособности (Smoke test, Sanity check)
  
  Это частный случай интеграционного теста. Обычно это очень небольшие тесты, которые прогоняются перед запуском системы, чтобы убедиться в работоспособности стороннего ПО, которое необходимо для корректного функционирования нашей системы. В случае провала таких тестов, мы можем оповестить пользователя о проблеме или и вовсе остановить запуск системы.
  
  Дымовое тестирование - пришло из сферы проверки оборудования, если, после подачи питания, появляется дым и запах гари, то оборудование неисправно.
  
Также дымовыми тестами можно сопровождать рефакторинг legacy кода, потому что написание полноценных юниттестов может быть сильно затратно по времени.

#### Регрессионное тестирование (Regression testing)
  
  Это может быть любой вид теста из описанных выше, который пишется после того, как была обнаружена проблема. Тест должен эмулировать в точности шаги для воспроизведения проблемы. Наличие такого теста после исправления проблемы дает гарантию, что точно такой же баг, больше не появится в системе.
  
*Что проверяется?*
Регрессионные тесты проверяют набор сценариев, которые раньше работали и должны быть относительно стабильными.

#### Прочее

- Приемочное тестирование
- Проверка на уязвимости (Penetration test, Pentest)
- Нагрузочное тестирование (Load testing)
- Тестирование производительности (Performance testing)
- Фаззинг тест (Fuzzing test, Fuzztest, Random test)
  
### Чем интеграционное тестирование отличается от функционального

- [Сравнение интеграционного и функционального тестирования](http://juice-health.ru/program/software-testing/497-integration-and-functional-testing)

Интеграционное и функциональное тестирования - это две фазы в процессе тестирования программного обеспечения. Первое проводится после модульного тестирования, а второе - метод тестирования черного ящика.

*Функциональное тестирование также упоминается как тестирование Е2Е для тестирования браузера.*

![Рис. Интеграционное тестирование против функционального тестирования](attachments/aed78f00.png)



[Тестируем Django с pytest. | Lexover's blog](http://lexover.ru/2021/03/07/test-django-using-pytest/)

[Pytest #0: Обзор курса - YouTube](https://www.youtube.com/watch?v=rAKIK5_UMzw&list=PLeLN0qH0-mCVdHgdjlnKTl4jKuJgCK-4b)